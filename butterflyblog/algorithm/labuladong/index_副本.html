<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>labuladong 的算法笔记 | isSeymour</title><meta name="author" content="isSeymour"><meta name="copyright" content="isSeymour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="labuladong的算法笔记 Start: 2025.03.01 End: 2025.03.31 Plan: AM 9:00 - 11:30 Check:    章节 (一) (二) (三) (四) (五) (六) (七)     基础 03.01 03.01 03.01 03.01 03.01 03.01 03.01    03.02 03.02 03.02 \ \ \ \   第零章 03.">
<meta property="og:type" content="website">
<meta property="og:title" content="labuladong 的算法笔记">
<meta property="og:url" content="https://isseymour.github.io/butterflyblog/algorithm/labuladong/index_%E5%89%AF%E6%9C%AC.html">
<meta property="og:site_name" content="isSeymour">
<meta property="og:description" content="labuladong的算法笔记 Start: 2025.03.01 End: 2025.03.31 Plan: AM 9:00 - 11:30 Check:    章节 (一) (二) (三) (四) (五) (六) (七)     基础 03.01 03.01 03.01 03.01 03.01 03.01 03.01    03.02 03.02 03.02 \ \ \ \   第零章 03.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp">
<meta property="article:published_time" content="2025-03-01T09:00:00.000Z">
<meta property="article:modified_time" content="2025-07-04T06:19:11.368Z">
<meta property="article:author" content="isSeymour">
<meta property="article:tag" content="博客, 个人网站">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/IC1011.ico"><link rel="canonical" href="https://isseymour.github.io/butterflyblog/algorithm/labuladong/index_%E5%89%AF%E6%9C%AC.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/butterflyblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/butterflyblog/',
  algolia: undefined,
  localSearch: {"path":"/butterflyblog/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'labuladong 的算法笔记',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-04 14:19:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/butterflyblog/code/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/labuladong/"><i class="fa-fw fa-solid fa-coffee"></i><span> labuladong</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/luogu/"><i class="fa-fw fa-solid fa-magnet"></i><span> 洛谷</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/RecSys/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> RecSys</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/isSeymour/PicGo/blog/page_img/TW1016.jpg')"><nav id="nav"><span id="blog-info"><a href="/butterflyblog/" title="isSeymour"><span class="site-name">isSeymour</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/labuladong/"><i class="fa-fw fa-solid fa-coffee"></i><span> labuladong</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/luogu/"><i class="fa-fw fa-solid fa-magnet"></i><span> 洛谷</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/RecSys/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> RecSys</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">labuladong 的算法笔记</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><div class="note danger no-icon flat"><p><a class="btn-beautify larger outline" target="_blank" rel="noopener" href="https://labuladong.online/" 
  title="labuladong的算法笔记"><i class="fa fa-share"></i><span>labuladong的算法笔记</span></a><br>
Start: 2025.03.01<br>
End: 2025.03.31<br>
Plan: AM 9:00 - 11:30<br>
Check:</p>
<table>
<thead>
<tr>
<th>章节</th>
<th>(一)</th>
<th>(二)</th>
<th>(三)</th>
<th>(四)</th>
<th>(五)</th>
<th>(六)</th>
<th>(七)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基础</strong></td>
<td>03.01</td>
<td>03.01</td>
<td>03.01</td>
<td>03.01</td>
<td>03.01</td>
<td>03.01</td>
<td>03.01</td>
</tr>
<tr>
<td></td>
<td>03.02</td>
<td>03.02</td>
<td>03.02</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td><strong>第零章</strong></td>
<td>03.04</td>
<td>03.05</td>
<td>03.06</td>
<td>03.07</td>
<td>03.08</td>
<td>03.09</td>
<td>03.09</td>
</tr>
<tr>
<td></td>
<td>03.10</td>
<td>03.11</td>
<td>03.12</td>
<td>03.13</td>
<td>03.13</td>
<td>03.14</td>
<td>\</td>
</tr>
<tr>
<td><strong>第一章</strong></td>
<td>03.15</td>
<td>04.08</td>
<td>04.09</td>
<td></td>
<td></td>
<td></td>
<td>04.09</td>
</tr>
<tr>
<td></td>
<td>04.10</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td><strong>第二章</strong></td>
<td></td>
<td></td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td><strong>第三章</strong></td>
<td></td>
<td></td>
<td>04.11</td>
<td></td>
<td></td>
<td>04.11</td>
<td>\</td>
</tr>
<tr>
<td><strong>第四章</strong></td>
<td></td>
<td></td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
</tbody>
</table>
<p>[TOC]</p>
</div>
<h1>前言：标准模板库 STL</h1>
<h2 id="数据结构">数据结构</h2>
<h3 id="1-vector">1. vector</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; b(n, vector&lt;<span class="type">int</span>&gt;(5, 0));</span><br><span class="line"></span><br><span class="line">a.resize(m);</span><br><span class="line">a.resize(m, 0);</span><br><span class="line">a.assign(n, 0);</span><br><span class="line"></span><br><span class="line">a[0] = 5;</span><br><span class="line">a.push_back(666);</span><br><span class="line">a.insert(a.begin() + 2, e); // 插入为第三个元素</span><br><span class="line">a.insert(a.end(), c.begin(), c.end());  // a+c</span><br><span class="line">a.erase(a.begin() + 2);     // 删除第三个元素</span><br><span class="line">a.clear();</span><br><span class="line"></span><br><span class="line">a.size();</span><br><span class="line">a.empty();</span><br><span class="line"></span><br><span class="line">a.front();</span><br><span class="line">a.back();</span><br></pre></td></tr></table></figure>
<h3 id="2-stack">2. stack</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">stk.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">stk.<span class="built_in">empty</span>();</span><br><span class="line">stk.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<h3 id="3-queue">3. queue</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line">Q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">Q.<span class="built_in">front</span>();</span><br><span class="line">Q.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">Q.<span class="built_in">empty</span>();</span><br><span class="line">Q.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<h3 id="4-deque">4. deque</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; DQ;</span><br><span class="line"></span><br><span class="line">DQ.<span class="built_in">push_front</span>(e);</span><br><span class="line">DQ.<span class="built_in">push_back</span>(e);</span><br><span class="line">DQ.<span class="built_in">pop_front</span>();</span><br><span class="line">DQ.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">DQ.<span class="built_in">front</span>();</span><br><span class="line">DQ.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">DQ.<span class="built_in">empty</span>();</span><br><span class="line">DQ.<span class="built_in">size</span>();</span><br><span class="line">DQ.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
<h3 id="5-unordered-set">5. unordered_set</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line">unorder_set&lt;<span class="type">int</span>&gt; Table;</span><br><span class="line"></span><br><span class="line">Table.<span class="built_in">insert</span>(e);</span><br><span class="line">Table.<span class="built_in">erase</span>(e);</span><br><span class="line">Table.<span class="built_in">emplace</span>(e);   <span class="comment">// 比 insert 更高效</span></span><br><span class="line"></span><br><span class="line">Table.<span class="built_in">count</span>(e);</span><br><span class="line">Table.<span class="built_in">find</span>(e);  <span class="comment">// 不存在则 Table.end()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Table.<span class="built_in">empty</span>();</span><br><span class="line">Table.<span class="built_in">size</span>();</span><br><span class="line">Table.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: Table)  cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="6-unordered-map">6. unordered_map</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">Map[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">Map.<span class="built_in">insert</span>(&#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">Map.<span class="built_in">erase</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Map.<span class="built_in">emplace</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = Map[<span class="string">&quot;apple&quot;</span>];</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">count</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Map.<span class="built_in">find</span>(<span class="string">&quot;apple&quot;</span>);  <span class="comment">// 不存在返回 Map.end()</span></span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">empty</span>();</span><br><span class="line">Map.<span class="built_in">size</span>();</span><br><span class="line">Map.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: Map)  cout &lt;&lt; x.first &lt;&lt; x.second &lt;&lt; endl;    <span class="comment">// apple  1</span></span><br></pre></td></tr></table></figure>
<h3 id="7-priority-queue">7. priority_queue</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;priority_queue&gt;</span></span></span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">maxHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">maxHeap.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">maxHeap.<span class="built_in">empty</span>();</span><br><span class="line">maxHeap.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DT</span>&#123;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">DT</span>(<span class="type">int</span> n, string na): <span class="built_in">no</span>(n), <span class="built_in">name</span>(na) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> DT &amp;a, <span class="type">const</span> DT &amp;b)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.no &lt; b.no;     <span class="comment">// no 越大，则 DT 越大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;DT, vector&lt;DT&gt;, Cmp&gt; maxHeap;</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="built_in">DT</span>(<span class="number">3</span>, <span class="string">&quot;Mary&quot;</span>));</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="built_in">DT</span>(<span class="number">1</span>, <span class="string">&quot;Smith&quot;</span>));</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="built_in">DT</span>(<span class="number">2</span>, <span class="string">&quot;John&quot;</span>));</span><br><span class="line"></span><br><span class="line">DT std = maxHeap.<span class="built_in">top</span>();  <span class="comment">// 3-Mary</span></span><br><span class="line">std.no;</span><br><span class="line">std.name;</span><br><span class="line"></span><br><span class="line">maxHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级队列，最小堆</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; minHeap;</span><br></pre></td></tr></table></figure>
<h3 id="8-string">8. string</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line">s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;      <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;  <span class="comment">// &quot;AAAAA&quot;</span></span><br><span class="line"></span><br><span class="line">s = s1 + s2;</span><br><span class="line">s += <span class="string">&quot;app&quot;</span>;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">&#x27;p&#x27;</span>);       <span class="comment">// 1</span></span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">&quot;le&quot;</span>);      <span class="comment">// 3</span></span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">&quot;banana&quot;</span>);  <span class="comment">// string::npos</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">length</span>();     <span class="comment">// 一样效果，两个返回值都是 size_t 类型，可以转 int</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = s[<span class="number">0</span>];</span><br><span class="line"><span class="type">char</span> ch = s.<span class="built_in">at</span>(<span class="number">3</span>);</span><br><span class="line">s[<span class="number">5</span>] = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;Insert&quot;</span>);    <span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">6</span>);            <span class="comment">// 从指定位置开始删除指定长度的字符</span></span><br><span class="line"></span><br><span class="line">string s5 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">s5.<span class="built_in">replace</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;AAAAA&quot;</span>);   <span class="comment">// abAAAAAfg</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> r1 = (s1 == s2);    <span class="comment">// 比较 true false</span></span><br><span class="line"><span class="type">int</span> r2 = s1.<span class="built_in">compare</span>(s2); <span class="comment">// 比较 -1, 0, 1 字典序比较</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)  cout &lt;&lt; s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> &amp;c : s)  cout &lt;&lt; c;</span><br><span class="line"></span><br><span class="line">string numS = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> numI = numS.<span class="built_in">stoi</span>(numS);</span><br><span class="line"><span class="type">double</span> numD = numS.<span class="built_in">stod</span>(numS);</span><br><span class="line"><span class="type">int</span> ai = <span class="number">34</span>;</span><br><span class="line">string aiS = <span class="built_in">to_string</span>(ai);</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());    <span class="comment">// 反转</span></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());       <span class="comment">// 字典序</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
<h3 id="9、list">9、list</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表容器，它允许在常数时间内进行任意位置的插入和删除操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(n)</span></span>;    <span class="comment">// n 个元素，全 0</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(n, <span class="number">8</span>)</span></span>; <span class="comment">// n 个元素，全 8</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l5</span><span class="params">(l4)</span></span>;</span><br><span class="line"></span><br><span class="line">myList.<span class="built_in">push_back</span>(<span class="number">10</span>);    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">myList.<span class="built_in">push_front</span>(<span class="number">20</span>);   <span class="comment">// 在开头添加元素</span></span><br><span class="line">myList.<span class="built_in">insert</span>(++myList.<span class="built_in">begin</span>(), <span class="number">30</span>); <span class="comment">// 在第二个位置插入30</span></span><br><span class="line"></span><br><span class="line">myList.<span class="built_in">pop_back</span>();       <span class="comment">// 删除末尾元素</span></span><br><span class="line">myList.<span class="built_in">pop_front</span>();      <span class="comment">// 删除开头元素</span></span><br><span class="line">myList.<span class="built_in">erase</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 删除第一个元素</span></span><br><span class="line">myList.<span class="built_in">remove</span>(<span class="number">10</span>);       <span class="comment">// 删除所有值为10的元素</span></span><br><span class="line">myList.<span class="built_in">clear</span>();          <span class="comment">// 清空list</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> first = myList.<span class="built_in">front</span>(); <span class="comment">// 第一个元素</span></span><br><span class="line"><span class="type">int</span> last = myList.<span class="built_in">back</span>();   <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = myList.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">bool</span> isEmpty = myList.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>(); it != myList.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : myList) &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向迭代器</span></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it = myList.<span class="built_in">begin</span>(); it != myList.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反向迭代器</span></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::reverse_iterator rit = myList.<span class="built_in">rbegin</span>(); rit != myList.<span class="built_in">rend</span>(); ++rit) &#123;</span><br><span class="line">    cout &lt;&lt; *rit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个已排序的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; list1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; list2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">list1.<span class="built_in">merge</span>(list2); <span class="comment">// list1变为1,2,3,4,5,6，list2为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">myList.<span class="built_in">sort</span>(); <span class="comment">// 默认升序</span></span><br><span class="line">myList.<span class="built_in">sort</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重（必须先排序）</span></span><br><span class="line">myList.<span class="built_in">unique</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line">myList.<span class="built_in">reverse</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接（转移元素）</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; otherList = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">myList.<span class="built_in">splice</span>(myList.<span class="built_in">end</span>(), otherList); <span class="comment">// 将otherList的元素移到myList末尾</span></span><br></pre></td></tr></table></figure>
<h2 id="算法与心得">算法与心得</h2>
<h3 id="1-algorithm">1. algorithm</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="built_in">swap</span>(vec[<span class="number">0</span>], vec[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 最值</span></span><br><span class="line"><span class="built_in">min</span>(a, b);</span><br><span class="line"><span class="built_in">max</span>(a, b);</span><br><span class="line"><span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br><span class="line"><span class="built_in">max</span>(&#123;a, b, c, d, e&#125;);</span><br><span class="line"><span class="built_in">min_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累积</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找（有序）</span></span><br><span class="line"><span class="type">bool</span> r = <span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) cout &lt;&lt; *it &lt;&lt; (it-vec.<span class="built_in">begin</span>())  &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现次数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 全部填充为 0</span></span><br><span class="line"><span class="built_in">replace</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">99</span>); <span class="comment">// 将 3 替换为 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(vec.size())</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转</span></span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="2-cmath">2. cmath</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用函数</span></span><br><span class="line"><span class="built_in">sqrt</span>(x);    <span class="comment">// 平方根</span></span><br><span class="line"><span class="built_in">cbrt</span>(x);    <span class="comment">// 立方根</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绝对值（整数、浮点数、长整数）</span></span><br><span class="line"><span class="built_in">abs</span>(a);</span><br><span class="line"><span class="built_in">fabs</span>(f);</span><br><span class="line"><span class="built_in">labs</span>(l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取整（向上取整、向下取整、四舍五入）</span></span><br><span class="line"><span class="built_in">ceil</span>(a);</span><br><span class="line"><span class="built_in">floor</span>(a);</span><br><span class="line"><span class="built_in">round</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指数</span></span><br><span class="line"><span class="built_in">exp</span>(k);     <span class="comment">// e^k</span></span><br><span class="line"><span class="built_in">exp2</span>(k);    <span class="comment">// 2^k</span></span><br><span class="line"><span class="built_in">pow</span>(a, k);  <span class="comment">// a^k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数</span></span><br><span class="line"><span class="built_in">log</span>(x);     <span class="comment">// 自然对数（e 底）</span></span><br><span class="line"><span class="built_in">log10</span>(x);   <span class="comment">// 常用对数（10 底）</span></span><br><span class="line"><span class="built_in">log2</span>(x);    <span class="comment">// 对数（2 底）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角函数</span></span><br><span class="line"><span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">cos</span>(x);</span><br><span class="line"><span class="built_in">tan</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反三角函数</span></span><br><span class="line"><span class="built_in">asin</span>(x);</span><br><span class="line"><span class="built_in">acos</span>(x);</span><br><span class="line"><span class="built_in">atan</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双曲函数</span></span><br><span class="line"><span class="built_in">sinh</span>(x);</span><br><span class="line"><span class="built_in">cosh</span>(x);</span><br><span class="line"><span class="built_in">tanh</span>(x);</span><br></pre></td></tr></table></figure>
<h3 id="3-必备实现">3. 必备实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大公约数 </span></span><br><span class="line"><span class="comment">// gcd(a, b) = gcd(b, a%b) 直到 b=0时，答案为a</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小公倍数</span></span><br><span class="line"><span class="comment">// lcm(a, b) = a * b / gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    a = <span class="built_in">abs</span>(a);</span><br><span class="line">    b = <span class="built_in">abs</span>(b);</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-心得操作与失误总结">4. 心得操作与失误总结</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证下一个检索元素不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">while</span>(i+<span class="number">1</span>&lt;n &amp;&amp; nums[i]==nums[i+<span class="number">1</span>])  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如若是需要 if 的逻辑，不要自作聪明写 =。</span></span><br><span class="line"><span class="comment">// 下面的两个方式结果在遍历后会不一样（会被覆盖）</span></span><br><span class="line"><span class="keyword">if</span>(color[i]==color[j])  flag = <span class="literal">false</span>;   <span class="comment">// 方式 1</span></span><br><span class="line">flag = color[i] != color[j];            <span class="comment">// 方式 2（会在遍历时被覆盖）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用栈和队列时，取值后面记得写 pop ！！！</span></span><br><span class="line"><span class="comment">// 如果发现超时，很可能是你压根没 pop 一直卡死</span></span><br><span class="line">Q.<span class="built_in">front</span>();  Q.<span class="built_in">pop</span>();</span><br><span class="line">S.<span class="built_in">top</span>();  S.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你发现能执行，题目也没写错，那么问题可能是你把int 写成了 bool （因为这个是能操作的，不会报错）</span></span><br><span class="line"><span class="comment">// 主要是在图：邻接表用 int，邻接矩阵用 bool。或者都用 int 也行</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G1;     <span class="comment">// 邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; G2;    <span class="comment">// 邻接矩阵</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G3;     <span class="comment">// 邻接矩阵+权重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对自己设计的数据结构排序</span></span><br><span class="line"><span class="comment">// 设计一个三元组的数组，按照第三个元素排序</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; MD;</span><br><span class="line">MD.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">88</span>&#125;);</span><br><span class="line">MD.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">66</span>&#125;);</span><br><span class="line">MD.<span class="built_in">push_back</span>(&#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">99</span>&#125;);</span><br><span class="line"><span class="built_in">sort</span>(MD.<span class="built_in">begin</span>(), MD.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; B)&#123;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">2</span>] &lt; B[<span class="number">2</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 优先队列不是 front 而是 top（因为本质是二叉堆，是树结构）</span></span><br><span class="line">Q.<span class="built_in">front</span>();  <span class="comment">// 队列</span></span><br><span class="line">S.<span class="built_in">top</span>();    <span class="comment">// 栈</span></span><br><span class="line">PQ.<span class="built_in">top</span>();   <span class="comment">// 优先队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于使用 cmp </span></span><br><span class="line"><span class="comment">// 1. sort 里面希望从小到大排序则用：</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 最小堆使用：</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; B)&#123;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">2</span>] &gt; B[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">priority_quque&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; PQ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动态规划初始化，看情况，别乱覆盖了</span></span><br><span class="line"><span class="comment">// 错误（区别在 dp[0][0]会被覆盖）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=m; j++)  dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)  dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多变量状态的哈希方法：字符串哈希表</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; memo;    <span class="comment">// 备忘录</span></span><br><span class="line">string key = <span class="built_in">to_string</span>(i) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">to_string</span>(remain);</span><br><span class="line">memo[key] = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划备忘录，你别光用不记录啊！</span></span><br><span class="line"><span class="comment">// 错误：</span></span><br><span class="line">string cur = <span class="built_in">to_string</span>(i) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">to_string</span>(remain);</span><br><span class="line"><span class="keyword">if</span>(memo.<span class="built_in">find</span>(cur) != memo.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> memo[cur];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain-nums[i]) + <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain+nums[i]);</span><br><span class="line"><span class="comment">// 正确：</span></span><br><span class="line">string cur = <span class="built_in">to_string</span>(i) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">to_string</span>(remain);</span><br><span class="line"><span class="keyword">if</span>(memo.<span class="built_in">find</span>(cur) != memo.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> memo[cur];</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain-nums[i]) + <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain+nums[i]);</span><br><span class="line">memo[cur] = res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划，多想一想子问题如何慢慢推出完整问题，一般是选前/后 i 个量、达到 j 能否完成/完成的方法数。</span></span><br><span class="line"><span class="comment">// 贪心问题，多画图看看：一般是某个 change 量的折线图，然后看最低点。</span></span><br><span class="line"><span class="comment">// 贪心思路的本质，如果找不到重复计算，那就通过问题中一些隐藏较深的规律，来减少冗余计算。</span></span><br><span class="line"><span class="comment">// 一般是刚好可以把第二层的循环去掉，也就是说：</span></span><br><span class="line"><span class="comment">// 仔细思考，会发现第二层的循环失败的位置j，会刚好成为第一层循环的i的下一个位置。</span></span><br><span class="line"><span class="comment">// 这样子就会使得两层循环实际上是一层循环！！！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>基础：数据结构及排序</h1>
<h2 id="一-数组（静态、动态）">(一) 数组（静态、动态）</h2>
<p>动态数组底层还是静态数组，只是自动帮我们进行<strong>数组空间的扩缩容</strong>，并把增删查改操作进行了封装，让我们使用起来更方便而已。</p>
<h2 id="二-链表（单、双）">(二) 链表（单、双）</h2>
<p>略</p>
<h2 id="三-变种：环形数组、跳表">(三) 变种：环形数组、跳表</h2>
<ol>
<li>
<p>环形数组：</p>
<ul>
<li>环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间在数组头部增删元素。</li>
<li>核心原理：环形数组的关键在于，它维护了两个指针 <code>start</code> 和 <code>end</code>，<code>start</code> 指向第一个有效元素的索引，<code>end</code> 指向最后一个有效元素的下一个位置索引。</li>
<li>理论上，你可以随意设计区间的开闭，但一般设计为<strong>左闭右开</strong>区间是最方便处理的。因为这样初始化 <code>start = end = 0</code> 时，区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>end</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。</li>
</ul>
</li>
<li>
<p>跳表<br>
一条普通的单链表长这样：</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index  0  1  2  3  4  5  6  7  8  9</span><br><span class="line">node   a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h-&gt;i-&gt;j</span><br></pre></td></tr></table></figure>
<p>如果我们想查询索引为 <code>7</code> 的元素是什么，只能从索引 <code>0</code> 头结点开始往后遍历，直到遍历到索引 <code>7</code>，找到目标节点 <code>h</code>。</p>
<p>而跳表则是这样的：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indexLevel   0-----------------------8-----10</span><br><span class="line">indexLevel   0-----------4-----------8-----10</span><br><span class="line">indexLevel   0-----2-----4-----6-----8-----10</span><br><span class="line">indexLevel   0--1--2--3--4--5--6--7--8--9--10</span><br><span class="line">nodeLevel    a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h-&gt;i-&gt;j-&gt;k</span><br></pre></td></tr></table></figure>
<p>此时，如果我们想查询索引为 <code>7</code> 的元素，可以从最高层索引开始一层一层地往下找，这个搜索过程中，会经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 层索引，在每层索引中移动的次数不会超过 2 次（因为上层索引区间在下一层被分为两半），所以跳表的查询时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="四-队列、栈、双端队列">(四) 队列、栈、双端队列</h2>
<ol>
<li>
<p>其实队列和栈都是<code>操作受限</code>的数据结构。</p>
</li>
<li>
<p>队列只能在一端插入元素，另一端删除元素；<br>
栈只能在某一端插入和删除元素。<br>
而双端队列的队头和队尾都可以插入或删除元素。</p>
</li>
</ol>
<h2 id="五-哈希表、哈希集合、加强哈希表">(五) 哈希表、哈希集合、加强哈希表</h2>
<p>略</p>
<h2 id="六-二叉树">(六) 二叉树</h2>
<h3 id="1-满二叉树">1. 满二叉树</h3>
<p>直接看图比较直观，满二叉树就是每一层节点都是满的，整棵树像一个正三角形：</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/perfect.png" alt="满二叉树"></p>
<p>满二叉树有个优势，就是它的节点个数很好算。假设深度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，那么总节点数就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<h3 id="2-完全二叉树">2. 完全二叉树</h3>
<p>完全二叉树是指，二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/complete.png" alt="完全二叉树"></p>
<p>不难发现，满二叉树其实是一种特殊的完全二叉树。</p>
<p><strong>完全二叉树的特点</strong>：由于它的节点紧凑排列，如果从左到右从上到下对它的每个节点编号，那么父子节点的索引存在明显的规律。</p>
<p>这个特点在讲到 二叉堆核心原理 和 线段树核心原理 时会用到：<strong>完全二叉树可以用数组来存储，不需要真的构建链式节点</strong>。</p>
<p>完全二叉树还有个比较难发觉的性质：<strong>完全二叉树的左右子树也是完全二叉树</strong>。</p>
<p>或者更准确地说应该是：<strong>完全二叉树的左右子树中，至少有一棵是满二叉树</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/complete1-2.jpg" alt="完全二叉树的隐藏性质"></p>
<h3 id="3-平衡二叉树">3. 平衡二叉树</h3>
<p>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，<strong>它的每个节点的左右子树的高度差不超过 1</strong>。</p>
<p>要注意是每个节点，而不仅仅是根节点。</p>
<p>假设平衡二叉树中共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个节点，那么平衡二叉树的高度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>这是非常重要的性质，后面讲到的 <code>红黑树</code> 和 <code>线段树</code> 会利用平衡二叉树的这个性质，保证算法的高效性。</p>
<h3 id="4-二叉搜索树">4. 二叉搜索树</h3>
<p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常见的二叉树，它的定义是：对于树中的每个节点，其<strong>左子树的每个节点</strong>的值都要小于这个节点的值，<strong>右子树的每个节点</strong>的值都要大于这个节点的值。你可以简单记为 <strong>左小右大</strong>。</p>
<p>BST 是非常常用的数据结构。因为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在。</p>
<h3 id="5-递归遍历-DFS">5. 递归遍历(DFS)</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的二叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>
<p>这个<strong>递归遍历节点顺序是固定的</strong>，务必记住这个顺序，否则你肯定玩不转二叉树结构。</p>
</li>
<li>
<p>二叉树有前/中/后序三种遍历，会得到三种不同顺序的结果。为啥你这里说递归遍历节点的顺序是固定的呢？</p>
</li>
</ol>
<ul>
<li>
<p>递归遍历的顺序，即 <code>traverse</code> 函数访问节点的顺序确实是固定的。正如上面那个可视化面板，root 指针在树上移动的顺序是固定的。</p>
</li>
<li>
<p>前中后序遍历的结果不同，原因是因为你把操作效果代码写在了不同位置，所以产生了不同的效果。</p>
</li>
</ul>
<ol start="3">
<li>BST 的中序遍历结构有序。</li>
</ol>
</blockquote>
<h3 id="6-层序遍历-BFS">6. 层序遍历(BFS)</h3>
<p>二叉树的层序遍历，顾名思义，就是一层一层地遍历二叉树。</p>
<p>这个遍历方式需要借助队列来实现，而且根据不同的需求，主要有三种不同的写法，下面一一列举。</p>
<p>（1）写法一</p>
<ul>
<li>优点：简单</li>
<li>缺点：无法知道当前是第几层</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 访问 cur 节点</span></span><br><span class="line">        std::cout &lt;&lt; cur-&gt;val &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知道节点的层数是个常见的需求，比方说让你收集每一层的节点，或者计算二叉树的最小深度等等。</p>
<p>所以这种写法虽然简单，但用的不多，下面介绍的写法会更常见一些。</p>
</blockquote>
<p>（2）写法二</p>
<ul>
<li>优点</li>
<li>缺点：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个变量 <code>i</code> 记录的是节点 <code>cur</code> 是当前层的第几个，大部分算法题中都不会用到这个变量。</p>
<p>但是注意队列的长度 <code>sz</code> 一定要<strong>在循环开始前保存</strong>下来，因为在循环过程中队列的长度是会变化的，不能直接用 <code>q.size()</code> 作为循环条件。</p>
<p>这种写法就可以记录下来每个节点所在的层数，可以解决诸如二叉树最小深度这样的问题，是我们最常用的层序遍历写法。</p>
<p>（3）写法三</p>
<p>既然写法二是最常见的，为啥还有个写法三呢？因为要给后面的进阶内容做铺垫。</p>
<p>回顾写法二，我们每向下遍历一层，就给 <code>depth</code> 加 <code>1</code>，可以理解为每条树枝的权重是 <code>1</code>，二叉树中每个节点的深度，其实就是从根节点到这个节点的路径权重和，且同一层的所有节点，路径权重和都是相同的。</p>
<p>那么假设，如果每条树枝的权重和可以是任意值，现在让你层序遍历整棵树，打印每个节点的路径权重和，你会怎么做？</p>
<p>写法三就是为了解决这个问题，在写法一的基础上添加一个 <code>State</code> 类，让每个节点自己负责维护自己的路径权重和，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">State</span>(TreeNode* node, <span class="type">int</span> depth) : <span class="built_in">node</span>(node), <span class="built_in">depth</span>(depth) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;State&gt; q;</span><br><span class="line">    <span class="comment">// 根节点的路径权重和是 1</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        State cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 访问 cur 节点，同时知道它的路径权重和</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; cur.depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur.node-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur.node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">State</span>(cur.node-&gt;left, cur.depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">State</span>(cur.node-&gt;right, cur.depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每个节点都有了自己的 <code>depth</code> 变量，是最灵活的，可以满足所有 BFS 算法的需求。</p>
<p>其实你很快就会学到，这种边带有权重的场景属于图结构算法，在之后的 BFS 算法习题集 和 dijkstra 算法 中，才会用到这种写法。</p>
<blockquote>
<p>二叉树的遍历方式只有上面两种，也许有其他的写法，但都是表现形式上的差异，本质上不可能跳出上面两种遍历方式。</p>
<p><strong>DFS 算法在寻找所有路径的问题中更常用。</strong></p>
<p><strong>而 BFS 算法在寻找最短路径的问题中更常用。</strong></p>
<ol>
<li>为什么 BFS 常用来寻找最短路径?</li>
</ol>
<ul>
<li>
<p>对于 DFS，你能不能在不遍历完整棵树的情况下，提前结束算法？<br>
不可以，因为你必须确切的知道每条树枝的深度（根节点到叶子节点的距离），才能找到最小的那个。<br>
即，<strong>DFS 遍历当然也可以用来寻找最短路径，但必须遍历完所有节点才能得到最短路径</strong>。</p>
</li>
<li>
<p>对于 BFS，<strong>由于 BFS 逐层遍历的逻辑，第一次遇到目标节点时，所经过的路径就是最短路径，算法可能并不需要遍历完所有节点就能提前结束</strong>。</p>
</li>
<li>
<p>从时间复杂度的角度来看，两种算法在最坏情况下都会遍历所有节点，时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，但在一般情况下，显然 BFS 算法的实际效率会更高。所以在<strong>寻找最短路径的问题中，BFS 算法是首选</strong>。</p>
</li>
</ul>
<ol start="2">
<li>为什么 DFS 常用来寻找所有路径?</li>
</ol>
<ul>
<li>
<p>你想啊，就以二叉树为例，如果要用 BFS 算法来寻找所有路径（根节点到每个叶子节点都是一条路径），队列里面就不能只放节点了，而需要使用第三种写法，新建一个 <code>State</code> 类，<strong>把当前节点以及到达当前节点的路径都存进去，这样才能正确维护每个节点的路径</strong>，最终计算出所有路径。</p>
</li>
<li>
<p>而使用 DFS 算法就简单了，<strong>它本就是一条树枝一条树枝从左往右遍历的，每条树枝就是一条路径，所以 DFS 算法天然适合寻找所有路径</strong>。</p>
</li>
</ul>
</blockquote>
<h2 id="七-多叉树">(七) 多叉树</h2>
<p>二叉树的节点长这样，每个节点有两个子节点。多叉树的节点长这样，每个节点有任意个子节点。就这点区别，其他没了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>森林：森林就是多个多叉树的集合。一棵多叉树其实也是一个特殊的森林。</p>
<p>在并查集算法中，我们会同时持有多棵多叉树的根节点，那么这些根节点的集合就是一个森林。</p>
</blockquote>
<h3 id="1-递归遍历（DFS）">1. 递归遍历（DFS）</h3>
<p>唯一的区别是，多叉树没有了中序位置，因为可能有多个节点嘛，所谓的中序位置也就没什么意义了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N 叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-层序遍历（BFS）">2. 层序遍历（BFS）</h3>
<p>多叉树的层序遍历和 二叉树的层序遍历 一样，都是用队列来实现，无非就是把二叉树的左右子节点换成了多叉树的所有子节点。所以多叉树的层序遍历也有三种写法，下面一一列举。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：简单层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 访问 cur 节点</span></span><br><span class="line">        std::cout &lt;&lt; cur-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 cur 的所有子节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：记录节点深度</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：适配不同权重边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* node;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">State</span>(Node* node, <span class="type">int</span> depth) : <span class="built_in">node</span>(node), <span class="built_in">depth</span>(depth) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::queue&lt;State&gt; q;</span><br><span class="line">    <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        State state = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        Node* cur = state.node;</span><br><span class="line">        <span class="type">int</span> depth = state.depth;</span><br><span class="line">        <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">State</span>(child, depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>。</p>
<h2 id="八-二叉树变种">(八) 二叉树变种</h2>
<h3 id="1-二叉搜索树">1. 二叉搜索树</h3>
<ul>
<li>二叉搜索树是特殊的 二叉树结构，其主要的实际应用是 <code>TreeMap</code> 和 <code>TreeSet</code>。</li>
<li>对于树中的每个节点，其<strong>左子树的每个节点</strong>的值都要小于这个节点的值，<strong>右子树的每个节点</strong>的值都要大于这个节点的值。</li>
<li>这个<strong>左小右大</strong>的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在。</li>
<li>理想的时间复杂度是树的高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，而普通的二叉树遍历函数则需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间遍历所有节点。</li>
<li>增删改的时间复杂度也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>前文说复杂度是树的高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mtext>（</mtext><mi>N</mi><mtext>为节点总数）</mtext></mrow><annotation encoding="application/x-tex">O(logN)（N 为节点总数）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">为节点总数）</span></span></span></span>，这是有前提的，即<strong>二叉搜索树要是平衡的，也就是左右子树的高度差不能太大</strong>。<br>
如果搜索树不平衡，比如这种极端情况，所有节点都只有右子树，没有左子树。这样二叉搜索树其实退化成了一条单链表，树的高度等于节点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这种情况下，即便这棵树符合 BST 的定义，但是性能就退化成了链表的性能，复杂度全部变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>二叉搜索树的性能取决于树的高度，树的高度取决于树的平衡性。</strong></li>
<li>大家熟知的红黑树就是一类自平衡的二叉搜索树，它的平衡性能非常好，但是实现起来比较复杂，这就是完美所需付出的代价。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    7</span><br><span class="line">   / \</span><br><span class="line">  4   9</span><br><span class="line"> / \   \</span><br><span class="line">1   5   10</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>TreeMap/TreeSet 实现原理</strong></p>
<p>它和前文介绍的 哈希表 <code>HashMap</code> 的结构是类似的，都是<strong>存储键值对</strong>的，<code>HashMap</code> 底层把键值对存储在一个 <code>table</code> 数组里面，而 <code>TreeMap</code> 底层把<strong>键值对存储在一棵二叉搜索树的节点</strong>里面。</p>
<p>至于 <code>TreeSet</code>，它和 <code>TreeMap</code> 的关系正如哈希表 <code>HashMap</code> 和哈希集合 <code>HashSet</code> 的关系一样，说白了就是 <code>TreeMap</code> 的简单封装，所以下面主要讲解 <code>TreeMap</code> 的实现原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通 TreeNode</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改得到 TreeMap</span></span><br><span class="line"><span class="comment">// 大写 K 为键的类型，大写 V 为值的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    TreeNode&lt;K, V&gt;* left;</span><br><span class="line">    TreeNode&lt;K, V&gt;* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(K key, V value) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get</code> 方法其实就类似上面可视化面板中查找目标节点的操作，根据目标 <code>key</code> 和当前节点的 <code>key</code> 比较，决定往左走还是往右走，可以一次性排除掉一半的节点，复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>至于 <code>put</code>, <code>remove</code>, <code>containsKey</code> 方法，其实也是要先利用 <code>get</code> 方法找到目标键所在的节点，然后做一些指针操作，复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li><code>keys</code> 方法返回所有键，且结果有序。可以利用 BST 的中序遍历结果有序的特性。</li>
</ul>
</blockquote>
<h3 id="2-红黑树">2. 红黑树</h3>
<ul>
<li>红黑树是自平衡的二叉搜索树，它的树高在任何时候都能保持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>（完美平衡），这样就能保证增删查改的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<h3 id="3-Tire-字典树-前缀树">3. Tire(字典树/前缀树)</h3>
<ul>
<li>Trie 树本质上就是一棵从二叉树衍生出来的多叉树。</li>
<li>Trie 树就是 <strong>多叉树结构</strong> 的延伸，是一种针对字符串进行特殊优化的数据结构。</li>
<li>Trie 树在处理字符串相关操作时有诸多优势，比如节省公共字符串前缀的内存空间、方便处理前缀操作、支持通配符匹配等。</li>
<li>这里要特别注意，<code>TrieNode</code> 节点本身只存储 <code>val</code> 字段，并没有一个字段来存储字符，字符是通过子节点在父节点的 <code>children</code> 数组中的索引确定的。形象理解就是，Trie 树用<strong>树枝</strong>存储字符串（键），用<strong>节点</strong>存储字符串（键）对应的数据（值）。所以我在图中把字符标在树枝，键对应的值 <code>val</code> 标在节点上：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trie 树节点实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    V val = <span class="literal">NULL</span>;</span><br><span class="line">    TrieNode&lt;V&gt;* children[<span class="number">256</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 <code>val</code> 字段存储键对应的值，<code>children</code> 数组存储指向子节点的指针。但是和之前的普通多叉树节点不同，<code>TrieNode</code> 中 <code>children</code> 数组的索引是有意义的，代表键中的一个字符。</p>
<blockquote>
<p>比如在实际做题时，题目说了只包含字符 <code>a-z</code>，那么你可以把大小改成 <code>26</code>；或者你不想用字符索引来映射，直接用哈希表 <code>HashMap&lt;Character, TrieNode&gt;</code> 也可以，都是一样的效果。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tire-example.jpeg" alt="Tire树"></p>
<h3 id="4-二叉堆">4. 二叉堆</h3>
<ul>
<li>二叉堆是一种能够动态排序的数据结构，是二叉树结构的延伸。</li>
<li>两个核心操作：下沉<code>sink</code>和上浮<code>swim</code>。</li>
<li>主要应用：优先队列<code>priority_queue</code>、堆排序<code>heap_sort</code>。</li>
</ul>
<blockquote>
<p>能够动态排序的数据结构，只有两个：1. 优先队列（底层采用二叉堆实现）2. 二叉搜索树<br>
二叉搜索树的功能更广，但是优先队列的 API 代码更简单，一般采用优先队列。</p>
</blockquote>
<ul>
<li>你可以认为二叉堆是一种特殊的二叉树，这棵二叉树上的任意节点的值，都必须大于等于（或小于等于）其左右子树<strong>所有</strong>节点的值。如果是大于等于，我们称之为<code>大顶堆</code>，如果是小于等于，我们称之为<code>小顶堆</code>。</li>
<li>二叉堆可以辅助我们快速找到最大值或最小值。</li>
<li>二叉堆还有个性质：<strong>一个二叉堆的左右子堆（子树）也是一个二叉堆</strong>。</li>
<li>应用 1：优先队列
<ul>
<li>自动排序是有代价的，注意优先级队列 API 的时间复杂度，<strong>增删元素</strong>的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mtext>其中</mtext><mi>N</mi><mtext>是当前二叉堆中的元素个数</mtext></mrow><annotation encoding="application/x-tex">O(\log N)其中 N 是当前二叉堆中的元素个数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord cjk_fallback">其中</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">是当前二叉堆中的元素个数</span></span></span></span>。</li>
<li>标准队列是先进先出的顺序，而二叉堆可以理解为一种<strong>会自动排序的队列</strong>，所以叫做优先级队列感觉也挺贴切的。当然，你也一定要明白，虽然它的 API 像队列，但<strong>它的底层原理和二叉树有关，和队列没啥关系</strong>。</li>
</ul>
<blockquote>
<ul>
<li>
<p>以小顶堆为例，向小顶堆中<strong>插入</strong>新元素遵循两个步骤：<br>
1、先把新元素追加到二叉树底层的最右侧，保持完全二叉树的结构。此时该元素的父节点可能比它大，不满足小顶堆的性质。<br>
2、为了恢复小顶堆的性质，需要将这个新元素不断上浮（swim），直到它的父节点比它小为止，或者到达根节点。此时整个二叉树就满足小顶堆的性质了。</p>
</li>
<li>
<p>以小顶堆为例，<strong>删除</strong>小顶堆的堆顶元素遵循两个步骤：<br>
1、先把堆顶元素删除，把二叉树底层的最右侧元素摘除并移动到堆顶，保持完全二叉树的结构。此时堆顶元素可能比它的子节点大，不满足小顶堆的性质。<br>
2、为了恢复小顶堆的性质，需要将这个新的堆顶元素不断下沉（sink），直到它比它的子节点小为止，或者到达叶子节点。此时整个二叉树就满足小顶堆的性质了。</p>
</li>
<li>
<p><strong>在数组上模拟二叉树：</strong><br>
正常情况下你如何拿到二叉树的底层最右侧节点？你需要层序遍历或递归遍历二叉树，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，进而导致 <code>push</code> 和 <code>pop</code> 方法的时间复杂度退化到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这显然是不可接受的。如果用数组来模拟二叉树，就可以完美解决这个问题，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间内找到二叉树的<strong>底层最右侧节点</strong>。</p>
</li>
<li>
<p>完全二叉树是关键：<br>
想要用数组模拟二叉树，前提是这个二叉树<strong>必须是完全二叉树</strong>。<br>
直接在数组的末尾追加元素，就相当于在完全二叉树的最后一层从左到右依次填充元素；<br>
数组中最后一个元素，就是完全二叉树的底层最右侧的元素，完美契合我们实现二叉堆的场景。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.png" alt="优先队列-数组实现"></p>
</li>
</ul>
<p>在这个数组中，索引 0 空着不用，就可以根据任意节点的索引计算出父节点或左右子节点的索引：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左子节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实从 0 开始也是可以的，稍微改一改计算公式就行了。</p>
</blockquote>
</li>
</ul>
<p>完整实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMinPQ</span> &#123;</span><br><span class="line">    <span class="comment">// 底层使用数组实现二叉堆</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆中元素的数量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (node - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右子节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮操作，时间复杂度是树高 O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node &gt; <span class="number">0</span> &amp;&amp; heap[<span class="built_in">parent</span>(node)] &gt; heap[node]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[<span class="built_in">parent</span>(node)], heap[node]);</span><br><span class="line">            node = <span class="built_in">parent</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉操作，时间复杂度是树高 O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">left</span>(node) &lt; size || <span class="built_in">right</span>(node) &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 比较自己和左右子节点，看看谁最小</span></span><br><span class="line">            <span class="type">int</span> min = node;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">left</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">left</span>(node)] &lt; heap[min]) &#123;</span><br><span class="line">                min = <span class="built_in">left</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">right</span>(node)] &lt; heap[min]) &#123;</span><br><span class="line">                min = <span class="built_in">right</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min == node) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左右子节点中有比自己小的，就交换</span></span><br><span class="line">            <span class="built_in">swap</span>(heap[node], heap[min]);</span><br><span class="line">            node = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化容量</span></span><br><span class="line">    <span class="built_in">SimpleMinPQ</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        heap.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回堆的元素数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，返回堆顶元素，时间复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增，向堆中插入一个元素，时间复杂度 O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把新元素追加到最后</span></span><br><span class="line">        heap[size] = x;</span><br><span class="line">        <span class="comment">// 然后上浮到正确位置</span></span><br><span class="line">        <span class="built_in">swim</span>(size);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删，删除堆顶元素，时间复杂度 O(logN)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = heap[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 把堆底元素放到堆顶</span></span><br><span class="line">        heap[<span class="number">0</span>] = heap[size - <span class="number">1</span>];</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 然后下沉到正确位置</span></span><br><span class="line">        <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SimpleMinPQ <span class="title">pq</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">pop</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">pop</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">pop</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">pop</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; pq.<span class="built_in">pop</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应用 2：堆排序
<ul>
<li>它的原理特别简单，就相当于把一个乱序的数组都 <code>push</code> 到一个二叉堆（优先级队列）里面，然后再一个个 <code>pop</code> 出来，就得到了一个有序的数组。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序伪码，对 arr 原地排序</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(NlogN)，空间复杂度 O(N)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    MyPriorityQueue pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : arr)</span><br><span class="line">        pq.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="comment">// 元素出堆的顺序是有序的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        res[i] = pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，正常的堆排序算法的代码并不依赖优先级队列，且空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。那是因为它把 <code>push</code> 和 <code>pop</code> 的代码逻辑展开了，再加上直接在数组上原地建堆，这样就不需要额外的空间了。<br>
刚才不是说二叉堆是一种特殊的二叉树吗？怎么可能不使用额外的空间复杂度，直接在数组上原地创建二叉树呢？<br>
<strong>二叉树</strong>是一种<strong>逻辑概念</strong>，并不是说只有 <code>TreeNode</code> 类构造出来的那个结构才是二叉树，其实数组也可以抽象成一棵树，一切分治穷举的思想都可以抽象成一棵树，递归函数的那个递归栈也可以理解成一棵树。</p>
</blockquote>
</li>
</ul>
<h3 id="5-线段树">5. 线段树</h3>
<ul>
<li>线段树是二叉树结构的衍生，用于高效解决区间查询和动态修改的问题。
<ul>
<li>区间查询：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>动态修改单个元素：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>这棵二叉树的叶子节点是数组中的元素，非叶子节点就是索引区间（线段）的汇总信息。</li>
<li>希望对整个区间进行查询，同时支持动态修改元素的场景，是线段树结构的应用场景。</li>
</ul>
<h2 id="九-图论">(九) 图论</h2>
<h3 id="1-图结构">1. 图结构</h3>
<ul>
<li>图结构就是 <strong>多叉树结构</strong> 的延伸。图结构逻辑上由若干节点（<code>Vertex</code>）和边（<code>Edge</code>）构成，我们一般用邻接表、邻接矩阵等方式来存储图。</li>
<li>在树结构中，只允许父节点指向子节点，不存在子节点指向父节点的情况，子节点之间也不会互相链接；而图中没有那么多限制，节点之间可以相互指向，形成复杂的网络结构。</li>
<li>图的逻辑结构:一幅图是由节点 (Vertex) 和边 (Edge) 构成的，逻辑结构如下：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tu-luoji.jpg" alt="图的逻辑结构"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tu-ljbljjz.jpeg" alt="邻接表与邻接矩阵"></li>
<li></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图节点的逻辑结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;Vertex*&gt; neighbors;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有一条指向 y 的边</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; matrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比</span></span><br><span class="line"><span class="comment">// 基本的 N 叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    std::vector&lt;TreeNode*&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>节点类型不是 int 怎么办?</strong><br>
上述讲解中，我默认图节点是一个从 0 开始的整数，所以才能存储到邻接表和邻接矩阵中，通过索引访问。<br>
但实际问题中，图节点可能是其他类型，比如字符串、自定义类等，那应该怎么存储呢？很简单，你再额外使用一个<strong>哈希表</strong>，把实际节点和整数 id 映射起来，然后就可以用邻接表和邻接矩阵存储整数 id 了。<br>
后面的讲解及习题中，我都会默认图节点是整数 id。</li>
<li>对于一幅有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 个节点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 条边的图，邻接表的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>（稀疏图），而邻接矩阵的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（稠密图）。<br>
在后面的图算法和习题中，大多都是稀疏图，所以你会看到<strong>邻接表</strong>的使用更多一些。<br>
<strong>邻接矩阵的最大优势在于，矩阵是一个强有力的数学工具</strong>，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。这也是为什么<strong>一定要把图节点类型转换成整数 id 的原因</strong>，不然的话你怎么用矩阵运算呢？</li>
</ul>
</blockquote>
<p>完整实现（邻接表）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加权有向图的通用实现（邻接表）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedDigraph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存储相邻节点及边的权重</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to, <span class="type">int</span> weight) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;to = to;</span><br><span class="line">            <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 邻接表，graph[v] 存储节点 v 的所有邻居节点及对应权重</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WeightedDigraph</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 我们这里简单起见，建图时要传入节点总数，这其实可以优化</span></span><br><span class="line">        <span class="comment">// 比如把 graph 设置为 Map&lt;Integer, List&lt;Edge&gt;&gt;，就可以动态添加新节点了</span></span><br><span class="line">        graph = vector&lt;vector&lt;Edge&gt;&gt;(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增，添加一条带权重的有向边，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">        graph[from].<span class="built_in">emplace_back</span>(to, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删，删除一条有向边，复杂度 O(V)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = graph[from].<span class="built_in">begin</span>(); it != graph[from].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;to == to) &#123;</span><br><span class="line">                graph[from].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，判断两个节点是否相邻，复杂度 O(V)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : graph[from]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.to == to) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，返回一条边的权重，复杂度 O(V)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : graph[from]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.to == to) &#123;</span><br><span class="line">                <span class="keyword">return</span> e.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;No such edge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，返回某个节点的所有邻居节点，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">const</span> vector&lt;Edge&gt;&amp; <span class="title">neighbors</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> graph[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">WeightedDigraph <span class="title">graph</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// true</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : graph.<span class="built_in">neighbors</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2 -&gt; &quot;</span> &lt;&lt; edge.to &lt;&lt; <span class="string">&quot;, wight: &quot;</span> &lt;&lt; edge.weight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 -&gt; 0, wight: 3</span></span><br><span class="line">    <span class="comment">// 2 -&gt; 1, wight: 4</span></span><br><span class="line"></span><br><span class="line">    graph.<span class="built_in">removeEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整实现（邻接矩阵）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加权有向图的通用实现（邻接矩阵）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedDigraph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存储相邻节点及边的权重</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> to, <span class="type">int</span> weight) : <span class="built_in">to</span>(to), <span class="built_in">weight</span>(weight) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WeightedDigraph</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        matrix = std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(n, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增，添加一条带权重的有向边，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">        matrix[from][to] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删，删除一条有向边，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        matrix[from][to] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，判断两个节点是否相邻，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[from][to] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，返回一条边的权重，复杂度 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[from][to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查，返回某个节点的所有邻居节点，复杂度 O(V)</span></span><br><span class="line">    <span class="function">std::vector&lt;Edge&gt; <span class="title">neighbors</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;Edge&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[v][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(i, matrix[v][i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 邻接矩阵，matrix[from][to] 存储从节点 from 到节点 to 的边的权重</span></span><br><span class="line">    <span class="comment">// 0 表示没有连接</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">WeightedDigraph <span class="title">graph</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    graph.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : graph.<span class="built_in">neighbors</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2 -&gt; &quot;</span> &lt;&lt; edge.to &lt;&lt; <span class="string">&quot;, weight: &quot;</span> &lt;&lt; edge.weight &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2 -&gt; 0, weight: 3</span></span><br><span class="line">    <span class="comment">// 2 -&gt; 1, weight: 4</span></span><br><span class="line"></span><br><span class="line">    graph.<span class="built_in">removeEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; graph.<span class="built_in">hasEdge</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-图的遍历">2. 图的遍历</h3>
<ul>
<li>图的遍历就是 多叉树遍历 的延伸，主要遍历方式还是<strong>深度优先搜索（DFS）<strong>和</strong>广度优先搜索（BFS）</strong>。</li>
<li>唯一的区别是，树结构中不存在环，而<strong>图结构中可能存在环</strong>，所以我们需要<strong>标记遍历过的节点</strong>，避免遍历函数在环中死循环。</li>
<li>遍历图的「节点」和「路径」略有不同，遍历「<strong>节点</strong>」时，需要 visited 数组在<strong>前序位置</strong>标记节点；遍历图的所有「<strong>路径</strong>」时，需要 onPath 数组在<strong>前序位置</strong>标记节点，在<strong>后序位置</strong>撤销标记。</li>
</ul>
<ol>
<li><strong>深度优先搜索（DFS）</strong><br>
（1）遍历所有节点（visited 数组）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    std::vector&lt;Node*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; root-&gt;val &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;Vertex*&gt; neighbors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的遍历框架</span></span><br><span class="line"><span class="comment">// 需要一个 visited 数组记录被遍历过的节点</span></span><br><span class="line"><span class="comment">// 避免走回头路陷入死循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Vertex* s, std::vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s-&gt;id]) &#123;</span><br><span class="line">        <span class="comment">// 防止死循环</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    visited[s-&gt;id] = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; s-&gt;id &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> neighbor : s-&gt;neighbors) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)遍历所有路径（onPath 数组）<br>
前文遍历节点的代码中，visited 数组的职责是保证每个节点只会被访问一次。而对于图结构来说，要想遍历所有路径，可能会多次访问同一个节点，这是关键的区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的算法代码可以遍历图的所有路径，寻找从 src 到 dest 的所有路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// onPath 和 path 记录当前递归路径上的节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">onPath</span><span class="params">(graph.size())</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Graph&amp; graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (src &lt; <span class="number">0</span> || src &gt;= graph.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (onPath[src]) &#123;</span><br><span class="line">        <span class="comment">// 防止死循环（成环）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    onPath[src] = <span class="literal">true</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(src);</span><br><span class="line">    <span class="keyword">if</span> (src == dest) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;find path: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : path) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; e : graph.<span class="built_in">neighbors</span>(src)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, e.to, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    onPath[src] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)同时使用 visited 和 onPath 数组<br>
遍历所有路径的算法复杂度较高，大部分情况下我们可能并不需要穷举完所有路径，而是仅需要找到某一条符合条件的路径。这种场景下，我们可能会借助 visited 数组进行<strong>剪枝</strong>，提前排除一些不符合条件的路径，从而降低复杂度。</p>
<p>(4)完全不用 visited 和 onPath 数组<br>
visited 和 onPath 主要的作用就是处理成环的情况，避免死循环。那如果<strong>题目告诉你输入的图结构不包含环</strong>，那么你就不需要考虑成环的情况了。</p>
<ol start="2">
<li><strong>广度优先搜索（BFS）</strong></li>
</ol>
<ul>
<li>图结构的广度优先搜索其实就是 多叉树的<strong>层序遍历</strong>，无非就是加了一个 <code>visited</code> 数组来<strong>避免重复遍历节点</strong>。</li>
<li>理论上 BFS 遍历也需要区分遍历所有「节点」和遍历所有「路径」，但是实际上 BFS 算法一般只用来寻找那条<strong>最短路径</strong>，不会用来求所有路径。</li>
</ul>
<p>(1)写法一：不记录遍历步数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 访问 cur 节点</span></span><br><span class="line">        std::cout &lt;&lt; cur-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 cur 的所有子节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图结构的 BFS 遍历，从节点 s 开始进行 BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> Graph&amp; graph, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; cur &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; e : graph.<span class="built_in">neighbors</span>(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[e.to]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                visited[e.to] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)写法二：记录遍历步数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> Graph&amp; graph, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 记录从 s 开始走到当前节点的步数</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot; at step &quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; e : graph.<span class="built_in">neighbors</span>(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[e.to]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                    visited[e.to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)写法三：适配不同权重边</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多叉树的层序遍历</span></span><br><span class="line"><span class="comment">// 每个节点自行维护 State 类，记录深度等信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* node;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">State</span>(Node* node, <span class="type">int</span> depth) : <span class="built_in">node</span>(node), <span class="built_in">depth</span>(depth) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrderTraverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;State&gt; q;</span><br><span class="line">    <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        State state = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        Node* cur = state.node;</span><br><span class="line">        <span class="type">int</span> depth = state.depth;</span><br><span class="line">        <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;depth = &quot;</span> &lt;&lt; depth &lt;&lt; <span class="string">&quot;, val = &quot;</span> &lt;&lt; cur-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">State</span>(child, depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图结构的 BFS 遍历，从节点 s 开始进行 BFS，且记录路径的权重和</span></span><br><span class="line"><span class="comment">// 每个节点自行维护 State 类，记录从 s 走来的权重和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 当前节点 ID</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line">    <span class="comment">// 从起点 s 到当前节点的权重和</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> node, <span class="type">int</span> weight) : <span class="built_in">node</span>(node), <span class="built_in">weight</span>(weight) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> Graph&amp; graph, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;State&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">State</span>(s, <span class="number">0</span>));</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        State state = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> cur = state.node;</span><br><span class="line">        <span class="type">int</span> weight = state.weight;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot; with path weight &quot;</span> &lt;&lt; weight &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> Edge&amp; e : graph.<span class="built_in">neighbors</span>(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[e.to]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">State</span>(e.to, weight + e.weight));</span><br><span class="line">                visited[e.to] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-并查集">3. 并查集</h3>
<ul>
<li>并查集 Union Find 是一种二叉树结构的衍生，用于高效解决<strong>无向图的连通性</strong>问题。</li>
<li>查询两个节点是否连通：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>合并两个连通分量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>查询连通分量的个数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<blockquote>
<p>你单纯去查邻接表/邻接矩阵，只能判断两个节点是否<strong>直接</strong>相连，而无法处理这种<strong>传递</strong>的连通关系。</p>
</blockquote>
<ul>
<li>如果我们想办法把<strong>同一个连通分量的节点</strong>都放到<strong>同一棵树</strong>中，把<strong>这棵树的根节点</strong>作为这个连通分量的代表，那么我们就可以高效实现上面的操作了。</li>
<li>并查集底层其实是一片<strong>森林（若干棵多叉树）</strong>，每棵树代表一个<strong>连通分量</strong>：
<ul>
<li><code>connected(p, q)</code>：只需要判断 p 和 q 所在的多叉树的<strong>根节点</strong>，若<strong>相同</strong>，则 p 和 q 在同一棵树中，即连通，否则不连通。</li>
<li><code>count()</code>：只需要统计一下总共有<strong>多少棵树</strong>，即可得到连通分量的数量。</li>
<li><code>union(p, q)</code>：只需要将 p 节点所在的这棵树的根节点，接入到 q 节点所在的这棵树的根节点下面，即可完成连接操作。注意这里并不是 p, q 两个节点的合并，而是<strong>两棵树根节点的合并</strong>。因为 p, q 一旦连通，那么他们所属的连通分量就合并成了同一个更大的连通分量。<br>
综上，并查集中<strong>每个节点其实不在乎自己的子节点是谁</strong>，<strong>只在乎自己的根节点是谁</strong>，所以一个并查集节点类似于下面这样：</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以<strong>并查集算法最终的目标</strong>，就是要<strong>尽可能降低树的高度</strong>，如果能保持树高为常数，那么上述方法的复杂度就都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 了。</p>
</blockquote>
<p>（1）权重数组的优化效果<br>
在仔细观察即可发现，使得树高线性增长的原因是，每次 <code>union</code> 操作都是将节点个数较多的树接到了节点个数较少的树下面，这就很容易让树高增加，很不明智。一种优化思路是引入一个权重数组，记录以每个节点的为根的树的节点个数，然后在 union 方法中，总是将节点个数较少的树接到节点个数较多的树下面，这样可以保证树尽可能平衡，树高也就不会线性增长。</p>
<p>（2）路径压缩的优化效果<br>
路径压缩的效果，一旦触发，无论树枝的高度是多少，都会被直接压缩为 2，路径压缩的<br>
均摊复杂度 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，这样就可以保证 union, connected, find 方法的时间复杂度都是常数级别 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="十-十大排序">(十) 十大排序</h2>
<ul>
<li>排序算法的关键指标
<ol>
<li>时空复杂度</li>
<li>排序稳定性</li>
<li>是否原地排序</li>
</ol>
</li>
</ul>
<h3 id="1-选择排序">1. 选择排序</h3>
<ul>
<li>选择排序是最简单朴素的排序算法，但是时间复杂度较高，且不是稳定排序。其他基础排序算法都是基于选择排序的优化。</li>
<li>每次都去遍历选择最小的元素。</li>
<li>分析：
<ol>
<li>选择排序算法是个不稳定排序算法，因为每次都要交换最小元素和当前元素的位置，这样可能会改变相同元素的相对位置。</li>
<li>选择排序的时间复杂度和初始数据的有序度完全没有关系，即便输入的是一个已经有序的数组，选择排序的时间复杂度依然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>选择排序的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，具体的操作次数大概是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n^2 / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span> 次，常规的优化思路无法降低时间复杂度。</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// sortedIndex 是一个分割线</span></span><br><span class="line">    <span class="comment">// 索引 &lt; sortedIndex 的元素都是已排序的</span></span><br><span class="line">    <span class="comment">// 索引 &gt;= sortedIndex 的元素都是未排序的</span></span><br><span class="line">    <span class="comment">// 初始化为 0，表示整个数组都是未排序的</span></span><br><span class="line">    <span class="type">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sortedIndex &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 找到未排序部分 [sortedIndex, n) 中的最小值</span></span><br><span class="line">        <span class="type">int</span> minIndex = sortedIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sortedIndex + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[minIndex]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换最小值和 sortedIndex 处的元素</span></span><br><span class="line">        <span class="type">int</span> tmp = nums[sortedIndex];</span><br><span class="line">        nums[sortedIndex] = nums[minIndex];</span><br><span class="line">        nums[minIndex] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sortedIndex 后移一位</span></span><br><span class="line">        sortedIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-冒泡排序（解决稳定）">2. 冒泡排序（解决稳定）</h3>
<ul>
<li>冒泡算法是对 选择排序 的一种优化，通过交换 <code>nums[sortedIndex]</code> 右侧的逆序对完成排序，是一种<strong>稳定</strong>排序算法。</li>
<li>优化的方向就在这里，你不要图省事儿直接把本次查找的最小的直接一次交换到前面；而应该一步一步交换，慢慢到最前面。</li>
<li>这个算法的名字叫做冒泡排序，因为它的执行过程就像从数组尾部向头部冒出水泡，每次都会将最小值顶到正确的位置。</li>
<li>如果一次交换操作都没有进行，说明数组已经有序，可以提前终止算法。</li>
<li>唯一的遗憾是，时间复杂度依然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并没有降低。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对选择排序进行第二波优化，获得稳定性的同时避免额外的 for 循环</span></span><br><span class="line"><span class="comment">// 这个算法有另一个名字，叫做冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.length;</span><br><span class="line">    <span class="type">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sortedIndex &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 寻找 nums[sortedIndex..] 中的最小值</span></span><br><span class="line">        <span class="comment">// 同时将这个最小值逐步移动到 nums[sortedIndex] 的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; sortedIndex; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// swap(nums[i], nums[i - 1])</span></span><br><span class="line">                <span class="type">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                nums[i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortedIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-插入排序（逆向提高效率）">3. 插入排序（逆向提高效率）</h3>
<ul>
<li>插入排序是基于 选择排序 的一种优化，将 <code>nums[sortedIndex]</code> 插入到左侧的有序数组中。对于有序度较高的数组，插入排序的效率比较高。</li>
<li>选择排序和冒泡排序是在 <code>nums[sortedIndex..]</code> 中找到最小值，然后将其插入到 <code>nums[sortedIndex]</code> 的位置。</li>
<li>那么我们能不能反过来想，在 <code>nums[0..sortedIndex-1]</code> 这个部分有序的数组中，找到 <code>nums[sortedIndex]</code> 应该插入的位置插入。</li>
<li>这个算法的名字叫做插入排序，它的执行过程就像是打扑克牌时，将新抓到的牌插入到手中已经排好序的牌中。</li>
<li>插入排序的<strong>空间复杂度</strong>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，是<strong>原地</strong>排序算法。<strong>时间复杂度</strong>是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，具体的操作次数和选择排序类似，是一个等差数列求和，大约是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n^2 / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/2</span></span></span></span> 次。</li>
<li>插入排序是一种<strong>稳定</strong>排序，因为只有在 <code>nums[i] &lt; nums[i - 1]</code> 的情况下才会交换元素，所以相同元素的相对位置不会发生改变。</li>
<li>初始有序度越高，效率越高。插入排序的综合性能应该要高于冒泡排序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对选择排序进一步优化，向左侧有序数组中插入元素</span></span><br><span class="line"><span class="comment">// 这个算法有另一个名字，叫做插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 维护 [0, sortedIndex) 是有序数组</span></span><br><span class="line">    <span class="type">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sortedIndex &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 将 nums[sortedIndex] 插入到有序数组 [0, sortedIndex) 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sortedIndex; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// swap(nums[i], nums[i - 1])</span></span><br><span class="line">                <span class="type">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                nums[i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortedIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-希尔排序（突破n-2）">4. 希尔排序（突破n^2）</h3>
<ul>
<li>希尔排序是基于 插入排序 的简单改进，通过预处理增加数组的局部有序性，突破了插入排序的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 时间复杂度。</li>
<li>希尔排序是<strong>不稳定</strong>排序。这个比较容易理解吧，当 <code>h</code> 大于 1 时进行的排序操作，就可能打乱相同元素的相对位置了。</li>
<li>空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，是<strong>原地</strong>排序算法。</li>
<li>希尔排序的时间复杂度是小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的。</li>
</ul>
<blockquote>
<p>h 有序数组：一个数组是 h 有序的，是指这个数组中任意间隔为 <code>h</code>（或者说间隔元素的个数为 <code>h-1</code>）的元素都是有序的。<br>
<strong>当一个数组完成排序的时候，其实就是 1 有序数组。</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums:</span><br><span class="line">[1, 2, 4, 3, 5, 7, 8, 6, 10, 9, 12, 11]</span><br><span class="line"> ^--------^--------^---------^</span><br><span class="line">    ^--------^--------^---------^</span><br><span class="line">       ^--------^--------^----------^</span><br><span class="line"></span><br><span class="line"> 1--------3--------8---------9</span><br><span class="line">    2--------5--------6---------12</span><br><span class="line">        4--------7--------10---------11</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序，对 h 有序数组进行插入排序</span></span><br><span class="line"><span class="comment">// 逐渐缩小 h，最后 h=1 时，完成整个数组的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 我们使用的生成函数是 2^(k-1)</span></span><br><span class="line">    <span class="comment">// 即 h = 1, 2, 4, 8, 16...</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        h = <span class="number">2</span> * h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改动一，把插入排序的主要逻辑套在 h 的 while 循环中</span></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 改动二，sortedIndex 初始化为 h，而不是 1</span></span><br><span class="line">        <span class="type">int</span> sortedIndex = h;</span><br><span class="line">        <span class="keyword">while</span> (sortedIndex &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 改动三，把比较和交换元素的步长设置为 h，而不是相邻元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = sortedIndex; i &gt;= h; i -= h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[i - h]) &#123;</span><br><span class="line">                    <span class="comment">// swap(nums[i], nums[i - h])</span></span><br><span class="line">                    <span class="type">int</span> tmp = nums[i];</span><br><span class="line">                    nums[i] = nums[i - h];</span><br><span class="line">                    nums[i - h] = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照递增函数的规则，缩小 h</span></span><br><span class="line">        h /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>希尔排序的性能和<strong>递增函数的选择</strong>有很大关系，上面的代码中我们使用的递增函数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，因为这是最简单的，但这并不最优的选择。比方说《算法 4》 中给的递增函数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>3</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(3^k−1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>，即 <code>1,4,13,40,121,364...</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把生成函数换成 (3^k - 1) / 2</span></span><br><span class="line"><span class="comment">// 即 h = 1, 4, 13, 40, 121, 364...</span></span><br><span class="line"><span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">    h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 按照递增函数的规则，缩小 h</span></span><br><span class="line">h /= <span class="number">3</span>;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-快速排序（二叉树前序位置）">5. 快速排序（二叉树前序位置）</h3>
<ul>
<li>快速排序的核心思路需要结合 <strong>二叉树的前序遍历</strong> 来理解：在二叉树遍历的前序位置将一个元素排好位置，然后递归地将剩下的元素排好位置。</li>
<li>快速排序的思路是：先把一个元素排好序，然后去把剩下的元素排好序。
<ol>
<li>任意选择一个元素作为切分元素 pivot（一般选择第一个元素）</li>
<li>对数组中的元素进行若干交换操作，将小于 pivot 的元素放到 pivot 的左边，大于 pivot 的元素放到 pivot 的右边（换句话说，<strong>其实就是将 pivot 这一个元素排好序</strong>）</li>
<li><strong>递归的去把 pivot 左右两侧的其他元素排好序</strong>。</li>
</ol>
</li>
<li>本质是二叉树的前序遍历，在前序位置将 <code>nums[p]</code> 排好序，然后递归排序左右元素</li>
<li>其中 <code>partition</code> 函数的实现是快速排序的核心，即遍历 <code>nums[lo..hi]</code>，将切分点元素 <code>pivot</code> 放到正确的位置，并返回该位置的索引 <code>p</code>。</li>
<li>每层元素总和仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，树高是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以总的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>快速排序不需要额外的辅助空间，是原地排序算法。递归遍历二叉树时，递归函数的堆栈深度为树的高度，所以空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>快速排序是<strong>不稳定</strong>排序算法，因为在 <code>partition</code> 函数中，不会考虑相同元素的相对位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分，将 nums[p] 排好序</span></span><br><span class="line">    <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 去左右子数组进行切分</span></span><br><span class="line">    <span class="built_in">sort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-归并排序（二叉树后序位置）">6. 归并排序（二叉树后序位置）</h3>
<ul>
<li>归并排序的核心思路需要结合 <strong>二叉树的后序遍历</strong> 来理解：先利用递归把左右两半子数组排好序，然后在二叉树的后序位置<strong>合并</strong>两个有序数组。</li>
<li>归并排序的稳定性取决于 <code>merge</code> 函数的实现，需要用到 <strong>双指针技巧</strong>，是<strong>稳定</strong>排序。</li>
<li>每层元素总和仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，树高是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以总的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li><strong>不是原地</strong>排序。归并排序的 <code>merge</code> 函数需要一个额外的数组来辅助进行有序数组的合并操作，消耗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[lo..mid]</span></span><br><span class="line">    <span class="built_in">sort</span>(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 利用定义，排序 nums[mid+1..hi]</span></span><br><span class="line">    <span class="built_in">sort</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时两部分子数组已经被排好序</span></span><br><span class="line">    <span class="comment">// 合并两个有序数组，使 nums[lo..hi] 有序</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-堆排序（运用二叉堆）">7. 堆排序（运用二叉堆）</h3>
<ul>
<li>堆排序是从 <strong>二叉堆结构</strong> 衍生出来的排序算法，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>堆排序主要分两步，第一步是在待排序数组上<strong>原地创建二叉堆</strong>（Heapify），然后进行<strong>原地排序</strong>（Sort）。</li>
<li>堆排序是一种<strong>不稳定</strong>的排序算法，因为二叉堆本质上是把数组结构抽象成了二叉树结构，在二叉树逻辑结构上的元素交换操作映射回数组上，无法顾及相同元素的相对位置。</li>
<li>分析：
<ol>
<li>二叉堆（优先级队列）底层是用<strong>数组</strong>实现的，但是<strong>逻辑上是一棵完全二叉树</strong>，主要依靠 上浮<code>swim</code>, 下沉<code>sink</code> 方法来维护堆的性质。</li>
<li>优先级队列可以分为<strong>小顶堆</strong>和<strong>大顶堆</strong>，小顶堆会将整个堆中最小的元素维护在堆顶，大顶堆会将整个堆中最大的元素维护在堆顶。</li>
<li>优先级队列<strong>插入</strong>元素时：首先把元素追加到二叉堆<strong>底部</strong>，然后调用 <code>swim</code> 方法把该元素<strong>上浮</strong>到合适的位置，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>优先级队列<strong>删除</strong>堆顶元素时：首先把堆底的<strong>最后一个元素交换到堆顶</strong>作为新的堆顶元素，然后调用 <code>sink</code> 方法把这个新的堆顶元素<strong>下沉</strong>到合适的位置，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
</li>
<li>那么最简单的堆排序算法思路就是直接利用优先级队列，把所有元素塞到优先级队列里面，然后再取出来，就完成排序了。</li>
<li>优先级队列的 <code>push</code>, <code>pop</code> 方法的复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，所以整个排序的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接利用优先级队列对数组从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个从小到大排序元素的小顶堆</span></span><br><span class="line">    SimpleMinPQ pq = <span class="keyword">new</span> <span class="built_in">SimpleMinPQ</span>(nums.length);</span><br><span class="line">    <span class="comment">// 先把所有元素插入到优先级队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// push 操作会自动构建二叉堆，时间复杂度为 O(logN)</span></span><br><span class="line">        pq.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再把所有元素取出来，就是从小到大排序的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// pop 操作从堆顶弹出二叉堆堆中最小的元素，时间复杂度为 O(logN)</span></span><br><span class="line">        nums[i] = pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>堆排序的两个关键步骤：
<ol>
<li>原地建堆（Heapify）：直接把待排序数组原地变成一个二叉堆。</li>
<li>排序（Sort）：将元素不断地从堆中取出，最终得到有序的结果。</li>
</ol>
</li>
<li>时间复杂度，假设 <code>nums</code> 的元素个数为 <code>N</code>：
<ol>
<li>第一步建堆的过程中，<code>swim</code> 方法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，算法对每个元素调用一次 <code>swim</code> 方法，所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
<li>第二步排序的过程中，每次 <code>sink</code> 方法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，算法对每个元素调用一次 <code>sink</code> 方法，所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。<br>
综上，整个堆排序的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
</li>
<li>空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小顶堆的上浮操作，时间复杂度是树高 O(logN)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapSwim</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node &gt; <span class="number">0</span> &amp;&amp; heap[<span class="built_in">parent</span>(node)] &gt; heap[node]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap, <span class="built_in">parent</span>(node), node);</span><br><span class="line">        node = <span class="built_in">parent</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆的下沉操作，时间复杂度是树高 O(logN)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minHeapSink</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> node, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">left</span>(node) &lt; size || <span class="built_in">right</span>(node) &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 比较自己和左右子节点，看看谁最小</span></span><br><span class="line">        <span class="type">int</span> min = node;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">left</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">left</span>(node)] &lt; heap[min]) &#123;</span><br><span class="line">            min = <span class="built_in">left</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">right</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">right</span>(node)] &lt; heap[min]) &#123;</span><br><span class="line">            min = <span class="built_in">right</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == node) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右子节点中有比自己小的，就交换</span></span><br><span class="line">        <span class="built_in">swap</span>(heap, node, min);</span><br><span class="line">        node = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆的上浮操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeapSwim</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node &gt; <span class="number">0</span> &amp;&amp; heap[<span class="built_in">parent</span>(node)] &lt; heap[node]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap, <span class="built_in">parent</span>(node), node);</span><br><span class="line">        node = <span class="built_in">parent</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆的下沉操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeapSink</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> node, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">left</span>(node) &lt; size || <span class="built_in">right</span>(node) &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 小顶堆和大顶堆的唯一区别就在这里，比较逻辑相反</span></span><br><span class="line">        <span class="comment">// 比较自己和左右子节点，看看谁最大</span></span><br><span class="line">        <span class="type">int</span> max = node;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">left</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">left</span>(node)] &gt; heap[max]) &#123;</span><br><span class="line">            max = <span class="built_in">left</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">right</span>(node) &lt; size &amp;&amp; heap[<span class="built_in">right</span>(node)] &gt; heap[max]) &#123;</span><br><span class="line">            max = <span class="built_in">right</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max == node) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap, node, max);</span><br><span class="line">        node = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左子节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右子节点的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = heap[i];</span><br><span class="line">    heap[i] = heap[j];</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入的数组元素从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步，原地建堆，注意这里创建的是大顶堆</span></span><br><span class="line">    <span class="comment">// 只要从左往右对每个元素调用 swim 方法，就可以原地建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">maxHeapSwim</span>(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，排序</span></span><br><span class="line">    <span class="comment">// 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可</span></span><br><span class="line">    <span class="type">int</span> heapSize = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从堆顶删除元素，放到堆的后面</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">        heapSize--;</span><br><span class="line">        <span class="comment">// 恢复堆的性质</span></span><br><span class="line">        <span class="built_in">maxHeapSink</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        <span class="comment">// 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接实现堆排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输入的数组元素从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步，原地建堆，注意这里创建的是大顶堆</span></span><br><span class="line">    <span class="comment">// 只要从左往右对每个元素调用 swim 方法，就可以原地建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="built_in">maxHeapSwim</span>(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，排序</span></span><br><span class="line">    <span class="comment">// 现在整个数组已经是一个大顶了，直接模拟删除堆顶元素的过程即可</span></span><br><span class="line">    <span class="type">int</span> heapSize = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从堆顶删除元素，放到堆的后面</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);    </span><br><span class="line">        heapSize--;</span><br><span class="line">        <span class="comment">// 恢复堆的性质</span></span><br><span class="line">        <span class="built_in">maxHeapSink</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        <span class="comment">// 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxHeapSink, maxHeapSwim 等函数代码见上文</span></span><br></pre></td></tr></table></figure>
<ul>
<li>再优化：<strong>对于一个二叉堆来说，其左右子堆（子树）也是一个二叉堆</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输入的数组元素从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步，原地建堆，注意这里创建的是大顶堆</span></span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次下沉，合并二叉堆</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =  n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">maxHeapSink</span>(nums, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并完成，现在整个数组已经是一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，排序，和刚才的代码一样</span></span><br><span class="line">    <span class="type">int</span> heapSize = n;</span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从堆顶删除元素，放到堆的后面</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="number">0</span>, heapSize - <span class="number">1</span>);</span><br><span class="line">        heapSize--;</span><br><span class="line">        <span class="comment">// 恢复堆的性质</span></span><br><span class="line">        <span class="built_in">maxHeapSink</span>(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        <span class="comment">// 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-计数排序（新原理）">8. 计数排序（新原理）</h3>
<ul>
<li>计数排序的原理比较简单：统计每种元素出现的次数，进而推算出每个元素在排序后数组中的索引位置，最终完成排序。</li>
<li>在它的算法思想中同时看到前面讲的 <strong>归并排序</strong> 和 <strong>计数排序</strong> 的影子。</li>
<li>计数排序的时间和空间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo><mtext>，其中</mtext><mi>n</mi><mtext>是待排序数组长度，</mtext><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mtext>是待排序数组的元素范围</mtext></mrow><annotation encoding="application/x-tex">O(n+max−min)，其中 n 是待排序数组长度，max−min 是待排序数组的元素范围</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mclose">)</span><span class="mord cjk_fallback">，其中</span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">是待排序数组长度，</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">min</span><span class="mord cjk_fallback">是待排序数组的元素范围</span></span></span></span>。</li>
<li>处理负数和自定义类型：简单映射技巧</li>
<li>非比较排序：计数排序都不需要比较元素的大小，代码中不包含 <code>if (nums[i] &gt; nums[j])</code> 这样的比较逻辑,那么到底是什么让他能够完成排序呢？答案是，它依靠数组<strong>索引的有序性</strong>，所以不用对元素进行比较。（也因此，不能使用哈希表作为 <code>count</code>计数数组。</li>
<li>计数排序以及后面介绍到的其他非比较排序算法，在特定场景下的时间复杂度是<strong>线性</strong>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，性能会显著高于通用排序算法。</li>
</ul>
<h3 id="9-桶排序（博采众长）">9. 桶排序（博采众长）</h3>
<ul>
<li>桶排序算法的核心思想分三步：
<ol>
<li>将待排序数组中的元素使用<strong>映射函数</strong>分配到若干个「<strong>桶</strong>」中。</li>
<li>对<strong>每个桶</strong>中的元素进行<strong>排序</strong>。</li>
<li>最后将这些排好序的<strong>桶进行合并</strong>，得到排序结果。</li>
</ol>
</li>
<li>求模的方法不可行，我们需要用<strong>除法向下取整</strong>的方式来将元素<strong>分配到桶</strong>中。</li>
<li>对于桶合并可以有多种排序方法：使用插入排序的桶排序、使用递归的桶排序。</li>
<li>桶排序的稳定性主要取决于对<strong>每个桶的排序</strong>算法。</li>
<li>空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，均摊时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，最坏时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<h3 id="10-基数排序-Radix-Sort">10. 基数排序(Radix Sort)</h3>
<ul>
<li>基数排序是 <strong>计数排序</strong> 算法的扩展，它的主要思路是对待排序元素的每一位依次进行计数排序。由于计数排序是稳定的，所以对每一位完成计数排序后，所有元素就完成了排序。</li>
<li>基数排序的原理很简单，比方说输入的数组都是三位数 <code>nums = [329, 457, 839, 439, 720, 355, 350]</code>，我们先按照<strong>个位</strong>数排序，然后按照<strong>十位</strong>数排序，然后按照<strong>百位</strong>数排序，最终就完成了整个数组的排序。这里面的关键在于，对每一位的排序都必须是稳定排序，否则最终结果就不对了。</li>
<li>使用什么稳定排序比较好？计数排序，复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></li>
<li>位数不同怎么办？前缀补 0</li>
<li>有负数？正数分数分开排序</li>
<li>采用 LSD 算法（Least Significant Digit first，最低位优先）。对应的是 MSD（Most Significant Digit first，最高位优先）</li>
<li>对于 LSD 基数排序，由于对每一位的排序都是稳定的，所以最终的排序结果也是<strong>稳定</strong>的。</li>
<li>假设待排序数组长度为 n，最大元素的位数为 m，LSD 计数排序本质上就是执行了 m 次计数排序。前文分析过，计数排序的时空复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+max−min)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mclose">)</span></span></span></span>，在十进制整数的基数排序的场景中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">max−min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span> 的值是常数 <code>10</code>，可以忽略，所以每次计数排序的时空复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。因此，LSD 基数排序的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSortLSD</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        min = std::<span class="built_in">min</span>(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最小元素，将所有元素转化为从零开始的非负数</span></span><br><span class="line">    <span class="type">int</span> offset = -min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[i] += offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最大元素的位数</span></span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        maxLen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从低位到高位，依次对每一位进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; maxLen; k++) &#123;</span><br><span class="line">        <span class="built_in">countSort</span>(nums, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有元素转化回原来的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[i] -= offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序使用的计数排序算法函数</span></span><br><span class="line"><span class="comment">// 已经确保 nums 中的元素都是非负数</span></span><br><span class="line"><span class="comment">// k 是当前需要排序的位数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基数排序中每一位十进制数的取值范围是 0~9</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个元素的第 k 位进行计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (num / <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">pow</span>(<span class="number">10</span>, k))) % <span class="number">10</span>;</span><br><span class="line">        count[digit]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照第 k 位的值对元素进行排序</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">sorted</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (nums[i] / <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">pow</span>(<span class="number">10</span>, k))) % <span class="number">10</span>;</span><br><span class="line">        sorted[count[digit] - <span class="number">1</span>] = nums[i];</span><br><span class="line">        count[digit]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把排序结果复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        nums[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>第零章、核心刷题框架汇总</h1>
<h2 id="零-万剑归宗">(零) 万剑归宗</h2>
<div class="note danger no-icon flat"><p>几句话总结一切数据结构和算法：</p>
<ol>
<li>种种数据结构，皆为<strong>数组</strong>（顺序存储）和<strong>链表</strong>（链式存储）的变换。</li>
<li>数据结构的关键点在于<strong>遍历和访问</strong>，即增删查改等基本操作。</li>
<li>种种算法，皆为<strong>穷举</strong>。</li>
<li>穷举的关键点在于<strong>无遗漏和无冗余</strong>。熟练掌握算法框架，可以做到无遗漏；充分利用信息，可以做到无冗余。</li>
</ol>
<p><a class="btn-beautify larger outline" target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/algorithm-summary/#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93" 
  title="鞭辟入里：原文链接"><i class="fa fa-share"></i><span>鞭辟入里：原文链接</span></a></p>
</div>
<h3 id="1-数据结构的存储">1. 数据结构的存储</h3>
<ul>
<li><strong>队列、栈</strong> 这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。</li>
<li><strong>图结构</strong> 的两种存储方式，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</li>
<li><strong>哈希表</strong> 就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法 需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法 需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</li>
<li><strong>树结构</strong>，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单，经典应用有 二叉堆；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如 二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</li>
</ul>
<p>综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：</p>
<p><strong>数组</strong> 由于是紧凑连续存储，可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p><strong>链表</strong> 因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p>
<h3 id="2-数据结构的操作">2. 数据结构的操作</h3>
<ul>
<li><strong>线性</strong>就是 <code>for/while</code> 迭代为代表，<strong>非线性</strong>就是<code>递归</code>为代表。</li>
</ul>
<ol>
<li><strong>数组</strong>遍历框架，典型的线性迭代结构：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>链表</strong>遍历框架，兼具迭代和递归结构：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的单链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode* p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 迭代访问 p-&gt;val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归访问 head-&gt;val</span></span><br><span class="line">    <span class="built_in">traverse</span>(head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>二叉树</strong>遍历框架，典型的非线性递归遍历结构：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的二叉树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树框架可以扩展为 N 叉树的遍历框架:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的 N 叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;TreeNode*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode* child : root-&gt;children)</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>图</strong>：N 叉树的遍历又可以扩展为图的遍历，因为<strong>图就是好几 N 叉棵树的结合体</strong>。<br>
图是可能出现环的？这个很好办，用个布尔数组 <code>visited</code> 做标记就行了。</li>
</ol>
<h3 id="3-算法的本质">3. 算法的本质</h3>
<ul>
<li>算法的本质就是「<strong>穷举</strong>」。</li>
</ul>
<h3 id="4-穷举的难点">4. 穷举的难点</h3>
<ul>
<li>穷举有两个关键难点：<strong>无遗漏</strong>、<strong>无冗余</strong>。</li>
<li>当你看到一道算法题，可以从这两个维度去思考：
<ol>
<li>如何穷举？即无遗漏地穷举所有可能解。</li>
<li>如何聪明地穷举？即避免所有冗余的计算，消耗尽可能少的资源求出答案。</li>
</ol>
</li>
<li>后续会有的系列：
<ol>
<li>数组/单链表系列算法：单指针、双指针、二分搜索、滑动窗口、前缀和、差分数组。</li>
<li>二叉树系列算法：动态规划、回溯（DFS）、层序（BFS）、分治。附加技巧剪枝、备忘录。</li>
<li>图系列算法：二叉树算法的延续。</li>
</ol>
</li>
</ul>
<h2 id="一-双指针（链表）">(一) 双指针（链表）</h2>
<blockquote>
<p>技巧目录：<br>
1、合并两个有序链表<br>
2、链表的分解<br>
3、合并 k 个有序链表<br>
4、寻找单链表的倒数第 k 个节点<br>
5、寻找单链表的中点<br>
6、判断单链表是否包含环并找出环起点<br>
7、判断两个单链表是否相交并找出交点</p>
</blockquote>
<h3 id="1、合并两个有序链表">1、合并两个有序链表</h3>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-1-merge_ex1.jpg" alt="0-1-合并"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy;</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">            <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>)  p-&gt;next = p1;</span><br><span class="line">        <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>)  p-&gt;next = p2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么时候需要用虚拟头结点？当你需要<strong>创造一条新链表</strong>的时候，可以使用<strong>虚拟头结点</strong>简化边界情况的处理。</p>
</blockquote>
<h3 id="2、单链表的分解">2、单链表的分解</h3>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/description/">分割链表</a><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-2-partition.jpg" alt="0-2-分解"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放小于 x 的链表的虚拟头结点</span></span><br><span class="line">        ListNode* dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 存放大于等于 x 的链表的虚拟头结点</span></span><br><span class="line">        ListNode* dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// p1, p2 指针负责生成结果链表</span></span><br><span class="line">        ListNode* p1 = dummy1, *p2 = dummy2;</span><br><span class="line">        <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">        <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &gt;= x) &#123;</span><br><span class="line">                p2-&gt;next = p;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p1-&gt;next = p;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不能直接让 p 指针前进，</span></span><br><span class="line">            <span class="comment">// p = p-&gt;next</span></span><br><span class="line">            <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">            ListNode* temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接两个链表</span></span><br><span class="line">        p1-&gt;next = dummy2-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、合并-k-个有序链表">3、合并 k 个有序链表</h3>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并k个有序链表</a></p>
<ul>
<li>
<p>合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？<br>
这里我们就要用到<strong>优先级队列</strong>这种数据结构，把链表节点放入一个<strong>最小堆</strong>，就可以<strong>每次获得 k 个节点中的最小节点</strong>。</p>
</li>
<li>
<p>优先队列 pq 中的元素个数最多是 k，所以一次 <code>push</code> 或者 <code>pop</code> 方法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>其中</mtext><mi>k</mi><mtext>是链表的条数，</mtext><mi>N</mi><mtext>是这些链表的节点总数</mtext></mrow><annotation encoding="application/x-tex">O(N\log k)其中 k 是链表的条数，N 是这些链表的节点总数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord cjk_fallback">其中</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">是链表的条数，</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">是这些链表的节点总数</span></span></span></span>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键优化：使用优先队列快速找到 k 个头节点的最小值</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 准备虚拟头节点</span></span><br><span class="line">        ListNode* dumy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* p = dumy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小根堆</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b)&#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; heap;</span><br><span class="line">        <span class="comment">// 初始存入 k 个的头节点</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode* t: lists)  <span class="keyword">if</span>(t != <span class="literal">NULL</span>)  heap.<span class="built_in">push</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始连接</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 最小的先连接</span></span><br><span class="line">            ListNode* minp = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            p-&gt;next = minp;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待选节点存入一个新的</span></span><br><span class="line">            <span class="keyword">if</span>(minp-&gt;next != <span class="literal">NULL</span>)  heap.<span class="built_in">push</span>(minp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> dumy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、单链表的倒数第-k-个节点">4、单链表的倒数第 k 个节点</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">类似题</a></li>
</ul>
<p>那你可能说，假设链表有 <code>n</code> 个节点，倒数第 <code>k</code> 个节点就是正数第 <code>n - k + 1</code> 个节点，不也是一个 <code>for</code> 循环的事儿吗？</p>
<p>这个解法需要遍历两次链表才能得到出倒数第 <code>k</code> 个节点。</p>
<p>能不能<strong>只遍历一次</strong>链表，就算出倒数第 k 个节点？</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-4-pic.jpeg" alt="倒数第k个"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 找到倒数第k个节点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// p1先走 k 步</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)  p1 = p1-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1，p2共同走 n-k 步</span></span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除倒数第k个，要找到倒数第k+1个</span></span><br><span class="line">        ListNode* p = <span class="built_in">findFromEnd</span>(dummy, n+<span class="number">1</span>);</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>无论遍历一次链表和遍历两次链表的时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，但上述这个算法更有<strong>技巧性</strong>。</p>
<blockquote>
<p>我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。</p>
</blockquote>
<h3 id="5、单链表的中点">5、单链表的中点</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">中点</a></p>
<p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 慢指针指向中点</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6、判断链表是否包含环">6、判断链表是否包含环</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">判断环</a></p>
<ul>
<li>判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：<br>
每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。
<ul>
<li>如果 <code>fast</code> 最终能正常走到链表末尾，说明链表中没有环；</li>
<li>如果 <code>fast</code> 走着走着竟然和 <code>slow</code> 相遇了，那肯定是 <code>fast</code> 在链表中转圈了，说明链表中含有环。</li>
</ul>
</li>
<li>如果链表中含有环，如何计算这个环的起点？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-6-%E7%9B%B8%E9%81%87.jpeg" alt="第一次相遇"></p>
<ul>
<li><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是<strong>环长度</strong>的「整数倍」。</li>
<li>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</li>
<li>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走 <code>k</code> 步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-6-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%9B%B8%E9%81%87.jpeg" alt="第二次相遇"></p>
<ul>
<li>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针，两次相遇即可</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="comment">// 第一次相遇：快慢</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)  <span class="keyword">break</span>;    <span class="comment">// 相遇</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无环</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二次相遇：一起走</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入环点</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7、两个链表是否相交">7、两个链表是否相交</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-7-%E9%93%BE%E8%A1%A8%E5%9B%BE.png" alt="例图"></p>
<ul>
<li>这个题直接的想法可能是用 <code>HashSet</code> 记录<strong>一个链表的所有节点</strong>，然后和<strong>另一条链表对比</strong>，但这就需要额外的空间。</li>
<li>如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-7-%E5%AD%98%E5%82%A8%E9%93%BE%E8%A1%A8.jpeg" alt="链表"></p>
<ul>
<li>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 <code>c1</code>。解决这个问题的关键是，<strong>通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code></strong>。所以，我们可以让 <code>p1</code> 遍历完链表 A 之后开始遍历链表 B，让 <code>p2</code> 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/0-7-%E6%8B%BC%E6%8E%A5.jpeg" alt="拼接"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拼接思想</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = headA, *p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 != <span class="literal">NULL</span>)  p1 = p1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>  p1 = headB;</span><br><span class="line">            <span class="keyword">if</span>(p2 != <span class="literal">NULL</span>)  p2 = p2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p2 = headA; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二-双指针（数组）">(二) 双指针（数组）</h2>
<blockquote>
<p>一、<strong>快慢指针技巧</strong></p>
<ol>
<li>原地修改</li>
<li>滑动窗口</li>
</ol>
<p>二、<strong>左右指针的常用算法</strong><br>
3. 二分查找<br>
4. n 数之和<br>
5. 反转数组<br>
6. 回文串判断</p>
</blockquote>
<h3 id="1、原地修改">1、原地修改</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">删除有序数组中的重复项</a></p>
<ul>
<li>数组问题中比较常见的快慢指针技巧，是让你原地修改数组。</li>
<li>由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及<strong>数据搬移</strong>，整个时间复杂度是会达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code> 前进一步。这样，就保证了 <code>nums[0..slow]</code> 都是无重复的元素，当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<code>nums[0..slow]</code> 就是整个数组去重之后的结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// fast 探路，有不重复的数字，交给 slow 填</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow])</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终 0..slow 就是答案</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再简单扩展一下，看看力扣第 83 题「删除排序链表中的重复元素」，如果给你一个有序的单链表，如何去重呢？其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// fast 探路，slow 填写</span></span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;val != slow-&gt;val)&#123;</span><br><span class="line">                slow-&gt;next = fast;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意切断</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了让你在有序数组/链表中去重，题目还可能让你对数组中的某些元素进行「<strong>原地删除</strong>」。</li>
<li>参考:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></li>
<li>题目要求我们把 <code>nums</code> 中所有值为 <code>val</code> 的元素原地删除，依然需要使用快慢指针技巧：<br>
如果 <code>fast</code> 遇到值为 <code>val</code> 的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow</code> 前进一步。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>给你输入一个数组 <code>nums</code>，请你原地修改，将数组中的所有值为 <code>0</code> 的元素移到数组末尾。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">移动零</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">            nums[slow++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里，原地修改数组的这些题目就已经差不多了。</p>
<h3 id="2、滑动窗口">2、滑动窗口</h3>
<ul>
<li>数组中另一大类快慢指针的题目就是「滑动窗口算法」。在下文 【（三）滑动窗口】给出了滑动窗口的代码框架：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口伪代码</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">        window.<span class="built_in">pop_front</span>(); <span class="comment">// nums[left]</span></span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体的题目本文就不重复了，这里只强调滑动窗口算法的快慢指针特性：<br>
<code>left</code> 指针在后，<code>right</code> 指针在前，两个指针中间的部分就是「<strong>窗口</strong>」，算法通过扩大和缩小「<strong>窗口</strong>」来解决某些问题。</li>
</ul>
<h3 id="3、二分查找">3、二分查找</h3>
<ul>
<li>在另一篇文章 【二分查找框架详解】 中有详细探讨二分搜索代码的细节问题，这里只写最简单的二分算法，旨在突出它的双指针特性：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、n-数之和">4、n 数之和</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和 II</a></li>
<li>给你一个下标从 <code>1</code> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong>  ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</li>
<li>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 就可以调整 sum 的大小：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="comment">// 完成</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)  <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;; <span class="comment">// 题目索引从1开始</span></span><br><span class="line">            <span class="comment">// 让 sum 小一点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)  right--;</span><br><span class="line">            <span class="comment">// 让 sum 大一点</span></span><br><span class="line">            <span class="keyword">else</span>  left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在另一篇文章 【一个函数秒杀所有nSum问题】 中也运用类似的左右指针技巧给出了 nSum 问题的一种通用思路，本质上利用的也是双指针技巧。</li>
</ul>
<h3 id="5、反转数组">5、反转数组</h3>
<ul>
<li>一般编程语言都会提供 <code>reverse</code> 函数，其实这个函数的原理非常简单，力扣第 344 题「反转字符串」就是类似的需求，让你反转一个 char[] 类型的字符数组，我们直接看代码吧：</li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">反转字符串</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> t = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = t;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于数组翻转的更多进阶问题，可以参见 【二维数组的花式遍历】。</li>
</ul>
<h3 id="6、回文串判断">6、回文串判断</h3>
<ul>
<li>判断很简单</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left  = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right])  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left++, right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提升一点难度，给你一个字符串，让你用双指针技巧从中找出<strong>最长的回文串</strong>?</li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 找到以 l, r 为中心的最长子回文串(若l=r，则说明以一个字符为中心)</span></span><br><span class="line">    <span class="function">string <span class="title">palindrome</span><span class="params">(string&amp; s, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 注意越界</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;s.<span class="built_in">size</span>() &amp;&amp; s[l]==s[r])</span><br><span class="line">            l--, r++;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(l+<span class="number">1</span>, r-l<span class="number">-1</span>);    <span class="comment">// 注意，退出循环时，l,r 都扩大了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 中心扩散</span></span><br><span class="line">            string s1 = <span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line">            string s2 = <span class="built_in">palindrome</span>(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            ans = s1.<span class="built_in">size</span>() &gt; ans.<span class="built_in">size</span>() ? s1 : ans;</span><br><span class="line">            ans = s2.<span class="built_in">size</span>() &gt; ans.<span class="built_in">size</span>() ? s2 : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你应该能发现最长回文子串使用的左右指针和之前题目的左右指针有一些不同：之前的左右指针都是从两端向中间相向而行，而回文子串问题则是让左右指针从中心向两端扩展。不过这种情况也就回文串这类问题会遇到，所以我也把它归为左右指针了。</p>
</blockquote>
<h2 id="三-滑动窗口">(三) 滑动窗口</h2>
<ul>
<li>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。</li>
<li><strong>滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组</strong>。</li>
</ul>
<h3 id="1、框架概述">1、框架概述</h3>
<ul>
<li>如果用暴力解的话，你需要嵌套 <code>for</code> 循环这样穷举所有子数组，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="comment">// nums[i, j] 是一个子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>滑动窗口算法技巧的思路也不难，就是维护一个窗口，不断滑动，然后更新答案，该算法的大致逻辑如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口伪代码</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">        window.<span class="built_in">pop_front</span>(); <span class="comment">// nums[left]</span></span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于滑动窗口算法框架写出的代码，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，比嵌套 <code>for</code> 循环的暴力解法效率高。</p>
<blockquote>
<ol>
<li>为啥是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>？</li>
</ol>
<ul>
<li>简单说，指针 <code>left</code>, <code>right</code> 不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次。</li>
<li>反观嵌套 <code>for</code> 循环的暴力解法，那个 <code>j</code> 会回退，所以某些元素会进入和离开窗口多次，所以时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 了。</li>
</ul>
<ol start="2">
<li>为啥滑动窗口能在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间穷举子数组？</li>
</ol>
<ul>
<li>这个问题本身就是错误的，<strong>滑动窗口并不能穷举出所有子串</strong>。要想穷举出所有子串，必须用那个嵌套 <code>for</code> 循环。</li>
<li>然而对于某些题目，<strong>并不需要穷举所有子串</strong>，就能找到题目想要的答案。滑动窗口就是这种场景下的一套算法模板，帮你对穷举过程进行剪枝优化，避免冗余计算。</li>
</ul>
</blockquote>
<p>因为本文的例题大多是子串相关的题目，字符串实际上就是数组，所以我就把输入设置成字符串了。你做题的时候根据具体题目自行变通即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    <span class="keyword">auto</span> window = ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c);</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架中两处 <code>...</code> 表示的更新窗口数据的地方，在具体的题目中，你需要做的就是往这里面填代码逻辑。</p>
<h3 id="2、最小覆盖子串">2、最小覆盖子串</h3>
<ul>
<li>参考:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/description/">最小覆盖子串</a></li>
<li>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</li>
<li>注：对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
<li>示例：<br>
输入：<code>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</code><br>
输出：<code>&quot;BANC&quot;</code></li>
</ul>
<p>滑动窗口算法的思路是这样：</p>
<ol>
<li>我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间 <code>[left, right)</code> 称为一个「窗口」。</li>
</ol>
<blockquote>
<p>为什么要「<strong>左闭右开</strong>」区间？</p>
<ul>
<li>理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。</li>
<li>因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。</li>
<li>另外，注意：<strong>当前窗口长度，就是 <code>right-left</code>，不需要<code>right-left+1</code>的</strong>。</li>
</ul>
</blockquote>
<ol start="2">
<li>
<p>我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
</li>
<li>
<p>此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
</li>
<li>
<p>重复第 <code>2</code> 和第 <code>3</code> 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
</li>
</ol>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，就好像一条毛毛虫，一伸一缩，不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1-1.png" alt="初始"></p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1-2.png" alt="找到可行解"></p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1-3.png" alt="优化可行解"></p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-1-4.png" alt="不再符合要求"></p>
<ul>
<li>现在开始套模板，只需要思考以下几个问题：
<ol>
<li>什么时候应该移动 right 扩大窗口？窗口加入字符时，应该更新哪些数据？</li>
<li>什么时候窗口应该暂停扩大，开始移动 left 缩小窗口？从窗口移出字符时，应该更新哪些数据？</li>
<li>我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 创建两个哈希表，用于检测是否达到要求</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; c: t)  need[c]++;     <span class="comment">// debug 半天，发现这里 t 写成 s 了。。。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窗口定义左闭右开 [left, right)</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;          <span class="comment">// 已经完成要求的不同字符数量</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, len = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 增大窗口</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 更新数据</span></span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])  valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 是否已达到要求</span></span><br><span class="line">            <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="comment">// 先更新答案</span></span><br><span class="line">                <span class="keyword">if</span>(right-left &lt; len)&#123;   <span class="comment">// 长度不用 r-l+1，因为r本身就是更大 1</span></span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right-left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 更新数据</span></span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])  valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> len&gt;n ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里再强调一下，里面的<code>if(window[d] == need[d])</code>用的很妙的，保证了不会多加少加、多减少减。</p>
</blockquote>
<h3 id="3、字符串排列">3、字符串排列</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/description/">字符串的排列</a></li>
<li>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的 <strong>排列</strong>(排列是字符串中所有字符的重新排序。)。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串 。</li>
<li>示例1：<br>
输入：<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code><br>
输出：<code>true</code><br>
解释：<code>s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></li>
<li>示例2：<br>
输入：<code>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</code><br>
输出：<code>false</code></li>
</ul>
<blockquote>
<p>相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 需要的数据</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; c: s1)  need[c]++;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n2)&#123;</span><br><span class="line">            <span class="comment">// 扩大</span></span><br><span class="line">            <span class="type">char</span> c = s2[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])  valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意收缩条件不一样</span></span><br><span class="line">            <span class="keyword">if</span>(right-left == n1)&#123;</span><br><span class="line">                <span class="comment">// 完成</span></span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 缩小</span></span><br><span class="line">                <span class="type">char</span> d = s2[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])  valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终出来肯定是失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实，你会发现，若是匹配的小窗是固定长度的，那么里面收缩的条件就是 <code>if</code> 而不是 <code>while</code>，当然你使用 <code>while (right - left &gt;= t.size()) </code> 也是能做的，只不过实际上就只执行一次。</p>
</blockquote>
<h3 id="4、找所有字母异位词">4、找所有字母异位词</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">找到字符串中所有字母异位词</a></li>
<li>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong>(字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次) 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</li>
<li>示例:<br>
输入: <code>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</code><br>
输出: <code>[0,6]</code><br>
解释:起始索引等于 <code>0</code> 的子串是 <code>&quot;cba&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。起始索引等于 <code>6</code> 的子串是 <code>&quot;bac&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 所需数据</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> &amp;t: p)  need[t]++;</span><br><span class="line">        <span class="type">int</span> valid = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 增大</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span>(window[c] == need[c])  valid++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缩小</span></span><br><span class="line">            <span class="keyword">if</span>(right-left == m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())  ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window[d] == need[d])  valid--;</span><br><span class="line">                    window[d]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5、最长无重复子串">5、最长无重复子串</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></li>
<li>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> 子串(连续的非空字符序列) 的长度。</li>
<li>示例：<br>
输入: <code>s = &quot;abcabcbb&quot;</code><br>
输出: <code>3</code><br>
解释: 因为无重复字符的最长子串是 <code>&quot;abc&quot;</code>，所以其长度为 <code>3</code>。</li>
</ul>
<p>下面是我的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 所需数据</span></span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window;    <span class="comment">// 只需要哈希集合即可</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 增大</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在，缩小</span></span><br><span class="line">            <span class="keyword">while</span>(window.<span class="built_in">find</span>(c) != window.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                window.<span class="built_in">erase</span>(d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在不存在了，可插入</span></span><br><span class="line">            <span class="keyword">if</span>(window.<span class="built_in">find</span>(c) == window.<span class="built_in">end</span>())&#123;</span><br><span class="line">                window.<span class="built_in">insert</span>(c);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, right-left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如若套用前面模版，也可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 所需数据</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 增大</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            right++;</span><br><span class="line">            window[c]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缩小</span></span><br><span class="line">            <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">char</span> d = s[left];</span><br><span class="line">                left++;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right-left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你只要能回答出来以下几个问题，就能运用滑动窗口算法：</p>
<ol>
<li>什么时候应该扩大窗口？</li>
<li>什么时候应该缩小窗口？</li>
<li>什么时候应该更新答案？</li>
</ol>
<blockquote>
<p>更多强化经典题：<a target="_blank" rel="noopener" href="https://labuladong.online/algo/problem-set/sliding-window/">滑动窗口-强化</a></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">将 x 减到 0 的最小操作数</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">乘积小于 K 的子数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">最大连续1的个数 III</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-repeating-character-replacement/description/">替换后的最长重复字符</a></li>
</ol>
<p>建议在第二天来完成。</p>
</blockquote>
<h2 id="四-二分搜索">(四) 二分搜索</h2>
<h3 id="1、代码框架">1、代码框架</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析二分查找的一个技巧是：不要出现 <code>else</code>，而是把所有情况用 <code>else if</code> 写清楚，这样可以清楚地展现所有细节。</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。</p>
<p>另外提前说明一下，计算 <code>mid</code> 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</p>
</blockquote>
<h3 id="2、寻找一个数（基本）">2、寻找一个数（基本）</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">二分查找</a></li>
<li>即搜索一个数，如果存在，返回其索引，否则返回 <code>-1</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 标准的二分搜索框架，返回目标元素的索引，不存在则返回 -1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;    <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;                   <span class="comment">// 注意</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid+<span class="number">1</span>;                   <span class="comment">// 注意</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid<span class="number">-1</span>;                  <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析：<br>
我们这个算法中使用的是 <code>[left, right]</code> 两端都闭的区间，<strong>这个区间其实就是每次进行搜索的区间</strong>。那么：</p>
<ol>
<li><code>while</code> 循环的条件是 <code>&lt;=</code> 而不是 <code>&lt;</code>。因为 <code>[4,4]</code>是有元素的，而<code>[5,4]</code>才没有元素了，就停止。</li>
<li>初始化 <code>right</code> 是 <code>n-1</code>，而不是 <code>n</code>。因为初始是 <code>[0,n-1]</code>才是可以搜索的空间，而<code>[0,n]</code>的最后<code>n</code>是不可搜索的。</li>
</ol>
<p>若是采用 <code>[left,right)</code> 那么你可以分析得到循环结束，应该是 类似<code>[4,4)</code> 也就是 <code>while</code> 用 <code>left &lt; right</code>就结束了。同时初始化应该是 <code>[0,n)</code> 刚好把所有元素包含且不含最后的<code>n</code>。</p>
<p>为什么是 <code>left = mid + 1，right = mid - 1</code>？</p>
<ul>
<li>明确了「<strong>搜索区间</strong>」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？当然是去搜索区间 <code>[left, mid-1]</code> 或者区间 <code>[mid+1, right]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</li>
</ul>
<p>此算法有什么缺陷？</p>
<ul>
<li>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 <code>2</code>，此算法返回的索引是 <code>2</code>，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 <code>1</code>，或者我想得到 <code>target</code> 的右侧边界，即索引 <code>3</code>，这样的话此算法是无法处理的。</li>
<li>这样的需求很常见，你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</li>
</ul>
</blockquote>
<h3 id="3、寻找左边界">3、寻找左边界</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();  <span class="comment">// 注意 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;                <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid  = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;               <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid;                <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果 <code>target</code> 不存在，搜索左侧边界的二分搜索返回的索引是大于 <code>target</code> 的最小索引。</strong></p>
<ul>
<li>举个例子，<code>nums = [2,3,5,7]</code>, <code>target = 4</code>，<code>left_bound</code> 函数返回值是 <code>2</code>，因为元素 <code>5</code> 是大于 <code>4</code> 的最小元素。</li>
</ul>
<p>为什么是 <code>left = mid + 1</code> 和 <code>right = mid</code>？</p>
<ul>
<li>「<strong>搜索区间</strong>」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步应该去 <code>mid</code> 的左侧或者右侧区间搜索，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</li>
</ul>
<p>为什么该算法能够搜索左侧边界？</p>
<ul>
<li>关键在于对于 <code>nums[mid] == target</code> 这种情况的处理是 <code>right = mid;</code>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</li>
</ul>
<p>为什么返回 <code>left</code> 而不是 <code>right</code>？</p>
<ul>
<li>一样，都可以。终止条件是 <code>left == right</code>。</li>
</ul>
</blockquote>
<p>可以直接拿来写 <code>floor</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个有序数组中，找到「小于 target 的最大元素的索引」</span></span><br><span class="line"><span class="comment">// 比如说输入 nums = [1,2,2,2,3]，target = 2，函数返回 0，因为 1 是小于 2 的最大元素。</span></span><br><span class="line"><span class="comment">// 再比如输入 nums = [1,2,3,5,6]，target = 4，函数返回 2，因为 3 是小于 4 的最大元素。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">floor</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 target 不存在，比如输入 [4,6,8,10], target = 7</span></span><br><span class="line">    <span class="comment">// left_bound 返回 2，减一就是 1，元素 6 就是小于 7 的最大元素</span></span><br><span class="line">    <span class="comment">// 当 target 存在，比如输入 [4,6,8,8,8,10], target = 8</span></span><br><span class="line">    <span class="comment">// left_bound 返回 2，减一就是 1，元素 6 就是小于 8 的最大元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">left_bound</span>(nums, target) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果非必要，不要自己手写，<strong>尽可能用编程语言提供的标准库函数</strong>，可以节约时间，而且标准库函数的行为在文档里都有明确的说明，不容易出错。</p>
</blockquote>
<p>如果想让 <code>target</code> 不存在时返回 <code>-1</code> 其实很简单，在返回的时候额外判断一下 <code>nums[left]</code> 是否等于 <code>target</code> 就行了，如果不等于，就说明 <code>target</code> 不存在。需要注意的是，访问数组索引之前要保证索引不越界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果索引越界，说明数组中无目标元素，返回 -1</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：其实上面的 <code>if</code> 中 <code>left &lt; 0</code> 这个判断可以省略，因为对于这个算法，<code>left</code> 不可能小于 <code>0</code>，你看这个算法执行的逻辑，<code>left</code> 初始化就是 <code>0</code>，且只可能一直往右走，那么只可能在右侧越界。不过我这里就同时判断了，因为在访问数组索引之前保证索引在左右两端都不越界是一个好习惯，没有坏处。另一个好处是让二分的模板更统一，降低你的记忆成本，因为等会儿寻找右边界的时候也有类似的出界判断。</p>
</blockquote>
<p>只要明白了<strong>搜索区间</strong>的概念，实际上，可以统一一下，仍然使用左右都闭的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;    <span class="comment">// 注意，采用区间[left, right]</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;                   <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            right = mid<span class="number">-1</span>;  <span class="comment">// 收紧右边界，不用怕找到小的了，因为后面返回的是left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;   <span class="comment">// 区间改为 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid<span class="number">-1</span>;  <span class="comment">// 区间改为 [left, mid-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 1 种返回</span></span><br><span class="line">    <span class="comment">// return left;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 种返回</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&gt;=nums.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、寻找右边界">4、寻找右边界</h3>
<p>先还是看左闭右开的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();  <span class="comment">// [left, right)</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;                <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            left = mid+<span class="number">1</span>;   <span class="comment">// 收紧，去查 [mid+1, right)</span></span><br><span class="line">        <span class="keyword">else</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;   <span class="comment">// 进入 [mid+1, right)</span></span><br><span class="line">        <span class="keyword">else</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid;    <span class="comment">// 进入 [left, mid)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">return</span> left<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么返回 <code>left - 1</code>？为什么不是返回 <code>right</code>？</p>
<ul>
<li>终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</li>
<li>为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：<code>left = mid + 1;</code>。</li>
<li>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</li>
<li>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，当然是为了把 <code>nums[mid]</code> 排除出搜索区间，这里就不再赘述。</li>
</ul>
<p><strong>如果 <code>target</code> 不存在，搜索右侧边界的二分搜索返回的索引是小于<code>target</code> 的最大索引。</strong></p>
<ul>
<li>比如 <code>nums = [2,3,5,7]</code>, <code>target = 4</code>，<code>right_bound</code> 函数返回值是 <code>1</code>，因为元素 <code>3</code> 是小于 <code>4</code> 的最大元素。</li>
</ul>
</blockquote>
<p>统一一下，现在可以改成左右都闭的写法了：<br>
而且由于此时终止条件变成了 <code>left+1 == right</code> 了，那么刚好<code>right = left-1</code>，可以直接换成 <code>right</code> 返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;    <span class="comment">// 采用 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第 1 种返回</span></span><br><span class="line">    <span class="comment">// return right;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 2 种返回</span></span><br><span class="line">    <span class="keyword">if</span>(right&lt;<span class="number">0</span> || right&gt;=nums.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums[right]==target? right : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以去做 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><strong>在左右边界的代码中，所有的情况，都是需要变动 <code>mid</code> 的，如<code>mid+1</code>或<code>mid-1</code>，记住</strong>！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分查找框架</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;    <span class="comment">// 区间[left, right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return left;</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">0</span> || left&gt;=nums.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left]==target? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;    <span class="comment">// 区间[left, right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return right;</span></span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">0</span> || right&gt;=nums.<span class="built_in">size</span>())  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==target? right : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">left_bound</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">right_bound</span>(nums, target);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二分思维的精髓就是：<strong>通过已知信息尽可能多地收缩（折半）搜索空间</strong>，从而增加穷举效率，快速找到目标。</p>
<p>但实际题目中不会直接让你写二分代码，我会在 【<a target="_blank" rel="noopener" href="https://labuladong.online/algo/frequency-interview/binary-search-in-action/">二分查找的运用</a>】 和 【<a target="_blank" rel="noopener" href="https://labuladong.online/algo/problem-set/binary-search/">二分查找的更多习题</a>】 中进一步讲解如何把二分思维运用到更多算法题中</p>
<h2 id="五-递归（一个视角-两种思维）">(五) 递归（一个视角+两种思维）</h2>
<blockquote>
<p><strong>一个视角是指「树」的视角，两种思维模式是指「遍历」和「分解问题」两种思维模式</strong>。</p>
<ol>
<li>算法的本质是穷举，递归是一种重要的穷举手段，递归的正确理解方法是从「<strong>树</strong>」的角度理解。</li>
<li>编写递归算法，有两种思维模式：一种是通过「<strong>遍历</strong>」一遍树得到答案，另一种是通过「<strong>分解问题</strong>」得到答案。</li>
</ol>
</blockquote>
<h3 id="1、从树的角度理解递归">1、从树的角度理解递归</h3>
<ul>
<li><strong>斐波那契数列</strong></li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509.斐波那契数</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>)</span><br><span class="line">         + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全排列问题</strong></li>
<li>参考:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46.全排列</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;   <span class="comment">// 记录一条完整答案</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visit; <span class="comment">// 记录当前访问情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从树的角度理解递归</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        visit.<span class="built_in">assign</span>(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 只需要访问根节点即可</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多叉树遍历子节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 已经访问到叶节点了</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 未访问过的，都是子节点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[i])  <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问这个子节点的所在的树</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 退回</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以抽象看成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列算法主要结构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (track.<span class="built_in">size</span>() == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, track);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你应该已经感觉到了，「树」结构是一个非常有效的数据结构。<strong>把问题抽象成树结构，然后用代码去遍历这棵树</strong>，就是<strong>递归的本质</strong>。</p>
<h3 id="2、编写递归的两种思维模式">2、编写递归的两种思维模式</h3>
<blockquote>
<p>上面讲的两道例题中，它们虽然都抽象成了一棵<strong>递归树</strong>，但<strong>斐波那契数列</strong>使用的是「<strong>分解问题</strong>」的思维模式求解，<strong>全排列</strong>使用的是「<strong>遍历</strong>」的思维模式求解。</p>
</blockquote>
<ul>
<li>
<p><strong>分解问题的思维模式</strong><br>
如果你想用「分解问题」的思维模式来写递归算法，那么这个<strong>递归函数</strong>一定要有一个<strong>清晰的定义</strong>，说明这个函数参数的含义是什么，返回什么结果。</p>
</li>
<li>
<p>二叉树的最大深度<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 分解问题的递归</span></span><br><span class="line">    <span class="comment">// 递归函数有清晰定义：f(父) = max&#123; f(子) &#125; + 1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经抵达叶节点的子节点（空）</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归：分解问题</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>遍历的思维模式</strong><br>
递归树上的节点并没有一个明确的含义，只是记录了之前所做的一些选择。所有全排列，就是所有叶子节点上的结果。这种思维模式称为「遍历」。<br>
如果你想用「遍历」的思维模式来写递归算法，那么你需要一个<strong>无返回值</strong>的遍历函数，在遍历的<strong>过程中收集结果</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列算法主要结构</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归树遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 到达叶节点，收集结果</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="comment">// 做出选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看前面的二叉树的最大深度，实际上遍历整棵树，在遍历的过程更新最大深度，这样当遍历完所有节点时，必然可以求出整棵树的最大深度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归：遍历思维也可以</span></span><br><span class="line">    <span class="comment">// 遍历，无返回值，过程中收集结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 到达叶节点，收集答案</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur++;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参考以下步骤，运用自如地写出递归算法：
<ol>
<li>首先，这个问题是否可以<strong>抽象成一棵树</strong>结构？如果可以，那么就要用递归算法了。</li>
<li>如果要用递归算法，那么就思考「遍历」和「分解问题」这两种思维模式，看看哪种更适合这个问题。</li>
<li>如果用「<strong>分解</strong>问题」的思维模式，那么一定要写清楚这个<strong>递归函数的定义</strong>是什么，然后利用这个定义来分解问题，利用子问题的答案推导原问题的答案。</li>
<li>如果用「<strong>遍历</strong>」的思维模式，那么要用一个<strong>无返回值</strong>的递归函数，单纯起到遍历递归树，到达<strong>叶节点收集结果</strong>的作用。</li>
</ol>
</li>
</ul>
<blockquote>
<p>「<strong>分解问题</strong>」的思维模式就对应着后面要讲解的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/dynamic-programming-framework/">动态规划算法</a> 和 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/divide-and-conquer/">分治算法</a>。</p>
<p>「<strong>遍历</strong>」的思维模式就对应着后面要讲解的 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/backtrack-framework/">DFS/回溯算法</a>。</p>
<p>在 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/intro/binary-tree-practice/">二叉树习题章节</a>，把所有二叉树相关的题目都用这两种思维模式来解一遍。你只要把二叉树玩明白了，这些递归算法就都玩明白了，真的很简单。</p>
</blockquote>
<h2 id="六-动态规划">(六) 动态规划</h2>
<blockquote>
<ul>
<li>动态规划问题的一般形式就是<strong>求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。</li>
<li>求解动态规划的核心问题是<strong>穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</li>
<li>只有列出正确的「<strong>状态转移方程</strong>」，才能正确地穷举。</li>
</ul>
<ol>
<li>是否具备「<strong>最优子结构</strong>」: 是否能够通过子问题的最值得到原问题的最值</li>
<li>存在「<strong>重叠子问题</strong>」: 需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算</li>
</ol>
<p>动态规划三要素：状态转移方程、最优子结构、重叠子问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自顶向下递归的动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">状态<span class="number">1</span>, 状态<span class="number">2</span>, ...</span>):</span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 所有可能的选择:</span><br><span class="line">        <span class="comment"># 此时的状态已经因为做了选择而改变</span></span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<h3 id="1、斐波那契数列">1、斐波那契数列</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/description/">509.斐波那契数</a></p>
<blockquote>
<p>斐波那契数列没有求最值，所以严格来说不是动态规划问题。主要是为了体现重叠子问题。</p>
</blockquote>
<ul>
<li>但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dp-fib.jpg" alt="fib"></li>
<li>二叉树节点总数为指数级别，所以子问题个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，计算解决一个子问题的时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，总复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<br>
注：满二叉树的节点个数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N=2^{h-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
<p><strong>带备忘录的递归解法</strong></p>
<ul>
<li>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</li>
<li>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归：备忘录</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo.<span class="built_in">assign</span>(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)  <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[n]!=<span class="number">0</span>)  <span class="keyword">return</span> memo[n];</span><br><span class="line">        </span><br><span class="line">        memo[n] = <span class="built_in">dp</span>(n<span class="number">-1</span>) + <span class="built_in">dp</span>(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dp-fib-1.jpg" alt="递归树情况"></p>
<ul>
<li>
<p>子问题个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，总复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dp-fib-1-1.jpg" alt="自顶向下"></p>
</li>
<li>
<p>带<strong>备忘录的递归</strong>解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和常见的动态规划解法已经差不多了，只不过这种解法是「<strong>自顶向下</strong>」进行「<strong>递归</strong>」求解</p>
</li>
<li>
<p>我们更常见的<strong>动态规划</strong>代码是「<strong>自底向上</strong>」进行「<strong>递推</strong>」求解。</p>
</li>
</ul>
<p><strong>带dp表的动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 带dp的动态规划</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp.<span class="built_in">assign</span>(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dp-fib-2.jpg" alt="自底向上"></p>
<ul>
<li>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即<strong>状态转移方程</strong>。</li>
<li>只要写出暴力解，优化方法无非是用<code>备忘录</code>或者 <code>DP table</code>，再无奥妙可言。</li>
</ul>
<h3 id="2、凑零钱">2、凑零钱</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322.零钱兑换</a></p>
<ul>
<li>
<p>给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 <code>-1</code> 。算法的函数签名如下：<br>
<code>int coinChange(vector&lt;int&gt;&amp; coins, int amount);</code></p>
</li>
<li>
<p>这个问题是动态规划问题，因为它具有「<strong>最优子结构</strong>」的。要符合「最优子结构」，<strong>子问题间必须互相独立</strong>。</p>
</li>
</ul>
<blockquote>
<p>什么是子问题相互独立？<br>
比如问题是考出最高的总成绩，那么将每门科目考到最高，这些子问题是互相独立，互不干扰的，那就是符号最优子结构。<br>
如果加一条限制，数学越好语文就会越差，那么就不是相互独立的了，也就不符合最优子结构。</p>
</blockquote>
<ol>
<li>确定「<strong>状态</strong>」，也就是原问题和子问题中会变化的变量。</li>
<li>确定「<strong>选择</strong>」，也就是导致「状态」产生变化的行为。</li>
<li>明确 <strong>dp</strong> 函数/数组的定义。</li>
</ol>
<p>先看直接单纯写出递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 暴力递归</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp(n) 是凑成n所需最少数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span> )  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="comment">// 计算子问题的解</span></span><br><span class="line">            <span class="type">int</span> subProblem = <span class="built_in">dp</span>(coins, amount-coin);</span><br><span class="line">            <span class="comment">// 无解跳过</span></span><br><span class="line">            <span class="keyword">if</span>(subProblem == <span class="number">-1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 有解更新</span></span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>)  ans = subProblem+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">min</span>(ans, subProblem+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这实际上就是暴力计算：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><mi>n</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mspace width="1em"/><mi mathvariant="normal">∣</mi><mspace width="1em"/><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo>∈</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">}</mo><mspace width="1em"/><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp(n) = \begin{cases}
-1,\quad n&lt;0\\
0,\quad n=0\\
min\{ dp(n-coin)+1 \quad | \quad coin\in coins  \}\quad n&gt;0 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">min</span><span class="mopen">{</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">in</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">in</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mclose">}</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>画出递归树：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dp-coins-1.jpg" alt="递归树"></p>
<ul>
<li>递归算法的时间复杂度分析：<strong>子问题总数 x 解决每个子问题所需的时间</strong>。</li>
<li>假设目标金额为 <code>n</code>，给定的硬币个数为 <code>k</code>，那么递归树最坏情况下高度为 <code>n</code>（全用面额为 1 的硬币），然后再假设这是一棵满 <code>k</code> 叉树，则节点的总数在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这个数量级。每个子问题的复杂度，由于每次递归包含一个 <code>for</code> 循环，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，相乘得到总时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，指数级别。</li>
<li>这个问题其实就解决了，只不过需要消除一下重叠子问题。</li>
</ul>
<p><strong>带备忘录的递归</strong><br>
就只需要在每次进入子问题前，看是不是计算过即可。</p>
<ol>
<li>计算前，看备忘录是不是计算过。</li>
<li>离开前，在备忘录记下计算结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归：改进备忘录</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        memo.<span class="built_in">assign</span>(amount+<span class="number">1</span>, <span class="number">-666</span>);    <span class="comment">// 先赋值为特殊记号，表示未计算过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp(n) 是凑成n所需最少数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span> )  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前，先看当前问题是不是计算过了</span></span><br><span class="line">        <span class="keyword">if</span>(memo[amount] != <span class="number">-666</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[amount];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin: coins)&#123;</span><br><span class="line">            <span class="comment">// 计算子问题的解</span></span><br><span class="line">            <span class="type">int</span> subProblem = <span class="built_in">dp</span>(coins, amount-coin);</span><br><span class="line">            <span class="comment">// 无解跳过</span></span><br><span class="line">            <span class="keyword">if</span>(subProblem == <span class="number">-1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 有解更新</span></span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>)  ans = subProblem+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">min</span>(ans, subProblem+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离开之前，记下备忘录</span></span><br><span class="line">        memo[amount] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>子问题总数不会超过金额数 <code>n</code>，即子问题数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。处理一个子问题的时间不变，仍是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，所以总的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">kn</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p><strong>带dp的动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 动态规划：dp表</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        dp.<span class="built_in">assign</span>(amount+<span class="number">1</span>, amount+<span class="number">1</span>);  <span class="comment">// 直接初始化为比金额还大 1，表示组不成</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> coin: coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-coin &lt; <span class="number">0</span>)  <span class="keyword">continue</span>;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;amount? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>显然时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(kn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">kn</span><span class="mclose">)</span></span></span></span></li>
</ul>
<blockquote>
<p>为什么凑零钱问题<strong>不能用贪心</strong>算法来解？因为想要硬币数最少，那就总是先使用面额大的硬币来凑？</p>
<ul>
<li>这题不能用贪心，贪心的意思是说，一路按照最优选择选下去，就一定能得到正确答案（专业术语叫做贪心选择性质）。而这道题是不满足贪心选择性质的。你如果无脑选用大额硬币，不一定就能凑出目标金额，即便凑出了，也不一定是最小的数量。</li>
<li>比如要凑8块，有1，4，5面值的钱，贪心就是【5，1，1，1】，正确答案是【4，4】</li>
<li>那么这时候你就要尝试其他较小的金额了，所以说到底还是得暴力穷举所有情况，需要用递归进行暴力穷举。通过观察暴力穷举解法代码，我们发现这道题存在最优子结构和重叠子问题，所以逐步优化写出了带备忘录的递归穷举解法（动态规划）。</li>
<li>注意上面这个思考过程，从<strong>暴力穷举</strong>算法开始，逐步尝试各种<strong>优化</strong>方法。至于「贪心」「动态规划」这种名词，只不过是对不同优化过程的代称罢了。</li>
</ul>
</blockquote>
<p>计算机解决问题其实没有任何特殊的技巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考「如何穷举」，然后再追求「如何聪明地穷举」。</p>
<ol>
<li>列出<strong>状态转移方程</strong>，就是在解决「<strong>如何穷举</strong>」的问题。<br>
之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</li>
<li><strong>备忘录、<code>DP table</code></strong> 就是在追求「<strong>如何聪明地穷举</strong>」。<br>
用空间换时间的思路，是降低时间复杂度的不二法门。</li>
</ol>
<h2 id="七-回溯-DFS">(七) 回溯(DFS)</h2>
<blockquote>
<p>其实回溯算法和我们常说的 DFS 算法基本可以认为是同一种算法，它们的细微差异在之后章节说明。</p>
<ul>
<li>抽象地说，解决一个<strong>回溯</strong>问题，实际上就是<strong>遍历一棵决策树</strong>的过程，树的<strong>每个叶子节点存放着一个合法答案</strong>。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。</li>
<li>站在回溯树的一个节点上，你只需要思考 3 个问题：
<ol>
<li><strong>路径</strong>：也就是已经做出的选择。</li>
<li><strong>选择列表</strong>：也就是你当前可以做的选择。</li>
<li><strong>结束条件</strong>：也就是到达决策树底层，无法再做选择的条件。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>。</p>
<h3 id="1、全排列">1、全排列</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46.全排列</a></p>
<blockquote>
<p>我们这次讨论的全排列问题不包含重复的数字，包含重复数字的扩展场景在之后章节。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-2.jpg" alt="决策树"><br>
我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列。</p>
</blockquote>
<p>框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode* child : root-&gt;childern) &#123;</span><br><span class="line">        // 前序位置需要的操作</span><br><span class="line">        traverse(child);</span><br><span class="line">        // 后序位置需要的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>疑问：多叉树 DFS 遍历框架的前序位置和后序位置应该在 for 循环外面，并不应该是在 for 循环里面呀？为什么在回溯算法中跑到 for 循环里面了？<br>
是的，DFS 算法的前序和后序位置应该在 for 循环外面，不过回溯算法和 DFS 算法略有不同，<a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/backtrack-vs-dfs/">解答回溯/DFS 算法的若干疑问</a> 会具体讲解，这里可以暂且忽略这个问题。</p>
</blockquote>
<p>前序和后序只是两个很有用的时间点：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-3.jpg" alt="前序、后序"><br>
前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。<br>
再看前面的：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-4.jpg" alt="对应决策树选择"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>
<p>好的，直接看一下完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯法</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        visit.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">backtrace</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 抵达叶节点，收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行一步决策选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入下一层决策树</span></span><br><span class="line">            <span class="built_in">backtrace</span>(nums);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            visit[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稍微做了些变通，没有显式记录「选择列表」，而是通过 used 数组排除已经存在 track 中的元素，从而推导出当前的选择列表：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-5.jpg" alt="正确的选择列表"></p>
<blockquote>
<ul>
<li>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">!)</span></span></span></span>，因为穷举整棵决策树是无法避免的，你最后肯定要穷举出 <code>N!</code> 种全排列结果。<br>
这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，<strong>回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。<br>
动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的。在 <a target="_blank" rel="noopener" href="https://labuladong.online/algo/essential-technique/binary-tree-summary/">二叉树心法（纲领篇）</a> 你将看到动态规划和回溯算法更深层次的区别和联系。</li>
</ul>
</blockquote>
<h2 id="八-BFS">(八) BFS</h2>
<blockquote>
<ul>
<li><strong>DFS/回溯</strong>算法的本质就是递归遍历一棵穷举树（多叉树），而多叉树的递归遍历又是从二叉树的递归遍历衍生出来的。所以我说 DFS/回溯算法的本质是<strong>二叉树的递归遍历</strong>。</li>
<li><strong>BFS</strong> 算法的本质就是遍历一幅<strong>图</strong>。而图的遍历算法其实就是多叉树的遍历算法加了个 visited 数组防止死循环；多叉树的遍历算法又是从二叉树遍历算法衍生出来的。所以我说 BFS 算法的本质就是二叉树的<strong>层序遍历</strong>。</li>
</ul>
</blockquote>
<h3 id="1、算法框架">1、算法框架</h3>
<ul>
<li>在前文图的数据结构里面，已经讲解了有三种写法，这里使用第二种。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数</span></span><br><span class="line"><span class="comment">// 当走到目标节点 target 时，返回步数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> Graph&amp; graph, <span class="type">int</span> s, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 记录从 s 开始走到当前节点的步数</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;visit &quot;</span> &lt;&lt; cur &lt;&lt; <span class="string">&quot; at step &quot;</span> &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将邻居节点加入队列，向四周扩散搜索</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> to : <span class="built_in">neighborsOf</span>(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[to]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                    visited[to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果走到这里，说明在图中没有找到目标节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、滑动谜题">2、滑动谜题</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-puzzle/description/">773.滑动谜题</a></p>
<ul>
<li>给你一个 <code>2x3</code> 的滑动拼图，用一个 <code>2x3</code> 的数组 <code>board</code> 表示。拼图中有数字 <code>0~5</code> 六个数，其中数字 <code>0</code> 就表示那个空着的格子，你可以移动其中的数字，当 <code>board</code> 变为 <code>[[1,2,3],[4,5,0]]</code> 时，赢得游戏。<br>
请你写一个算法，计算赢得游戏需要的最少移动次数，如果不能赢得游戏，返回 <code>-1</code>。<br>
比如说输入的二维数组 <code>board = [[4,1,2],[5,0,3]]</code>，算法应该返回 <code>5</code>：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/bfs-game-board.jpeg" alt="示例"><br>
如果输入的是 <code>board = [[1,2,3],[5,4,0]]</code>，则算法返回 <code>-1</code>，因为这种局面下无论如何都不能赢得游戏。</li>
</ul>
<blockquote>
<ul>
<li>抽象出来的图结构也是会包含环的，所以需要一个 <code>visited</code> 数组记录已经走过的节点，避免成环导致死循环。</li>
<li>注意，此时是整张图的状态完全和之前一样了才是成环了，所以<code>visited</code>的索引，应该是一整张图的状态。但二维数组这种可变数据结构是无法直接加入哈希集合的。</li>
<li>再用一点技巧，想办法把二维数组转化成一个不可变类型才能存到哈希集合中。常见的解决方案是把二维数组序列<strong>化成一个字符串</strong>，这样就可以直接存入哈希集合了。</li>
</ul>
</blockquote>
<p>其中比较有技巧性的点在于，二维数组有「<strong>上下左右</strong>」的概念，压缩成一维的字符串后后，还怎么把数字 0 和上下左右的数字进行交换？对于这道题，题目说输入的数组大小都是 2 x 3，所以我们可以直接手动写出来这个映射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录一维字符串的相邻索引</span></span><br><span class="line"><span class="type">int</span> map[<span class="number">6</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个映射的含义就是，<strong>在一维字符串中，索引 <code>i</code> 在二维数组中的的相邻索引为 <code>neighbor[i]</code></strong>：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/bfs-game-neighbor.jpeg" alt="索引转换"><br>
这样，无论数字 0 在哪里，都可以通过这个索引映射得到它的相邻索引进行交换了。</p>
<blockquote>
<p>如果是 <code>m x n</code> 的二维数组，怎么办？<br>
用代码生成它的一维索引映射。<br>
观察上图就能发现，如果二维数组中的某个元素 <code>e</code> 在一维数组中的索引为 <code>i</code>，那么 <code>e</code> 的左右相邻元素在一维数组中的索引就是 <code>i - 1</code> 和 <code>i + 1</code>，而 <code>e</code> 的上下相邻元素在一维数组中的索引就是 <code>i - n</code> 和 <code>i + n</code>，其中 <code>n</code> 为二维数组的列数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成邻居表</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateNeighborTable</span>(<span class="type">int</span> m, <span class="type">int</span> n)&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m*n; i++)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; one;</span><br><span class="line">        <span class="comment">// 不是第一列，有左侧邻居</span></span><br><span class="line">        <span class="keyword">if</span>(i%n != <span class="number">0</span>)  one.<span class="built_in">push_back</span>(i<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 不是最后列，有右侧邻居</span></span><br><span class="line">        <span class="keyword">if</span>(i%n != n<span class="number">-1</span>)  one.<span class="built_in">puhs_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不是第一行，有上侧邻居</span></span><br><span class="line">        <span class="keyword">if</span>(i-n &gt;= <span class="number">0</span>)  one.<span class="built_in">push_back</span>(i-n);</span><br><span class="line">        <span class="comment">// 不是最后行，有下侧邻居</span></span><br><span class="line">        <span class="keyword">if</span>(i+n &lt; m*n)  one.<span class="built_in">push_back</span>(i+n);</span><br><span class="line">        map[i] = one;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，至此，解法已经出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string target = <span class="string">&quot;123450&quot;</span>;       <span class="comment">// 目标状态图</span></span><br><span class="line">    unordered_set&lt;string&gt; visit;    <span class="comment">// 记录已出现过的状态，防止成环</span></span><br><span class="line">    <span class="comment">// 索引表，map[2] 表示 s[2] 的上下左右邻居在 s 中的索引</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; map = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// BFS 框架</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">slidingPuzzle</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Tips: 转为 string 操作（方便 1 判断相同、2 哈希存储）</span></span><br><span class="line">        string start = <span class="string">&quot;000000&quot;</span>;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                start[i*n+j] = board[i][j] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* --- BFS 框架 --- */</span></span><br><span class="line">        queue&lt;string&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(start);</span><br><span class="line">        visit.<span class="built_in">insert</span>(start);</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 本层所有的状态图</span></span><br><span class="line">            <span class="type">int</span> sz = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++)&#123;</span><br><span class="line">                string cur = Q.<span class="built_in">front</span>();  Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 已经抵达</span></span><br><span class="line">                <span class="keyword">if</span>(cur == target)  <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">// 下一层状态图入队</span></span><br><span class="line">                <span class="keyword">for</span>(string next: <span class="built_in">getNeighbor</span>(cur))&#123;</span><br><span class="line">                    <span class="comment">// 防止成环</span></span><br><span class="line">                    <span class="keyword">if</span>(visit.<span class="built_in">count</span>(next))  <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 入队</span></span><br><span class="line">                    Q.<span class="built_in">push</span>(next);</span><br><span class="line">                    visit.<span class="built_in">insert</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入下层，步数加一</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --- BFS 框架 --- */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回cur的下一步状态图</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string cur)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; all;</span><br><span class="line">        <span class="type">int</span> zero = cur.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> idx: map[zero])&#123;</span><br><span class="line">            string next = cur;</span><br><span class="line">            next[zero] = cur[idx];</span><br><span class="line">            next[idx] = cur[zero];</span><br><span class="line">            all.<span class="built_in">push_back</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你会发现，这里对于 <code>visit</code> 只有 <code>insert</code> 并没有 <code>erase</code>，因为并不会回滚，我们是 BFS，广度优先遍历不存在回滚状态。</p>
<h3 id="3、解开密码锁的最少次数">3、解开密码锁的最少次数</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/open-the-lock/description/">752.打开转盘锁</a></p>
<ul>
<li>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为 <code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。<br>
锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。<br>
列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。<br>
字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>
</li>
<li>
<p>示例1：<br>
输入: <code>deadends = [&quot;8888&quot;], target = &quot;0009&quot;</code><br>
输出： <code>1</code><br>
解释：把最后一位反向旋转一次即可 <code>&quot;0000&quot; -&gt; &quot;0009&quot;</code>。</p>
</li>
<li>
<p>示例2：<br>
输入：<code>deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</code><br>
输出：<code>6</code><br>
解释：可能的移动序列为 <code>&quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;</code>。注意 <code>&quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot;</code> 这样的序列是不能解锁的，因为当拨动到 “0102” 时这个锁就会被锁定。</p>
</li>
</ul>
<p>千万不要陷入细节，尝试去想各种具体的情况。要知道算法的本质就是<strong>穷举</strong>，我们直接从 “0000” 开始暴力穷举，把所有可能的拨动情况都穷举出来，难道还怕找不到最少的拨动次数么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_set&lt;string&gt; visit;</span><br><span class="line">    unordered_set&lt;string&gt; dead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// BFS 框架</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 死亡状态也用哈希集合</span></span><br><span class="line">        <span class="keyword">for</span>(string state: deadends)  dead.<span class="built_in">insert</span>(state);</span><br><span class="line">        queue&lt;string&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> sz = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz; i++)&#123;</span><br><span class="line">                <span class="comment">// 读取队头</span></span><br><span class="line">                string cur = Q.<span class="built_in">front</span>();  Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 成功状态</span></span><br><span class="line">                <span class="keyword">if</span>(cur == target)  <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">// 死亡状态</span></span><br><span class="line">                <span class="keyword">if</span>(dead.<span class="built_in">count</span>(cur))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下一层入队</span></span><br><span class="line">                <span class="keyword">for</span>(string next : <span class="built_in">getNeighbors</span>(cur))&#123;</span><br><span class="line">                    <span class="comment">// 防成环(不会矛盾的，是使用全部四个字符，一起作为状态来哈希的)</span></span><br><span class="line">                    <span class="keyword">if</span>(visit.<span class="built_in">count</span>(next))  <span class="keyword">continue</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(next);</span><br><span class="line">                    visit.<span class="built_in">insert</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一层，步数+1</span></span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 cur 的旋转一次的可能(8个)</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbors</span><span class="params">(string cur)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; all;</span><br><span class="line">        <span class="type">char</span> map[<span class="number">10</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;, &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;, &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;,&#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;4&#x27;</span>&#125;, &#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;, &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;7&#x27;</span>&#125;, &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;,&#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;, &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            string next = cur;</span><br><span class="line">            next[i] = map[cur[i]-<span class="string">&#x27;0&#x27;</span>][<span class="number">0</span>];</span><br><span class="line">            all.<span class="built_in">push_back</span>(next);</span><br><span class="line">            next[i] = map[cur[i]-<span class="string">&#x27;0&#x27;</span>][<span class="number">1</span>];</span><br><span class="line">            all.<span class="built_in">push_back</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这里对于死亡状态的处理，也可以在准备入队的时候就直接不入队。各有利弊。</p>
</blockquote>
<h3 id="4、双向-BFS-优化">4、双向 BFS 优化</h3>
<blockquote>
<p>下面再介绍一种 BFS 算法的优化思路：双向 BFS，可以提高 BFS 搜索的效率。<br>
在一般的面试笔试题中，普通的 BFS 算法已经够用了，如果遇到超时无法通过，或者面试官的追问，可以考虑解法是否需要双向 BFS 优化。</p>
<p>双向 BFS 就是从标准的 BFS 算法衍生出来的：<br>
<strong>传统的 BFS 框架是从起点开始向四周扩散，遇到终点时停止</strong>；<br>
<strong>而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/bfs-traditional.jpeg" alt="传统BFS"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/bfs-youhua.jpeg" alt="双向BFS"></p>
</blockquote>
<ul>
<li>图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code>target</code>；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</li>
<li>当然从 Big O 表示法分析算法复杂度的话，这两种 BFS 在最坏情况下都可能遍历完所有节点，所以<strong>理论时间复杂度都是</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，但<strong>实际运行中双向 BFS 确实会更快</strong>一些。</li>
</ul>
<blockquote>
<p>双向 BFS 的局限性：你必须<strong>知道终点</strong>在哪里，才能使用双向 BFS 进行优化。<br>
上述两题可以直接知道终点。<br>
但是比如求树的最小高度，就不知道终点。</p>
</blockquote>
<p>以密码锁为例，这里直接给代码，不再讲解，实际上考试和竞赛，就用上述的代码就行。这里的优化，只需要知道有这么一个思路，在面试时可以讲出来就行，不追求代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">deads</span><span class="params">(deadends.begin(), deadends.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (deads.<span class="built_in">count</span>(<span class="string">&quot;0000&quot;</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">&quot;0000&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用集合不用队列，可以快速判断元素是否存在</span></span><br><span class="line">        unordered_set&lt;string&gt; q1;</span><br><span class="line">        unordered_set&lt;string&gt; q2;</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        q1.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        q2.<span class="built_in">insert</span>(target);</span><br><span class="line">        visited.<span class="built_in">insert</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在这里增加步数</span></span><br><span class="line">            step++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 哈希集合在遍历的过程中不能修改，所以用 newQ1 存储邻居节点</span></span><br><span class="line">            unordered_set&lt;string&gt; newQ1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 q1 中的所有节点的邻居</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> string&amp; cur : q1) &#123;</span><br><span class="line">                <span class="comment">// 将一个节点的未遍历相邻节点加入集合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> string&amp; neighbor : <span class="built_in">getNeighbors</span>(cur)) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否到达终点</span></span><br><span class="line">                    <span class="keyword">if</span> (q2.<span class="built_in">count</span>(neighbor)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.<span class="built_in">count</span>(neighbor) &amp;&amp; !deads.<span class="built_in">count</span>(neighbor)) &#123;</span><br><span class="line">                        newQ1.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">                        visited.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// newQ1 存储着 q1 的邻居节点</span></span><br><span class="line">            q1 = newQ1;</span><br><span class="line">            <span class="comment">// 因为每次 BFS 都是扩散 q1，所以把元素数量少的集合作为 q1</span></span><br><span class="line">            <span class="keyword">if</span> (q1.<span class="built_in">size</span>() &gt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 s[j] 向上拨动一次</span></span><br><span class="line">    <span class="function">string <span class="title">plusOne</span><span class="params">(string s, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[j] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 s[i] 向下拨动一次</span></span><br><span class="line">    <span class="function">string <span class="title">minusOne</span><span class="params">(string s, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            s[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s[j] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbors</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; neighbors;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            neighbors.<span class="built_in">push_back</span>(<span class="built_in">plusOne</span>(s, i));</span><br><span class="line">            neighbors.<span class="built_in">push_back</span>(<span class="built_in">minusOne</span>(s, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>双向 BFS 还是遵循 BFS 算法框架的，但是有几个细节区别：</p>
<ol>
<li>不再使用队列存储元素，而是改用 哈希集合，方便<strong>快速判两个集合是否有交集</strong>。</li>
<li>调整了 <code>return step</code> 的位置。因为双向 BFS 中不再是简单地判断是否到达终点，而是判断两个集合是否有交集，所以要在计算出邻居节点时就进行判断。</li>
<li>还有一个优化点，每次都保持 <code>q1</code> 是元素数量较小的集合，这样可以一定程度减少搜索次数。<br>
因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散邻居节点之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</li>
</ol>
<p>不过话说回来，<strong>无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的</strong>，只能说双向 BFS 是一种进阶技巧，算法运行的速度会相对快一点，掌握不掌握其实都无所谓。</p>
<h2 id="九-二叉树系列">(九) 二叉树系列</h2>
<blockquote>
<p>二叉树解题的思维模式分两类：</p>
<ol>
<li>是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「<strong>遍历</strong>」的思维模式。</li>
<li>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「<strong>分解问题</strong>」的思维模式。<br>
无论使用哪种思维模式，你都需要思考：如果单独抽出<strong>一个二叉树节点</strong>，它需要<strong>做什么事情</strong>？需要<strong>在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>关注点</th>
<th>操作位置</th>
<th>区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态规划</td>
<td>分解</td>
<td>整个子树</td>
<td>后序位置</td>
<td>\</td>
</tr>
<tr>
<td>回溯</td>
<td>遍历(递归)</td>
<td>树枝(边)</td>
<td>\</td>
<td>做选择、撤销选择在for循环里面</td>
</tr>
<tr>
<td>DFS</td>
<td>遍历(递归)</td>
<td>节点</td>
<td>\</td>
<td>做选择、撤销选择在for循环外面</td>
</tr>
<tr>
<td>BFS</td>
<td>遍历(迭代)</td>
<td>节点</td>
<td>\</td>
<td>\</td>
</tr>
</tbody>
</table>
<h3 id="1、二叉树的重要性、深入理解前中后序">1、二叉树的重要性、深入理解前中后序</h3>
<ul>
<li>举个例子，比如两个经典排序算法 快速排序 和 归并排序，对于它俩，你有什么理解？</li>
<li>如果你告诉我，<strong>快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历</strong>，那么我就知道你是个算法高手了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ****** 前序遍历位置 ******</span></span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// ************************</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">    <span class="built_in">sort</span>(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">    <span class="built_in">sort</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ****** 后序位置 ******</span></span><br><span class="line">    <span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">// *********************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题。</p>
<p>1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？</p>
<p>2、请分析，后序遍历有什么特殊之处？</p>
<p>3、请分析，为什么多叉树没有中序遍历？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不管所谓前中后序，单看 traverse 函数，你说它在做什么事情？其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代遍历数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(arr, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ListNode* p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">traverse</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，它没办法简单改写成 for 循环的迭代形式，所以我们遍历二叉树一般都使用递归形式。你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</p>
<p>所谓<strong>前序位置</strong>，就是<strong>刚进入一个节点（元素）的时候</strong>，<strong>后序位置</strong>就是<strong>即将离开一个节点（元素）的时候</strong>，那么进一步，你把代码写在不同位置，代码执行的时机也不同：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-weizhi.jpeg" alt="前序、后序时机"></p>
<p>比如说，如果让你<strong>倒序打印</strong>一条单链表上所有节点的值，你怎么搞？实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归遍历单链表，倒序打印链表元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traverse</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上是利用<strong>递归的堆栈</strong>帮你实现了倒序遍历的效果。</p>
<blockquote>
<p>前序位置的代码在刚刚进入一个二叉树节点的时候执行；<br>
后序位置的代码在将要离开一个二叉树节点的时候执行；<br>
中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-qzhxu.jpeg" alt="执行"><br>
你可以发现每个节点都有「唯一」属于自己的前中后序位置，所以我说前中后序遍历是遍历二叉树过程中处理每一个<strong>节点</strong>的<strong>三个特殊时间点</strong>。<br>
因为二叉树的每个节点只会进行<strong>唯一一次左子树切换右子树</strong>，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以<strong>多叉树节点没有「唯一」的中序遍历位置</strong>。</p>
</blockquote>
<blockquote>
<p><strong>二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作</strong>。</p>
</blockquote>
<h3 id="2、两种解题思路">2、两种解题思路</h3>
<blockquote>
<p>二叉树题目的递归解法可以分两类思路，<br>
第一类是<strong>遍历</strong>一遍二叉树得出答案，<br>
第二类是通过<strong>分解</strong>问题计算出答案，<br>
这两类思路分别对应着 <strong>回溯</strong>算法核心框架 和 <strong>动态规划</strong>核心框架。</p>
</blockquote>
<p>二叉树的最大深度这个问题来举例：</p>
<ul>
<li><strong>遍历思路</strong>：所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数。遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度。</li>
<li><strong>分解思路</strong>：一棵二叉树的最大深度可以通过子树的最大深度推导出来。</li>
</ul>
<p>那么我们再回头看看最基本的<strong>二叉树前中后序遍历</strong>，就比如力扣第 144 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a>」，让你计算前序遍历结果。</p>
<p>普通解法，就是<strong>遍历思想</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 存放前序遍历结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前序遍历结果</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>能否改成<strong>分解思想</strong>？<br>
<strong>一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历的结果，root-&gt;val 在第一个</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="comment">// 利用函数定义，后面接着左子树的前序遍历结果</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(), left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 利用函数定义，最后接着右子树的前序遍历结果</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(), right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>综上，遇到一道二叉树的题目时的通用思考过程是：<br>
1、<strong>是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 traverse 函数配合外部变量来实现。<br>
2、<strong>是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。<br>
3、<strong>无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://labuladong.online/algo/intro/binary-tree-practice/">小题狂练-二叉树系列</a></p>
</blockquote>
<h3 id="3、后序位置的特殊之处">3、后序位置的特殊之处</h3>
<p>先简单说下前序和中序：</p>
<ul>
<li>前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。</li>
<li>中序位置主要用在 BST（二叉搜索树） 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。</li>
</ul>
<blockquote>
<p>仔细观察，<strong>前中后序位置的代码，能力依次增强</strong>。</p>
<ul>
<li>前序位置的代码只能从函数参数中获取<strong>父节点传递来的数据</strong>。</li>
<li>中序位置的代码不仅可以获取参数数据，还可以获取到<strong>左子树通过函数返回值</strong>传递回来的数据。</li>
<li>后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到<strong>左右子树通过函数返回值</strong>传递回来的数据。</li>
</ul>
<p>所以，某些情况下把代码移到后序位置效率最高；<strong>有些事情，只有后序位置的代码能做</strong>。</p>
</blockquote>
<p>举些具体的例子来感受下它们的能力区别。现在给你一棵二叉树，我问你两个简单的问题：<br>
1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？<br>
2、如何打印出每个节点的左右子树各有多少节点？<br>
第一题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Node %d at level %d&quot;</span>, root-&gt;val, level);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line"><span class="built_in">traverse</span>(root, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>第二题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> leftCount = <span class="built_in">count</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightCount = <span class="built_in">count</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点 %p 的左子树有 %d 个节点，右子树有 %d 个节点&quot;</span>,</span><br><span class="line">            root, leftCount, rightCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你必须遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。<br>
结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。<br>
那么换句话说，<strong>一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">543.二叉树的直径</a></p>
<ul>
<li>所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度（经过的连线数量）。最长「直径」并不一定要穿过根结点。</li>
<li>解决这题的关键在于，每一条二叉树的「直径」长度，就是<strong>一个节点的左右子树的最大深度之和</strong>。<br>
求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。</li>
</ul>
<p>先看下面的解法，或许你会觉得奇怪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 记录最大直径的长度</span></span><br><span class="line">    <span class="type">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径，求最大直径</span></span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对每个节点计算直径</span></span><br><span class="line">        <span class="type">int</span> leftMax = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> myDiameter = leftMax + rightMax;</span><br><span class="line">        <span class="comment">// 更新全局最大直径</span></span><br><span class="line">        maxDiameter = <span class="built_in">max</span>(maxDiameter, myDiameter);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树的最大深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里实际上是使用前序遍历来做题，你会觉得奇怪，是前序位置还没得到子树的深度情况，不得不去调用递归函数获得数据。而后再对子树进行遍历。时间复杂度也高达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
然而，后序遍历就不需要这么复杂，因为它这个位置天然的就已经获取了左右子树的数据情况。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxDeep</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDeep</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ld = <span class="built_in">maxDeep</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rd = <span class="built_in">maxDeep</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, ld+rd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ld+<span class="number">1</span>, rd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考题：请你思考一下，<strong>运用后序遍历的题目使用的是「遍历」的思路还是「分解问题」的思路</strong>？<br>
利用后序位置的题目，一般都使用「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点 + 左右子树的子问题。<br>
反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。<br>
参考练习题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/binary-tree-part3/">二叉树心法-后序篇</a></li>
<li><a target="_blank" rel="noopener" href="https://labuladong.online/algo/data-structure/bst-part4/">二叉搜索树-后序篇</a></li>
<li><a target="_blank" rel="noopener" href="https://labuladong.online/algo/problem-set/binary-tree-post-order-i/">后序位置解题</a></li>
</ul>
</blockquote>
<h3 id="4、以树的视角看动归-回溯-DFS算法的区别和联系">4、以树的视角看动归/回溯/DFS算法的区别和联系</h3>
<blockquote>
<p>动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：</p>
<ul>
<li><strong>动态规划</strong>算法属于<strong>分解</strong>问题（分治）的思路，它的关注点在整棵「<strong>子树</strong>」。</li>
<li><strong>回溯</strong>算法属于<strong>遍历</strong>的思路，它的关注点在节点间的「<strong>树枝</strong>」。</li>
<li><strong>DFS</strong> 算法属于<strong>遍历</strong>的思路，它的关注点在单个「<strong>节点</strong>」。</li>
</ul>
<p>此外，两个遍历的区别在于：回溯算法和 DFS 算法代码中「<strong>做选择</strong>」和「<strong>撤销选择</strong>」的<strong>位置不同</strong>。<br>
DFS 算法把「做选择」「撤销选择」的逻辑放在 <strong>for 循环外面</strong>；<br>
回溯算法把「做选择」「撤销选择」的逻辑放在 <strong>for 循环里面</strong>。</p>
</blockquote>
<p><strong>例子1：分解思路（动态规划）</strong><br>
给你一棵二叉树，请你用分解问题的思路写一个 count 函数，计算这棵二叉树共有多少个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：输入一棵二叉树，返回这棵二叉树的节点总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前节点关心的是两个子树的节点总数分别是多少</span></span><br><span class="line">    <span class="comment">// 因为用子问题的结果可以推导出原问题的结果</span></span><br><span class="line">    <span class="type">int</span> leftCount = <span class="built_in">count</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightCount = <span class="built_in">count</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序位置，左右子树节点数加上自己就是整棵树的节点数</span></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是动态规划分解问题的思路，它的<strong>着眼点永远是结构相同的整个子问题</strong>，类比到二叉树上就是「<strong>子树</strong>」。</p>
<ul>
<li>参考例题就是斐波那契数列：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(N - <span class="number">1</span>) + <span class="built_in">fib</span>(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-fib.jpg" alt="斐波那契数"></p>
<p><strong>例子2：遍历思路（回溯）</strong><br>
给你一棵二叉树，请你用遍历的思路写一个 traverse 函数，打印出遍历这棵二叉树的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空（说明已经越过叶节点），就返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从节点 root 出发，沿着 left 边走</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从节点 %s 进入节点 %s&quot;</span>, root, root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 从节点 root 的左边回来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从节点 %s 回到节点 %s&quot;</span>, root-&gt;left, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 root 出发，沿着 right 边走</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从节点 %s 进入节点 %s&quot;</span>, root, root-&gt;right);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 从节点 root 的右边回来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从节点 %s 回到节点 %s&quot;</span>, root-&gt;right, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树也一样</span></span><br><span class="line"><span class="comment">// 多叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    std::vector&lt;Node*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;从节点 &quot;</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; 进入节点 &quot;</span> &lt;&lt; child-&gt;val &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">traverse</span>(child);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;从节点 &quot;</span> &lt;&lt; child-&gt;val &lt;&lt; <span class="string">&quot; 回到节点 &quot;</span> &lt;&lt; root-&gt;val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，这就是回溯算法遍历的思路，它的<strong>着眼点永远是在节点之间移动的过程</strong>，类比到二叉树上就是「<strong>树枝</strong>」。</p>
<ul>
<li>参考例题，就是全排列：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯算法核心部分代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 回溯算法框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        track.<span class="built_in">addLast</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下一层回溯树</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.<span class="built_in">removeLast</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-qpl.jpeg" alt="全排列"></p>
<p><strong>例子3：遍历思路（DFS）</strong><br>
给你一棵二叉树，请你写一个 traverse 函数，把这棵二叉树上的每个节点的值都加一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历过的每个节点的值加一</span></span><br><span class="line">    root-&gt;val++;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，这就是 DFS 算法遍历的思路，它的<strong>着眼点永远是在单一的节点上</strong>，类比到二叉树上就是处理每个「<strong>节点</strong>」。</p>
<ul>
<li>参考题目，岛屿问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 算法核心逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历过的每个格子标记为 0</span></span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-daoyu.jpg" alt="岛屿问题"></p>
<p>综上，<strong>动态规划关注整棵「子树」，回溯算法关注节点间的「树枝」，DFS 算法关注单个「节点」</strong>。<br>
有了这些铺垫，你就很容易理解为什么回溯算法和 DFS 算法代码中「做选择」和「撤销选择」的位置不同了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter node %s\n&quot;</span>, root-&gt;val.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leave node %s\n&quot;</span>, root-&gt;val.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m on the branch from %s to %s\n&quot;</span>, root-&gt;val.<span class="built_in">c_str</span>(), child-&gt;val.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(child);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;ll leave the branch from %s to %s\n&quot;</span>, child-&gt;val.<span class="built_in">c_str</span>(), root-&gt;val.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，你<strong>回溯算法必须把「做选择」和「撤销选择」的逻辑放在 for 循环里面，否则怎么拿到「树枝」的两个端点</strong>？</p>
<h3 id="5、层序遍历">5、层序遍历</h3>
<ul>
<li>二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/binTree-level.jpeg" alt="层序遍历"></p>
<p><strong>BFS</strong> 算法框架 就是从二叉树的<strong>层序遍历</strong>扩展出来的，常用于求无权图的最短路径问题。</p>
<p>拓展：玩的足够花的话，会有各种方法实现层序遍历：<br>
第一个花活：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelTraverse</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 视为第 0 层</span></span><br><span class="line">        <span class="built_in">traverse</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置，看看是否已经存储 depth 层的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt;= depth) &#123;</span><br><span class="line">            <span class="comment">// 第一次进入 depth 层</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt; &#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序位置，在 depth 层添加 root 节点的值</span></span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种思路从结果上说确实可以得到层序遍历结果，但其本质还是二叉树的前序遍历，或者说 DFS 的思路，而不是层序遍历，或者说 BFS 的思路。因为这个解法是依赖前序遍历自顶向下、自左向右的顺序特点得到了正确的结果。抽象点说，<strong>这个解法更像是从左到右的「列序遍历」，而不是自顶向下的「层序遍历」</strong>。所以对于计算最小距离的场景，这个解法完全等同于 DFS 算法，没有 BFS 算法的性能的优势。</p>
<p>第二个花活：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelTraverse</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">traverse</span>(nodes);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(vector&lt;TreeNode*&gt;&amp; curLevelNodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (curLevelNodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序位置，计算当前层的值和下一层的节点列表</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodeValues;</span><br><span class="line">        vector&lt;TreeNode*&gt; nextLevelNodes;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode* node : curLevelNodes) &#123;</span><br><span class="line">            nodeValues.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                nextLevelNodes.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                nextLevelNodes.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序位置添加结果，可以得到自顶向下的层序遍历</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(nodeValues);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(nextLevelNodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序位置添加结果，可以得到自底向上的层序遍历结果</span></span><br><span class="line">        <span class="comment">// res.push_back(nodeValues);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 traverse 函数很像递归遍历单链表的函数，其实就是<strong>把二叉树的每一层抽象理解成单链表的一个节点进行遍历</strong>。相较上一个递归解法，这个递归解法是自顶向下的「层序遍历」，更接近 BFS 的奥义，可以作为 BFS 算法的递归实现扩展一下思维。</p>
<blockquote>
<p>问：最后，不懂什么时候要新增traverse函数，什么时候直接用题目给的原函数递归。比如二叉树的直径，解法是需要新增一个递归函数maxDepth。我尝试直接递归原函数diameterOfBinaryTree，但行不通？<br>
答：因为要在 maxDepth 的后序位置<strong>操作外部变量</strong>，<strong>题目最终要的答案是那个外部变量</strong>，<strong>而不是 maxDepth 的返回值</strong>。所以这种情况下<strong>只能新建一个函数</strong>。如果题目要的答案恰好是你函数的返回值，那么你才可以直接用原函数递归。</p>
</blockquote>
<h2 id="十-排列、组合、子集（回溯）">(十) 排列、组合、子集（回溯）</h2>
<p>无论是排列、组合还是子集问题，简单说无非就是让你从序列 <code>nums</code> 中以给定规则取若干元素，主要有以下几种变体：</p>
<ul>
<li>形式一、<strong>元素无重不可复选</strong>，即 <code>nums</code> 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。<br>
以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 <code>7</code> 的组合应该只有 <code>[7]</code>。</li>
<li>形式二、<strong>元素有重不可复选</strong>，即 <code>nums</code> 中的元素有可能存在重复，每个元素最多只能被使用一次。<br>
以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。</li>
<li>形式三、<strong>元素无重可复选</strong>，即 <code>nums</code> 中的元素都是唯一的，每个元素可以被使用若干次。<br>
以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。</li>
<li>当然，也可以说有第四种形式，即元素可重可复选。但既然元素可复选，那又何必存在重复元素呢？<strong>元素去重之后就等同于形式三</strong>，所以这种情况不用考虑。<br>
上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。<br>
除此之外，题目也可以再添加各种限制条件，比如让你求和为 <code>target</code> 且元素个数为 <code>k</code> 的组合，那这么一来又可以衍生出一堆变体。<br>
但<strong>无论形式怎么变化，其本质就是穷举所有解</strong>，而这些解呈现<strong>树形结构</strong>，所以合理使用<strong>回溯算法框架</strong>，稍改代码框架即可把这些问题一网打尽。</li>
</ul>
<p>记住如下子集问题和排列问题的回溯树：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-zhzj.jpeg" alt="组合、子集的回溯树"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-pl.jpeg" alt="排列的回溯树"></p>
<p>首先，<strong>组合问题和子集问题其实是等价的</strong>，这个后面会讲；至于之前说的三种<strong>变化</strong>形式，无非是在这两棵树上<strong>剪掉或者增加</strong>一些树枝罢了。</p>
<h3 id="1、子集（元素无重不可复选）">1、子集（元素无重不可复选）</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/description/">78.子集</a></p>
<ul>
<li>给你一个无重复元素的数组 <code>nums</code>，其中每个元素最多使用一次，请你返回 <code>nums</code> 的所有子集。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯：元素无重复，不可重选</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 框架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进入一个节点，就开始收集结果（前序位置收集，看回溯树上的收集点）</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// 继续添加一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrace</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们通过保证元素之间的相对顺序不变来防止出现重复的子集。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/hiusu-zji-0.jpeg" alt="回溯树"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-zji-1.jpeg" alt="回溯树"></p>
<h3 id="2、组合（元素无重不可复选）">2、组合（元素无重不可复选）</h3>
<p>如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。<br>
比如说，让你在 <code>nums = [1,2,3]</code> 中拿 <code>2</code> 个元素形成所有的组合，你怎么做？稍微想想就会发现，大小为 <code>2</code> 的所有组合，不就是所有大小为 <code>2</code> 的子集嘛。所以我说组合和子集是一样的：<strong>大小为 k 的组合就是大小为 k 的子集</strong>。<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/">77.组合</a></p>
<ul>
<li>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</li>
</ul>
<p>反映到代码上，只需要稍改 base case，控制算法<strong>仅仅收集第 k 层节点的值</strong>即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯：组合，就是 k大小子集（这里nums = [1,2,...,n])</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 框架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case: 进入节点，收集时，只收集k大小的。且提前终止，不必再往下了。</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个新元素进入(直接用索引作为数字了)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=n; i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrace</span>(n, k, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、排列（元素无重不可复选）">3、排列（元素无重不可复选）</h3>
<p>就是全排列问题，前面讲过。<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46.全排列</a></p>
<ul>
<li>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-qpl.jpeg" alt="回溯树"><br>
用 <code>used</code> 数组标记已经在路径上的元素避免重复选择，然后收集所有叶子节点上的值，就是所有全排列的结果</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 防复选</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯：排列，无重复，不复选</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">backtrace</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 框架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 到达叶节点才收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])  <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtrace</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但如果题目不让你算全排列，而是让你算<strong>元素个数为 k 的排列</strong>，怎么算？<br>
也很简单，改下 <code>backtrack</code> 函数的 <code>base case</code>，仅收集第 <code>k</code> 层的节点值即可。</p>
<h3 id="4、子集-组合（元素有重不可复选）">4、子集/组合（元素有重不可复选）</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/description/">90.子集II</a></p>
<ul>
<li>给你一个整数数组 <code>nums</code>，其中可能包含重复元素，请你返回该数组所有可能的子集。</li>
<li>比如输入 <code>nums = [1,2,2]</code>，你应该输出：<br>
<code>[ [],[1],[2],[1,2],[2,2],[1,2,2] ]</code></li>
</ul>
<p>可以看到，[2] 和 [1,2] 这两个结果出现了重复，所以我们需要进行剪枝，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/hiusu-ziji2-1.jpeg" alt="回溯树"><br>
体现在代码上，需要先进行排序，让<strong>相同的元素靠在一起</strong>，如果发现 <code>nums[i] == nums[i-1]</code>，则<strong>跳过</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 先排序，保证相同元素在一起</span></span><br><span class="line">        <span class="built_in">backtrace</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯框架：子集，有重复，不复选。顺序保证非重复性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 一进来就收集结果</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// 添加一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝：相同元素不重复选 (用当前和前一个来判断更好，可以思考为什么)</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrace</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>组合问题和子集问题是等价的</strong>，下面看：<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/description/">40.组合总和II</a></p>
<ul>
<li>给你输入 <code>candidates</code> 和一个目标和 <code>target</code>，从 <code>candidates</code> 中找出中所有和为 <code>target</code> 的组合。<br>
<code>candidates</code> 可能存在重复元素，且其中的每个数字最多只能使用一次。</li>
<li>说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 <code>candidates</code> 中所有和为 <code>target</code> 的子集。</li>
<li>只要额外用一个 <code>trackSum</code> 变量记录回溯路径上的元素和，然后将 <code>base case</code> 改一改即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 先排序：让相同的数字在一起</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 在回溯</span></span><br><span class="line">        <span class="built_in">backtrace</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯框架：子集，有重复，不复选。顺序保证非重复性。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 达到目标才收集结果，同时由于全正数，可以提前结束</span></span><br><span class="line">        <span class="keyword">if</span>(curSum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum == target)  ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            curSum += candidates[i];</span><br><span class="line">            <span class="built_in">backtrace</span>(candidates, target, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            curSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5、排列（元素有重不可复选）">5、排列（元素有重不可复选）</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/description/">47.全排列II</a></p>
<ul>
<li>给你输入一个可包含重复数字的序列 <code>nums</code>，请你写一个算法，返回所有可能的全排列。</li>
<li>比如输入 <code>nums = [1,2,2]</code>，函数返回：<br>
<code>[ [1,2,2],[2,1,2],[2,2,1] ]</code></li>
</ul>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 防复选</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrace</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯框架：排列，有重复，不复选。used保证不复选。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 防复选</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 剪枝：相同元素，一定是前面已经入path，这里才能接第二个</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !used[i<span class="number">-1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtrace</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>比如 <code>[1,2,2']</code> 和 <code>[1,2',2]</code> 应该只被算作同一个排列，但被算作了两个不同的排列。<br>
所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？<br>
答案是，<strong>保证相同元素在排列中的相对位置保持不变</strong>。</li>
<li>如果 <code>nums = [1,2,2',2'']</code>，我只要保证重复元素 <code>2</code> 的相对位置固定，比如说 <code>2 -&gt; 2' -&gt; 2''</code>，也可以得到无重复的全排列结果。仔细思考，应该很容易明白其中的原理：<br>
<strong>标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的</strong>；<br>
<strong>而如果固定相同元素形成的序列顺序，当然就避免了重复</strong>。</li>
<li>那么反映到代码上，你注意看这个剪枝逻辑：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="comment">// 如果前面的相邻相等元素没有用过，则跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择 nums[i]</span></span><br></pre></td></tr></table></figure>
<p><strong>当出现重复元素时，比如输入 <code>nums = [1,2,2',2'']</code>，<code>2'</code> 只有在 <code>2</code> 已经被使用的情况下才会被选择，同理，<code>2''</code> 只有在 <code>2'</code> 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定</strong>。</p>
<blockquote>
<p>这里拓展一下，如果你把上述剪枝逻辑中的 <code>!used[i - 1]</code> 改成 <code>used[i - 1]</code>，其实也可以通过所有测试用例，但效率会有所下降，这是为什么呢？之所以这样修改不会产生错误，是因为这种写法相当于维护了 <code>2'' -&gt; 2' -&gt; 2</code> 的相对顺序，最终也可以实现去重的效果。<br>
但为什么这样写效率会下降呢？因为这个写法剪掉的树枝不够多。<br>
比如输入 <code>nums = [2,2',2'']</code>，产生的回溯树如下：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/hiusu-pl2-1.jpeg" alt="回溯树"><br>
如果用绿色树枝代表 <code>backtrack</code> 函数遍历过的路径，红色树枝代表剪枝逻辑的触发，那么 <code>!used[i - 1]</code> 这种剪枝逻辑得到的回溯树长这样：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-pl2-2.jpeg" alt="回溯树"><br>
而 <code>used[i - 1]</code> 这种剪枝逻辑得到的回溯树如下：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/hiusu-pl2-3.jpeg" alt="回溯树"></p>
</blockquote>
<p>排列去重，也有读者提出别的剪枝思路：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 防复选</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        used.<span class="built_in">assign</span>(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrace</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯框架：排列，有重复，不复选。used保证不复选。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个</span></span><br><span class="line">        <span class="type">int</span> preNum = <span class="number">666</span>;   <span class="comment">// 本层刚刚的前一个选择。题目有效是-10 ~ 10</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 防复选</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 剪枝：相同情况不重复做</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == preNum)  <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            preNum = nums[i];   <span class="comment">// 记录本层前一次选的</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">backtrace</span>(nums);</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-pl2-4.jpeg" alt="回溯树"></p>
<h3 id="6、子集-组合（元素无重可复选）">6、子集/组合（元素无重可复选）</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/description/">39.组合总和</a></p>
<ul>
<li>给你一个无重复元素的整数数组 <code>candidates</code> 和一个目标和 <code>target</code>，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有组合。<code>candidates</code> 中的每个数字可以无限制重复被选取。</li>
<li>输入 <code>candidates = [1,2,3]</code>, <code>target = 3</code>，算法应该返回：<br>
<code>[ [1,1,1],[1,2],[3] ]</code></li>
</ul>
<blockquote>
<p>想解决这种类型的问题，也得回到回溯树上，我们不妨先思考思考，标准的子集/组合问题是如何保证不重复使用元素的？<br>
答案在于 <code>backtrack</code> 递归时输入的参数 <code>start</code>。</p>
</blockquote>
<ul>
<li>这个 <code>i</code> 从 <code>start</code> 开始，那么下一层回溯树就是从 <code>start + 1</code> 开始，从而保证 <code>nums[start]</code> 这个元素不会被重复使用：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/huisu-zhzj.jpeg" alt="回溯树"></li>
<li>那么反过来，如果我想让每个元素被重复使用，我只要把 <code>i + 1</code> 改成 <code>i</code> 即可，这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/hiusu-zjzh3-1.jpeg" alt="回溯树"><br>
当然，这样<strong>这棵回溯树会永远生长下去</strong>，所以我们的递归函数需要设置合适的 <code>base case</code> 以结束算法，即路径和大于 <code>target</code> 时就没必要再遍历下去了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 排序，是为了可以提前结束（而且这里因为回溯树会一直生长，必须提前结束）</span></span><br><span class="line">        <span class="comment">// 更正：不必，组合问题，是会遍历所有可能的，并不需要排序。前面题排序是为了去重</span></span><br><span class="line">        <span class="comment">// sort(candidates.begin(), candidates.end());</span></span><br><span class="line">        <span class="built_in">backtrace</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯框架：组合，无重复，可复选。顺序保证复用正确。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(curSum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum == target)  ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            curSum += candidates[i];</span><br><span class="line">            <span class="built_in">backtrace</span>(candidates, target, i);   <span class="comment">// 把 i+1 改为 i</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            curSum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7、排列（元素无重可复选）">7、排列（元素无重可复选）</h3>
<p>参考：力扣上没有题目<strong>直接</strong>考察这个场景，可以用<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46.全排列</a>来自己测试输入输出。</p>
<ul>
<li>我们不妨先想一下，<code>nums</code> 数组中的元素无重复且可复选的情况下，会有哪些排列？</li>
<li>比如输入 <code>nums = [1,2,3]</code>，那么这种条件下的全排列共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>3</mn><mn>3</mn></msup><mo>=</mo><mn>27</mn></mrow><annotation encoding="application/x-tex">3^3 = 27</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">27</span></span></span></span> 种：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],</span><br><span class="line">  [2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],</span><br><span class="line">  [3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>标准的全排列算法利用 <code>used</code> 数组进行剪枝，避免重复使用同一个元素。<br>
如果允许重复使用元素的话，<strong>直接放飞自我</strong>，去除所有 <code>used</code> 数组的剪枝逻辑就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 防复选</span></span><br><span class="line">    <span class="comment">// vector&lt;bool&gt; used;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// used.assign(nums.size(), false);</span></span><br><span class="line">        <span class="built_in">backtrace</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 框架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 到达叶节点才收集结果</span></span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个新元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// if(used[i])  continue;</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// used[i] = true;</span></span><br><span class="line">            <span class="built_in">backtrace</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">// used[i] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8、最后总结">8、最后总结</h3>
<table>
<thead>
<tr>
<th>题型</th>
<th>重复说明</th>
<th>是否要sort</th>
<th>保证非重复性的关键点</th>
<th>收集结果的时机</th>
<th>收集位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>子集</td>
<td>无重复，不复选</td>
<td>No</td>
<td>按顺序控制下一层 <code>start=i+1</code></td>
<td>每一个节点都收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>组合</td>
<td>无重复，不复选</td>
<td>No</td>
<td>按顺序控制下一层 <code>start=i+1</code></td>
<td>达到k大小的节点收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>排列</td>
<td>无重复，不复选</td>
<td>No</td>
<td>使用 <code>used</code> 记录防复用</td>
<td>到达叶子节点（n大小）才收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>子集/组合</td>
<td>有重复，不复选</td>
<td>Yes</td>
<td>按顺序控制下一层<code>start=i+1</code> + 相同元素排一起</td>
<td>达到题目要求的节点才收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>排列</td>
<td>有重复，不复选</td>
<td>Yes</td>
<td>使用 <code>used</code> 记录防复用 + 相同元素排一起</td>
<td>到达叶子节点(n 大小)才收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>子集/组合</td>
<td>无重复，可复选</td>
<td>No</td>
<td>改 <code>start = i</code> 即可复用，注意控制结束</td>
<td>达到题目要求的节点才收集</td>
<td>前序位置</td>
</tr>
<tr>
<td>排列</td>
<td>无重复，可复选</td>
<td>No</td>
<td>不用<code>used</code> 即可，放飞自我</td>
<td>到达叶子节点(n大小)才收集</td>
<td>前序位置</td>
</tr>
</tbody>
</table>
<p><strong>形式一、元素无重不可复选</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合/子集问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(meet the conditions)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// return ; // 也可能不需要</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>形式二、元素有重不可复选</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 组合/子集问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(meet the conditions)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// return ; // 也可能不需要</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，跳过值相同的相邻树枝</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 排列问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (used[i])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, used);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>形式三、元素无重可复选</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合/子集问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(meet the conditions)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// return ; // 也可能不需要</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯算法标准框架</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意参数</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列问题回溯算法框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集节点结果</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtrack</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要从树的角度思考，这些问题<strong>看似复杂多变，实则改改 <code>base case</code> 就能解决</strong>。</p>
<blockquote>
<p>后面，还会在<a target="_blank" rel="noopener" href="https://labuladong.online/algo/practice-in-action/two-views-of-backtrack/">球盒模型：回溯算法穷举的两种视角</a> 中进一步解说回溯。</p>
</blockquote>
<h2 id="十一-贪心算法">(十一) 贪心算法</h2>
<p>举个简单的例子，就能直观的展现贪心算法了。</p>
<ul>
<li>比方说现在有两种钞票，面额分为为 1 元和 100 元，每种钞票的数量无限，但现在你只能选择 10 张，请问你应该如何选择，才能使得总金额最大？</li>
<li>那你肯定会说，这还用问么？肯定是 10 张全拿 100 元的钞票，共计 1000 元，这就是最优策略，但凡犹豫一秒就是傻瓜。</li>
<li>你这么说，也对，也不对。说你对，因为这确实是最优解法，没毛病。说你不对，是因为这个解法暴露的是你只想捞钱的本质 (¬‿¬) ，跳过了算法的产生、优化过程，不符合计算机思维。</li>
<li>那计算机就要提问了，<strong>一切算法的本质是穷举</strong>，现在你还没有穷举出所有可能的解法，凭什么说这就是最优解呢？按照算法思维，这个问题的本质是做 10 次选择，每次选择有两种可能，分别是 1 元和 100 元，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span> 种可能的选择。所以你心里首先应该出现一棵高度为 10 的二叉树来穷举所有可行解，遍历这些可行解，然后可以得到最优解。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：做 n 次选择，返回可以获得的最大金额</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这次选择 1 元，然后递归求解剩下的 n - 1 次选择的最大值</span></span><br><span class="line">    <span class="type">int</span> result1 = <span class="number">1</span> + <span class="built_in">findMax</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这次选择 100 元，然后递归求解剩下的 n - 1 次选择的最大值</span></span><br><span class="line">    <span class="type">int</span> result2 = <span class="number">100</span> + <span class="built_in">findMax</span>(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回两种选择中的最大值</span></span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">max</span>(result1, result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findMax(n - 1)</code> 的值肯定都一样，那么 <code>100 + findMax(n - 1)</code> 必然大于 <code>1 + findMax(n - 1)</code>，因此可以进行优化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化一、没必要对两种选择进行比较了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">100</span> + <span class="built_in">findMax</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化二、递归改为迭代</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化三、直接计算结果就行了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是贪心算法，复杂度从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 优化到了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，堪称离谱。</p>
<h3 id="1、贪心选择性质">1、贪心选择性质</h3>
<ul>
<li>作为对比，我们稍微改一改题目：<br>
现在有两种钞票，面额分别为 1 元和 100 元，每种钞票的数量无限。现在给你一个目标金额 <code>amount</code>，请问你最少需要多少张钞票才能凑出这个金额？<br>
这道题其实就是 动态规划解题套路框架 中讲解的凑零钱问题。</li>
<li>为了方便讲解，本文开头的最大金额问题我们称为「问题一」，这里的最少钞票数量问题我们称为「问题二」。</li>
<li>我们是如何解决问题二的？首先也是抽象出递归树，写出指数级别的暴力穷举算法，然后发现了重叠子问题，于是用备忘录消除重叠子问题，这就是标准的动态规划算法的求解过程，不能再优化了。</li>
<li>所以，这两个问题到底有什么区别？区别在于，<strong>问题二没有贪心选择性质，而问题一有</strong>。</li>
</ul>
<blockquote>
<p><strong>贪心选择性质</strong>就是说能够通过局部最优解<strong>直接</strong>推导出全局最优解。</p>
</blockquote>
<p>对于问题一，局部最优解就是每次都选择 100 元，因为 100 &gt; 1；对于问题二，局部最优解也是每次都选择 100 元，因为每张面额尽可能大，所需的钞票数量就能尽可能少。但区别在于，<strong>问题一中每一次选择的局部最优解组合起来就是全局最优解</strong>，<strong>而问题二中不是</strong>。<br>
比方说目标金额 amount = 3，虽然每次选择 100 元是局部最优解，但想凑出 3 元，只能选择 3 张 1 元，局部最优解不一定能构成全局最优解。对于问题二的场景，不符合贪心选择性质，所以不能用贪心算法，只能穷举所有可行解，才能计算出最优解。</p>
<blockquote>
<p><strong>贪心选择性质 vs 最优子结构</strong></p>
<ul>
<li>动态规划：问题必须要有「最优子结构」性质。</li>
<li>贪心算法：问题必须要有「贪心选择」性质。<br>
最优子结构的意思是说，现在我已经把<strong>所有子问题的最优解</strong>都求出来了，然后我可以<strong>基于这些子问题的最优解推导出原问题的最优解</strong>。<br>
贪心选择性质的意思是说，我只需要进行<strong>一些局部最优</strong>的选择策略，就能直接知道哪个子问题的解是最优的了，且这个局部最优解可以推导出原问题的最优解。此时此刻我就能知道，<strong>不需要等到所有子问题的解算出来才知道</strong>。</li>
<li>所以贪心算法的效率一般都比较高，因为它不需要遍历完整的解空间。</li>
</ul>
</blockquote>
<h3 id="2、例题实战">2、例题实战</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏</a></p>
<ul>
<li>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>
判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</li>
<li>
<p>输入：<code>nums = [2,3,1,1,4]</code><br>
输出：<code>true</code><br>
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
</li>
<li>
<p>注意题目说 <code>nums[i]</code> 表示可以跳跃的最大长度，不是固定长度。假设 <code>nums[i] = 3</code>，意味着你可以在索引 <code>i</code> 往前跳 <code>1</code> 步、<code>2</code> 步或 <code>3</code> 步。</p>
</li>
<li>
<p>我们先思考暴力穷举解法吧，如何穷举所有可能的跳跃路径？你心里的那棵多叉树画出来了没有？假设 <code>N</code> 为 <code>nums</code> 的长度，这道题相当于做 <code>N</code> 次选择，每次选择有 <code>nums[i]</code> 种选项，想要穷举所有的跳跃路径，就是一棵高度为 <code>N</code> 的多叉树，每个节点有 <code>nums[i]</code> 个子节点。</p>
</li>
<li>
<p>这个算法本质上还是穷举了所有可能的选择，可以走动态规划那一套流程进行优化，但是这里我们先不急，可以再仔细想想，这个问题有没有贪心选择性质？</p>
</li>
<li>
<p>这里面有个细节，比方说你现在站在 <code>nums[i] = 3</code> 的位置，你可以跳到 <code>i+1</code>, <code>i+2</code>, <code>i+3</code> 三个位置，此时你真的需要分别跳过去，然后递归求解子问题 <code>dp(i+1)</code>, <code>dp(i+2)</code>, <code>dp(i+3)</code>，最后通过子问题的答案来决定 <code>dp(i)</code> 的结果吗？<br>
其实不用的，<code>i+1</code>, <code>i+2</code>, <code>i+3</code> 三个候选项，它们谁能走得最远，你就选谁，准没错。<br>
具体来说:</p>
<ol>
<li><code>i+1</code> 能走到的最远距离是 <code>i+1+nums[i+1]</code></li>
<li><code>i+2</code> 能走到的最远距离是 <code>i+2+nums[i+2]</code></li>
<li><code>i+3</code> 能走到的最远距离是 <code>i+3+nums[i+3]</code><br>
你看看谁最大，就选谁。</li>
</ol>
</li>
<li>
<p>这就是<strong>贪心选择</strong>性质，通过<strong>局部最优解就能推导全局最优解</strong>，<strong>不需要等到递归计算出所有子问题的答案才能做选择</strong>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接遍历所有元素，更新最远即可</span></span><br><span class="line">        <span class="type">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=farest &amp;&amp; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest, i+nums[i]);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> farthest &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏II</a></p>
<ul>
<li>给定一个长度为 <code>n</code> 的 <code>0</code> 索引整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。<br>
每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:<br>
<code>0 &lt;= j &lt;= nums[i]</code><br>
<code>i + j &lt; n</code><br>
返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</li>
<li>输入: <code>nums = [2,3,1,1,4]</code><br>
输出: <code>2</code><br>
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li>
</ul>
<p>暴力穷举肯定也是可以做的，就类似上面的那道题，只不过修改一下 dp 数组的定义，返回值从 boolean 改成 int，表示最少需要跳跃的次数就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目问的就是 dp(nums, 0) 的结果，base case 就是当 p 超过最后一格时，不需要跳跃</span></span><br><span class="line"><span class="keyword">if</span> (p &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态规划做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 备忘录都初始化为 n，相当于 INT_MAX</span></span><br><span class="line">        <span class="comment">// 因为从 0 跳到 n - 1 最多 n - 1 步</span></span><br><span class="line">        memo = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子问题已经计算过</span></span><br><span class="line">        <span class="keyword">if</span> (memo[p] != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> steps = nums[p];</span><br><span class="line">        <span class="comment">// 你可以选择跳 1 步，2 步...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">            <span class="comment">// 穷举每一个选择</span></span><br><span class="line">            <span class="comment">// 计算每一个子问题的结果</span></span><br><span class="line">            <span class="type">int</span> subProblem = <span class="built_in">dp</span>(nums, p + i);</span><br><span class="line">            <span class="comment">// 取其中最小的作为最终结果</span></span><br><span class="line">            memo[p] = <span class="built_in">min</span>(memo[p], subProblem + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法已经通过备忘录消除了冗余计算，时间复杂度是 <code>递归深度 x 每次递归需要的时间复杂度</code>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在 LeetCode 上是无法通过所有用例的，会超时。</p>
<p>所以进一步的优化就只能是贪心算法了，我们要仔细思考是否存在贪心选择性质，是否能够通过局部最优解推导全局最优解，避免全量穷举所有的可能解。</p>
<p>和上面的题目是一样的优化思路：我们真的需要递归地计算出每一个子问题的结果，然后求最值吗？其实不需要。</p>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tanxin-2.jpg" alt="贪心"></p>
<p>上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？</p>
<p>肯定是跳到索引 2 位置的，为什么？因为 2 的选择很多啊，你 3 能去的地方，我 2 都可以去。</p>
<p><strong>这就是贪心选择性质，我们不需要真的递归穷举出所有选择的具体结果来比较求最值，而只需要每次选择那个最有潜力的局部最优解，最终就能得到全局最优解</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>, farthest = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;   <span class="comment">// 思考是i&lt;n-1</span></span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                steps++;            <span class="comment">// 这一步是准备跳了，实际上还没跳（但知道一定会跳的）</span></span><br><span class="line">                end = farthest;     <span class="comment">// 这里更新的最远，实际上是这一步的可跳范围，还没跳出去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是我自己的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cur+nums[cur] &amp;&amp; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 当前已经可以到了，那就直接到，不必探索最优待选，反正都是走一步了</span></span><br><span class="line">            <span class="keyword">if</span>(cur+nums[cur] &gt;= n<span class="number">-1</span>)&#123;</span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 碰到更优的，则更新待选</span></span><br><span class="line">            best = i+nums[i] &gt; best+nums[best] ? i : best;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抵达边界，开始真的选了一个走去</span></span><br><span class="line">            <span class="keyword">if</span>(i == cur+nums[cur])&#123;</span><br><span class="line">                cur = best;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，可以通过所有测试用例。</p>
<h3 id="3、贪心算法的解题步骤">3、贪心算法的解题步骤</h3>
<ul>
<li>贪心算法的关键在于问题是否具备<strong>贪心选择性质</strong>，所以只能具体问题具体分析，<strong>没办法抽象出一套固定的算法模板或者思维模式</strong>，判断一道题是否是贪心算法。</li>
<li>经验是，<strong>没必要刻意地识别一道题是否具备贪心选择性质</strong>。你只需时刻记住，<strong>算法的本质是穷举</strong>，遇到任何题目都要<strong>先想暴力穷举</strong>思路，穷举的过程中如果<strong>存在冗余计算</strong>，就用备忘录<strong>优化</strong>掉。</li>
<li>如果提交结果<strong>还是超时</strong>，<strong>那就说明不需要穷举所有的解空间就能求出最优解，这种情况下肯定需要用到贪心算法</strong>。你可以仔细观察题目，是否可以提前排除掉一些不合理的选择，是否可以<strong>直接</strong>通过局部最优解推导全局最优解。</li>
</ul>
<h2 id="十二-分治算法">(十二) 分治算法</h2>
<p>分治思想和分治算法不一样。</p>
<h3 id="1、分治思想">1、分治思想</h3>
<ul>
<li>广义的分治思想是一个宽泛的概念，本站教程中也经常称之为「<strong>分解问题的思路</strong>」。</li>
<li>分治思想就是把一个问题分解成若干个子问题，然后分别解决这些子问题，最后合并子问题的解得到原问题的解，这种思想广泛存在于递归算法中。<br>
例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：输入一棵二叉树的根节点，返回这棵树的节点总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先算出左右子树的节点个数</span></span><br><span class="line">    <span class="type">int</span> leftCount = <span class="built_in">count</span>(root.left);</span><br><span class="line">    <span class="type">int</span> rightCount = <span class="built_in">count</span>(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树的节点个数加上自己，就是整棵树的节点个数</span></span><br><span class="line">    <span class="keyword">return</span> leftCount + rightCount + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态规划算法 属不属于分治思想？<br>
也属于，因为所有动态规划算法都是把大问题分解成了结构相同规模更小的子问题，通过子问题的最优解合并得到原问题的最优解，只不过这个过程中有一些特殊的优化操作罢了。</li>
<li>前面讲过，递归算法只有两种思路，一种是遍历的思路，另一种是分解问题的思路（分治思想）。<br>
遍历思路的典型代表就是 回溯算法，那么除了回溯算法之外，其他递归算法都可以归为分解问题的思路（分治思想）。</li>
<li>「<strong>分治思想」占据了递归算法的半壁江山</strong>，那么当我们说「分治算法」的时候，具体是指什么呢？是不是可以说上面列举的这些递归算法都是「分治算法」呢？其实不是的。</li>
</ul>
<h3 id="2、分治算法">2、分治算法</h3>
<p>狭义的分治算法也是运用分治思想的递归算法，但它有一个特征，是上面列举的算法所不具备的：<br>
<strong>把问题分解后进行求解，相比于不分解直接求解，时间复杂度更低</strong>。<br>
符合这个特征的算法，我们才称之为「<strong>分治算法</strong>」。</p>
<p>上面列举的算法，它们本身就只能分解求解，不存在「直接求解」的解法，所以只说它们运用了分治思想，不说它们是分治算法。</p>
<ul>
<li>比如 <strong>桶排序算法</strong>，桶排序的思路是把待排序数组分成若干个桶，然后对每个桶分别进行插入排序，最后把所有有序桶合并，这样时间复杂度能降到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br>
直接用 <strong>插入排序</strong> 的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，而分解后再用插入排序，总的时间复杂度就能降到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这种才算分治算法。</li>
</ul>
<p><strong>那么这里面是什么道理，为什么分而治之的复杂度更低呢</strong>？如果把所有问题都分而治之，是不是都能得到更低的复杂度呢？<br>
下面就来详细地对比探究一下，什么情况下分治思想能降低复杂度，什么时候不可以，以及其中的原理所在。</p>
<h3 id="3、无效的分治">3、无效的分治</h3>
<p>理论上讲，很多算法都可以用分解问题的思路改写成递归算法，但大部分情况下这种改写是无意义的。</p>
<ul>
<li>求一个数组的和，这个算法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全可以用分解问题的思路把这个问题改写成递归算法：<br>
你问我所有元素的和，我就把这个问题分解成第一个元素和剩余元素的和，这就是分治思想呀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：返回 nums[start..] 的元素和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nums[start..] 的元素和可以分解成第一个元素和剩余元素的和</span></span><br><span class="line">    <span class="keyword">return</span> nums[start] + <span class="built_in">getSum2</span>(nums, start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归树的形态类似一条链表，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，这是因为每次递归调用都是 <code>start + 1</code>，所以递归树退化成了链表。<br>
这个算法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br>
可以看到，这个算法的时间复杂度并没有比迭代算法更低，而且还多了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间复杂度。<br>
那改一下，改成中间劈一半？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum3</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算 nums[start..mid] 的和</span></span><br><span class="line">    <span class="type">int</span> leftSum = <span class="built_in">getSum3</span>(nums, start, mid);</span><br><span class="line">    <span class="comment">// 计算 nums[mid+1..end] 的和</span></span><br><span class="line">    <span class="type">int</span> rightSum = <span class="built_in">getSum3</span>(nums, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并得到 nums[start..end] 的和</span></span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSum2</code> 算法的递归树退化成了链表，堆栈（树高）的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>；而这个 <code>getSum3</code> 算法从中间二分，递归树就是一个较为平衡的二叉树，所以堆栈（树高）的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。<br>
时间复杂度还是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因为递归调用的次数（二叉树节点数）是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每次递归调用只做几次加减法，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>综上，这两种分治算法改写都属于无效的分治，没有降低时间复杂度，反而由于递归而增加了空间复杂度。<br>
这也是预期之内的事情，数组元素求和，时间复杂度在怎么优化都不可能低于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，因为你至少得遍历一遍所有元素对吧，这么遍历一次就要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间了，怎么可能优化呢？</p>
<ol>
<li>
<p><strong>分治的思想是广泛存在的</strong>，几乎所有算法都可以改写成递归分治的形式。</p>
</li>
<li>
<p><strong>分治思想不等于高效</strong>。不要听到 XX 算法就觉得高大上，很多时候，改写成分治解法并不能带来什么实际的好处，甚至可能增加空间复杂度，因为递归调用需要堆栈空间。</p>
</li>
</ol>
<p>3、<strong>用二分的方式进行分治可以将递归树的深度从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，确实有优化效果</strong>。对于上面这个元素求和的例子，无论怎么分治都不如原解法高效，但可以看出二分的分治方式是确实有助于减少递归树的高度。</p>
<h3 id="4、有效的分治">4、有效的分治</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23.合并 K 个升序链表</a></p>
<ul>
<li>给你一个链表数组，每个链表都已经按升序排列。<br>
请你将所有链表合并到一个升序链表中，返回合并后的链表。</li>
<li>示例 1：<br>
输入：<code>lists = [[1,4,5],[1,3,4],[2,6]]</code><br>
输出：<code>[1,1,2,3,4,4,5,6]</code></li>
</ul>
<p>在 单链表双指针技巧汇总 中，我介绍的解法是利用 <strong>优先级队列</strong> 这种数据结构对链表节点进行动态排序，这种解法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，其中 <code>k</code> 代表链表的条数，<code>N</code> 代表 <code>k</code> 条链表节点的总数，在本文中，我们不再依赖额外的数据结构，而是直接用分治算法解决这个问题，时间复杂度依然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<p>先看简单的。<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21.合并 2 个升序列表</a></p>
<ul>
<li>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</li>
<li>输入：<code>l1 = [1,2,4], l2 = [1,3,4]</code><br>
输出：<code>[1,1,2,3,4,4]</code><br>
这个问题解答过，如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span>, *p </span>= &amp;dummy;</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">            <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mn>1</mn><mo>+</mo><mi>l</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(l1+l2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。</p>
<p>下面我们来思考如何合并 k 个有序链表。<br>
先想一个暴力解吧，运用上面的这个 <code>mergeTwoLists</code> 函数把 <code>k</code> 个链表两两合并，都合并到第一个链表上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 k 个有序链表都合并到 lists[0] 上</span></span><br><span class="line">    ListNode l0 = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">        l0 = <span class="built_in">mergeTwoLists</span>(l0, lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，链表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">l_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会被遍历 <code>k−1</code> 次，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">l_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会被遍历 <code>k−2</code> 次，以此类推，最后一条链表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">l_{k−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9028em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 会被遍历 <code>1</code> 次。<br>
看到冗余计算了吗？<strong>越靠前的链表被重复遍历的次数越多，这就是这个算法低效的原因</strong>。我们只要减少这种重复，就能提高算法的效率。<br>
刚刚这个，就等效于下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：合并 lists[start..] 为一个有序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">mergeKLists2</span><span class="params">(ListNode[] lists, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == lists.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并 lists[start + 1..] 为一个有序链表</span></span><br><span class="line">    ListNode subProblem = <span class="built_in">mergeKLists2</span>(lists, start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 lists[start] 和 subProblem，就得到了 lists[start..] 的有序链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[start], subProblem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就和前面的 <code>getSum2</code> 很像。递归树的形态类似一个单链表，高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。<br>
不难发现<strong>重复的次数取决于树高</strong>，上面这个算法的递归树很不平衡，导致递归树退化成链表，树高变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。<br>
<strong>如果能让递归树尽可能地平衡，就能减小树高，进而减少链表的重复遍历次数，提高算法的效率</strong>。<br>
如何让递归树平衡呢？就类似上面 <code>getSum3</code> 函数的思路，把链表从中间分成两部分，分别递归合并为有两个序链表，最后再将这两部分合并成一个有序链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：合并 lists[start..end] 为一个有序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">mergeKLists3</span><span class="params">(ListNode[] lists, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 合并左半边 lists[start..mid] 为一个有序链表</span></span><br><span class="line">    ListNode left = <span class="built_in">mergeKLists3</span>(lists, start, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并右半边 lists[mid+1..end] 为一个有序链表</span></span><br><span class="line">    ListNode right = <span class="built_in">mergeKLists3</span>(lists, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并左右两个有序链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度相当于是把 <code>k</code> 条链表分别遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 次。那么假设 <code>k</code> 条链表的元素总数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，该算法的时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，和 单链表双指针技巧汇总 中介绍的优先级队列解法相同。<br>
再来看空间复杂度，该算法的空间复杂度只有递归树堆栈的开销，也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，要优于优先级队列解法的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="5、总结">5、总结</h3>
<ol>
<li>分治思想在递归算法中是广泛存在的，甚至一些非递归算法，都可以强行改写成分治递归的形式，但并不是所有算法都能用分治思想提升效率。</li>
<li><strong>把递归算法抽象成递归树，如果递归树节点的时间复杂度和树的深度相关，那么使用分治思想对问题进行二分，就可以使递归树尽可能平衡，进而优化总的时间复杂度</strong>。</li>
<li>反之，如果递归树节点的时间复杂度和树的深度无关，那么使用分治思想就没有意义，反而可能引入额外的空间复杂度。</li>
</ol>
<blockquote>
<ul>
<li><code>getSum</code> 函数即便改为递归形式，每个递归节点做的事情无非就是一些加减运算，所以递归节点的时间复杂度总是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，和树的深度无关，所以分治思想不起作用。</li>
<li>而 <code>mergeKLists</code> 函数中，每个递归节点都需要合并两个链表，这两个链表是子节点返回的，其长度和递归树的高度相关，所以使用分治思想可以优化时间复杂度。</li>
</ul>
</blockquote>
<h2 id="十三-时空复杂度分析">(十三) 时空复杂度分析</h2>
<p>本文会篇幅较长，会涵盖如下几点：</p>
<p>1、利用时间复杂度反推解题思路，减少试错时间。<br>
2、时间都去哪儿了？哪些常见的编码失误会导致算法超时。<br>
3、Big O 表示法的几个基本特点。<br>
4、非递归算法中的时间复杂度分析。<br>
5、数据结构 API 的效率衡量方法（摊还分析）。<br>
6、递归算法的时间/空间复杂度的分析方法，这部分是重点，我会用动态规划和回溯算法举例。</p>
<h3 id="1、复杂度反推解题">1、复杂度反推解题</h3>
<ul>
<li><strong>你应该在开始写代码之前就留意题目给的数据规模</strong>，因为复杂度分析可以避免你在错误的思路上浪费时间，有时候它甚至可以直接告诉你这道题用什么算法。</li>
<li>举例来说吧，比如一个题目给你输入一个数组，其长度能够达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 这个量级，那么我们肯定可以知道这道题的时间复杂度大概要小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，得优化成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 才行。因为如果你写的算法是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的，最大的复杂度会达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">10^12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span> 这个量级，在大部分判题系统上都是跑不过去的。<br>
为了把复杂度控制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们的选择范围就缩小了，可能符合条件的做法是：<strong>对数组进行排序处理、前缀和、双指针、一维 dp 等等</strong>，从这些思路切入就比较靠谱。<br>
像<strong>嵌套 for 循环、二维 dp、回溯算法</strong>这些思路，基本可以直接排除掉了。</li>
<li>举个更直接的例子，如果你发现题目给的数据规模很小，比如数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span> 这样的，那么我们可以断定这道题大概率要用<strong>暴力穷举</strong>算法。<br>
因为判题平台肯定是尽可能扩大数据规模难为你，它一反常态给这么小的数据规模，肯定是因为<strong>最优解就是指数/阶乘级别</strong>的复杂度。你放心用<br>
<strong>回溯算法</strong> 招呼它就行了，不用想别的算法了。</li>
</ul>
<h3 id="2、编码失误导致异常">2、编码失误导致异常</h3>
<ul>
<li>这些错误会产生预期之外的时间消耗，拖慢你的算法运行，甚至导致超时。</li>
</ul>
<table>
<thead>
<tr>
<th>编码失误</th>
<th>原因</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用了标准输出</td>
<td>标准输出属于 I/O 操作，会很大程度上拖慢你的算法代码运行</td>
<td>输出语句注释掉</td>
</tr>
<tr>
<td>错误地传参数</td>
<td>尤其是函数是递归函数时，错误地传值几乎必然导致超时或超内存</td>
<td>传引用</td>
</tr>
<tr>
<td>接口对象的底层实现不明</td>
<td>Java 会有，C++不用管</td>
<td>自己创建</td>
</tr>
</tbody>
</table>
<h3 id="3、Big-O-表示法">3、Big O 表示法</h3>
<p>Big O 记号的数学定义：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mtext>存在正常量</mtext><mi>c</mi><mtext>和</mtext><msub><mi>n</mi><mn>0</mn></msub><mtext>，使得对所有</mtext><mi>n</mi><mo>≥</mo><msub><mi>n</mi><mn>0</mn></msub><mtext>，有</mtext><mn>0</mn><mo>≤</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">O(g(n)) = \{ f(n): 存在正常量 c 和 n_0，使得对所有 n \geq n_0，有 0 \leq f(n) \leq c*g(n) \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">存在正常量</span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，使得对所有</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，有</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)}</span></span></span></span></span></p>
<p>常用的这个符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span> 其实代表一个<strong>函数的集合</strong>，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 代表着一个由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">g(n) = n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> <strong>派生出来的一个函数集合</strong>。</p>
<ol>
<li>只保留增长速率最快的项，其他的项可以省略。</li>
<li>Big O 记号表示复杂度的「上界」。</li>
</ol>
<h3 id="4、算法分析">4、算法分析</h3>
<ul>
<li>数据结构：一般看平均时间复杂度，而不是最坏时间复杂度。</li>
<li>非递归算法：正常计算即可。</li>
<li>递归算法：
<ol>
<li><code>递归算法的时间复杂度 = 递归树的节点个数 x 每个节点的时间复杂度</code></li>
<li><code>递归算法的空间复杂度 = 递归树的高度 + 算法申请的存储空间</code></li>
</ol>
</li>
</ul>
<h3 id="5、最后总结">5、最后总结</h3>
<ol>
<li>复杂度分析是一种技术工具，我们应该灵活运用这个工具，辅助我们又快又好地写出解法代码。</li>
<li>Big O 标记代表一个函数的集合，用它表示时空复杂度时代表一个上界，所以如果你和别人算的复杂度不一样，可能你们都是对的，只是精确度不同罢了。</li>
<li>时间复杂度的分析不难，关键是你要透彻理解算法到底干了什么事。非递归算法中嵌套循环的复杂度依然可能是线性的；数据结构 API 需要用平均时间复杂度衡量性能；递归算法本质是遍历递归树，时间复杂度取决于递归树中节点的个数（递归次数）和每个节点的复杂度（递归函数本身的复杂度）。</li>
</ol>
<h1>第一章、经典数据结构算法</h1>
<h2 id="一-链表">(一) 链表</h2>
<p>参考题：</p>
<h3 id="1-82-删除排序链表中的重复元素-II">1. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 链表分解思想：分成一条重复的链表，一条独特的链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">101</span>);   <span class="comment">// 题给数据 -100 -- +100</span></span><br><span class="line">        ListNode *dummy2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *p1 = dummy1, *p2 = dummy2;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">// 重复节点</span></span><br><span class="line">            <span class="keyword">if</span>((p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;val == p-&gt;next-&gt;val) || (p-&gt;val == p1-&gt;val))&#123;</span><br><span class="line">                p1-&gt;next = p;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不重复节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p2-&gt;next = p;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意上面的最后一步！！！断开原链表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回不重复链表即可</span></span><br><span class="line">        <span class="keyword">return</span> dummy2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-264-丑数-II">2. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/description/">264. 丑数 II</a></h3>
<p>可以先做附：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-primes/description/">204.计算质数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 素数筛（注意 0/1 既不是素数、也不是合数）</span></span><br><span class="line">    <span class="comment">// 返回小于n的质数数量</span></span><br><span class="line">    <span class="comment">// 请完全背下来！！！！！一点不用改</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">F</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="comment">// F[0] = F[1] = false; // 用不上，而且可能会n&lt;1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除合数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;n; i++)            <span class="comment">// 提前 i*i 计算</span></span><br><span class="line">            <span class="keyword">if</span>(F[i])&#123;                       <span class="comment">// 只有素数才筛选</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i*i; j&lt;n; j+=i)  <span class="comment">// 从 i*i 开始，每次+=i</span></span><br><span class="line">                    F[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;n; i++)  <span class="keyword">if</span>(F[i])  cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 理解为三个链表合并</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ugly</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;   <span class="comment">// 索引</span></span><br><span class="line">        <span class="type">int</span> r2 = <span class="number">1</span>, r3 = <span class="number">1</span>, r5 = <span class="number">1</span>;   <span class="comment">// 下一个计算结果</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 选最小的接上</span></span><br><span class="line">            <span class="type">int</span> minR = <span class="built_in">min</span>(&#123;r2, r3, r5&#125;);</span><br><span class="line">            ugly[p] = minR;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="comment">// 更新被取走的链表的下一个计算结果</span></span><br><span class="line">            <span class="keyword">if</span>(minR == r2)&#123;</span><br><span class="line">                r2 = ugly[p2] * <span class="number">2</span>;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minR == r3)&#123;</span><br><span class="line">                r3 = ugly[p3] * <span class="number">3</span>;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minR == r5)&#123;</span><br><span class="line">                r5 = ugly[p5] * <span class="number">5</span>;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> ugly[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-有序矩阵中第-K-小的元素">3. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/">有序矩阵中第 K 小的元素</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 优先队列，合并多行有序链表，找到第k小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 优先队列</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123; </span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]; </span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：元素值， 元素坐标 x,y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)  minHeap.<span class="built_in">push</span>(&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次插入 k 个即可</span></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 当前第几小的</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; cur = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            ans = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 谁被去掉，换那条的上来(取完了就不用了)</span></span><br><span class="line">            <span class="type">int</span> i = cur[<span class="number">1</span>], j = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; matrix[i].<span class="built_in">size</span>())  minHeap.<span class="built_in">push</span>(&#123;matrix[i][j+<span class="number">1</span>], i, j+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">// 继续</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-查找和最小的-K-对数字">4. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/">查找和最小的 K 对数字</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 相当于有 n1 条 n2 长度的链表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>(), n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 存储内容，是 加和数字 aNum 以及 索引 i1, i2</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; minHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n1; i++)  minHeap.<span class="built_in">push</span>(&#123;nums1[i]+nums2[<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新出 K 个即可</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; cur = minHeap.<span class="built_in">top</span>();</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> i = cur[<span class="number">1</span>], j = cur[<span class="number">2</span>];</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">            <span class="comment">// 推一个新的（没有就不用推了）</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">                minHeap.<span class="built_in">push</span>(&#123;nums1[i]+nums2[j+<span class="number">1</span>], i, j+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">// 继续</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-两数相加">5. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/description/">两数相加</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 || p2)&#123;</span><br><span class="line">            <span class="type">int</span> res = carry;</span><br><span class="line">            <span class="keyword">if</span>(p1)  res += p1-&gt;val, p1 = p1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p2)  res += p2-&gt;val, p2 = p2-&gt;next;</span><br><span class="line"></span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(res % <span class="number">10</span>);</span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            </span><br><span class="line">            carry = res / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">            cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-两数相加-II">6. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/description/">两数相加 II</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 当然可以反转链表，不反转怎么办？—— 栈！</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栈存储，甚至直接存储 int 即可</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk1;</span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">            stk1.<span class="built_in">push</span>(p1-&gt;val);</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk2;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p2)&#123;</span><br><span class="line">            stk2.<span class="built_in">push</span>(p2-&gt;val);</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回到正常思路了</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>() || !stk2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> res = carry;</span><br><span class="line">            <span class="keyword">if</span>(!stk1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> a = stk1.<span class="built_in">top</span>();</span><br><span class="line">                stk1.<span class="built_in">pop</span>();</span><br><span class="line">                res += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stk2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> b = stk2.<span class="built_in">top</span>();</span><br><span class="line">                stk2.<span class="built_in">pop</span>();</span><br><span class="line">                res += b;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push</span>(res % <span class="number">10</span>);</span><br><span class="line">            carry = res / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)  ans.<span class="built_in">push</span>(carry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后存回链表</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!ans.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ListNode *r = <span class="keyword">new</span> <span class="built_in">ListNode</span>(ans.<span class="built_in">top</span>());</span><br><span class="line">            r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            ans.<span class="built_in">pop</span>();</span><br><span class="line">            p-&gt;next = r;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7、方法：花式反转链表">7、方法：花式反转链表</h3>
<ol>
<li>反转整个单链表<br>
参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 反转以 head 为起点的单链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于单链表的结构，至少要用三个指针才能完成迭代反转</span></span><br><span class="line">        <span class="comment">// cur 是当前遍历的节点，pre 是 cur 的前驱结点，nxt 是 cur 的后继结点</span></span><br><span class="line">        ListNode *pre, *cur, *nxt;</span><br><span class="line">        pre = <span class="literal">nullptr</span>; cur = head; nxt = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 逐个结点反转</span></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            <span class="comment">// 更新指针位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            <span class="keyword">if</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                nxt = nxt-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>reverseList(1-&gt;2-&gt;3-&gt;4) = reverseList(2-&gt;3-&gt;4) -&gt; 1</code><br>
这就是「分解问题」的思路，通过递归函数的定义，把原问题分解成若干规模更小、结构相同的子问题，最后通过子问题的答案组装原问题的解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归写法</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 把后续反转，再接上</span></span><br><span class="line">        ListNode *second = head-&gt;next;</span><br><span class="line">        ListNode *last = <span class="built_in">reverseList</span>(second);</span><br><span class="line">        second-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，递归操作链表并不高效。<br>
递归解法和迭代解法相比，时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，但是迭代解法的空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，而递归解法需要堆栈，空间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<ol start="2">
<li>反转链表前 N 个节点</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *pre, *cur, *nxt;</span><br><span class="line">    pre = <span class="literal">nullptr</span>; cur = head; nxt = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">        <span class="keyword">if</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nxt = nxt-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点</span></span><br><span class="line">    head-&gt;next = cur;</span><br><span class="line">    <span class="comment">// 此时的 pre 是反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后驱节点</span></span><br><span class="line">ListNode* successor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">        successor = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverseN</span>(head-&gt;next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>反转链表的一部分<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">92. 反转链表 II</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到第 m 个节点的前驱</span></span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第 m 个节点开始反转</span></span><br><span class="line">        pre-&gt;next = <span class="built_in">reverseN</span>(pre-&gt;next, n - m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pre, *cur, *nxt;</span><br><span class="line">        pre = <span class="literal">nullptr</span>; cur = head; nxt = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            <span class="keyword">if</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                nxt = nxt-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点</span></span><br><span class="line">        head-&gt;next = cur;</span><br><span class="line">        <span class="comment">// 此时的 pre 是反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 后驱节点</span></span><br><span class="line">    ListNode* successor = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line">            successor = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* last = <span class="built_in">reverseN</span>(head-&gt;next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = successor;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>K 个一组反转链表<br>
参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">25. K 个一组翻转链表</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">        ListNode *a, *b;</span><br><span class="line">        a = b = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 不足 k 个，不需要反转了</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">        ListNode *newHead = <span class="built_in">reverseN</span>(a, k);</span><br><span class="line">        <span class="comment">// 此时 b 指向下一组待反转的头结点</span></span><br><span class="line">        <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">        a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上文实现的反转前 N 个节点的函数</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pre, *cur, *nxt;</span><br><span class="line">        pre = <span class="literal">nullptr</span>; cur = head; nxt = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            <span class="keyword">if</span> (nxt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                nxt = nxt-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = cur;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8、方法：回文链表判断">8、方法：回文链表判断</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/description/">234.回文链表</a></p>
<ul>
<li><strong>寻找</strong>回文串的核心思想是从中心向两端扩展</li>
<li><strong>判断</strong>回文串，双指针技巧从两端向中间逼近即可</li>
<li>那么对于回文链表，怎么办？</li>
</ul>
<ol>
<li><strong>思考做法</strong></li>
</ol>
<p><strong>链表兼具递归结构，树结构不过是链表的衍生</strong>。那么，<strong>链表其实也可以有前序遍历和后序遍历</strong>，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="comment">// 中序遍历代码</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历代码</span></span><br><span class="line">    <span class="built_in">traverse</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序打印单链表中的元素值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traverse</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 从左向右移动的指针</span></span><br><span class="line">    ListNode* left;</span><br><span class="line">    <span class="comment">// 从右向左移动的指针</span></span><br><span class="line">    ListNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录链表是否为回文</span></span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        left = head;</span><br><span class="line">        <span class="built_in">traverse</span>(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用递归，走到链表尾部 </span></span><br><span class="line">        <span class="built_in">traverse</span>(right-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置，此时的 right 指针指向链表右侧尾部</span></span><br><span class="line">        <span class="comment">// 所以可以和 left 指针比较，判断是否是回文链表</span></span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = left-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这么做的核心逻辑是什么呢？实际上就是<strong>把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的</strong>，只不过我们利用的是递归函数的堆栈而已。</p>
<ol start="2">
<li><strong>优化空间复杂度</strong><br>
不必要求</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow, *fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        </span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = <span class="built_in">reverse</span>(slow);</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种解法虽然高效，但破坏了输入链表的原始结构，能不能避免这个瑕疵呢？</p>
<p>其实这个问题很好解决，关键在于得到p, q这两个指针位置。只要在函数 return 之前加一段代码即可恢复原先链表顺序：<code>p-&gt;next = reverse(q);</code></p>
<h2 id="二-数组">(二) 数组</h2>
<h3 id="1、双指针的七道题">1、双指针的七道题</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">有序数组去重，原地修改</a>：快慢指针</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/description/">移除val元素，原地修改</a>：快慢指针</li>
<li>滑动窗口，背下框架</li>
<li>二分查找：左右指针</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">两数之和</a>：左右指针</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">反转数组</a>：左右指针</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文串判断</a>：核心子函数是中心向两端扩散的左右指针</li>
</ol>
<blockquote>
<p>只要数组有序，就应该想到双指针技巧。</p>
</blockquote>
<p>全部代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">T1：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// fast 探路，slow 填写</span></span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;val != slow-&gt;val)&#123;</span><br><span class="line">                slow-&gt;next = fast;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意切断</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T5：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="comment">// 完成</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)  <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;; <span class="comment">// 题目索引从1开始</span></span><br><span class="line">            <span class="comment">// 让 sum 小一点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)  right--;</span><br><span class="line">            <span class="comment">// 让 sum 大一点</span></span><br><span class="line">            <span class="keyword">else</span>  left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T6：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> t = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = t;</span><br><span class="line">            left++, right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T7：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 找到以 l, r 为中心的最长子回文串(若l=r，则说明以一个字符为中心)</span></span><br><span class="line">    <span class="function">string <span class="title">palindrome</span><span class="params">(string&amp; s, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 注意越界</span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;s.<span class="built_in">size</span>() &amp;&amp; s[l]==s[r])</span><br><span class="line">            l--, r++;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(l+<span class="number">1</span>, r-l<span class="number">-1</span>);    <span class="comment">// 注意，退出循环时，l,r 都扩大了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// 中心扩散</span></span><br><span class="line">            string s1 = <span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line">            string s2 = <span class="built_in">palindrome</span>(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            ans = s1.<span class="built_in">size</span>() &gt; ans.<span class="built_in">size</span>() ? s1 : ans;</span><br><span class="line">            ans = s2.<span class="built_in">size</span>() &gt; ans.<span class="built_in">size</span>() ? s2 : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、二维数组的花式遍历">2、二维数组的花式遍历</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">反转字符串的单词</a><br>
先反转整个字符串，再反转每个单词。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/description/">旋转数组</a><br>
做法是：顺时针旋转 90 度 = 先沿左上右下对角线镜像，再每行反转即可。<br>
若是逆时针旋转呢？顺时针旋转 90 度 = 先沿右上左下对角线镜像，再每行反转即可。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/">矩阵螺旋遍历</a><br>
本质上就是按照“右、下、左、上”的固定循环顺序遍历，每次碰到边界后，改变方向并更新边界。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/description/">生成螺旋矩阵</a><br>
一样的思路。</li>
</ol>
<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">T1：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        string ans;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; STK;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            <span class="comment">// 吐单词</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!STK.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!STK.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        ans += STK.<span class="built_in">top</span>();</span><br><span class="line">                        STK.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存单词</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                STK.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 末尾还没吐的</span></span><br><span class="line">        <span class="keyword">while</span>(!STK.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans += STK.<span class="built_in">top</span>();</span><br><span class="line">            STK.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去除尾部空格</span></span><br><span class="line">        <span class="keyword">if</span>(ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>)  </span><br><span class="line">            ans = ans.<span class="built_in">substr</span>(<span class="number">0</span>, ans.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 做法：顺时针旋转 90 度 = 先左上右下对角线镜像，再每行反转</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 1. 镜像</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每行反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : matrix)  <span class="built_in">reverse</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 若是逆时针，那么</span></span><br><span class="line"><span class="comment">// 逆时针旋转 90 度 = 先右上左下对角线镜像，再每行反转</span></span><br><span class="line"></span><br><span class="line">T3:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质上，是按照 右、下、左、上 的顺序碰边界后改方向</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 方向 0/1/2/3</span></span><br><span class="line">        <span class="type">int</span> direct = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="type">int</span> minR = <span class="number">0</span>, minC = <span class="number">0</span>, maxR = m<span class="number">-1</span>, maxC = n<span class="number">-1</span>; </span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans.<span class="built_in">size</span>() &lt; m*n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(direct == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; maxC)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    direct = (direct+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                    minR++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(direct == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; maxR)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    direct = (direct+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                    maxC--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(direct == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; minC)</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    direct = (direct+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                    maxR--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(direct == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; minR)</span><br><span class="line">                    i--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    direct = (direct+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                    minC++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T4:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质就是按照 右、下、左、上 遍历，碰到边界后，改方向，更新边界</span></span><br><span class="line">    <span class="comment">// 可以换一种写法</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">M</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= n*n)&#123;</span><br><span class="line">            <span class="comment">// 右(注意 if 里面用的是 M 需要扩展的那行)</span></span><br><span class="line">            <span class="keyword">if</span>(top &lt;= bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">                    M[top][i] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=top; i&lt;=bottom; i++)&#123;</span><br><span class="line">                    M[i][right] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span>(top &lt;= bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=right; i&gt;=left; i--)&#123;</span><br><span class="line">                    M[bottom][i] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=bottom; i&gt;=top; i--)&#123;</span><br><span class="line">                    M[i][left] = num;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束返回</span></span><br><span class="line">        <span class="keyword">return</span> M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、团灭-nSum-问题">3、团灭 nSum 问题</h3>
<blockquote>
<p>这类 nSum 问题就是给你输入一个数组 <code>nums</code> 和一个目标和 <code>target</code>，让你从 <code>nums</code> 选择 <code>n</code> 个数，使得这些数字之和为 <code>target</code>。</p>
</blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">2Sum</a><br>
做法：
<ul>
<li>先排序（若无序）</li>
<li>再左右指针法<br>
泛化一下：<code>nums</code> 中可能有多对儿元素之和都等于 <code>target</code>，请你的算法返回所有和为 <code>target</code> 的元素对儿，其中不能出现重复。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-nSum-2.jpeg" alt="2Sum 问题"></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">3Sum</a><br>
做法：
<ul>
<li>排序</li>
<li>固定第一个数（注意别重复）</li>
<li>第二三个数字，调用 2Sum 完成 target-num1</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">4Sum</a><br>
做法：
<ul>
<li>排序</li>
<li>固定第一个数字（注意别重复）</li>
<li>第二三四个数字，调用 3Sum 完成 target-num1</li>
</ul>
</li>
<li>100Sum? 仍然用<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">4Sum</a>举例<br>
做法：写个通用的函数，实际上就是递归 nSum
<ul>
<li>最外层排序，</li>
<li>然后调用 nSum，执行如下：
<ul>
<li>base case 是 2Sum</li>
<li>其余，固定一个数字，求 n-1 Sum</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>问：如果就是希望返回原下标，而阻碍我们第一步排序，怎么办？<br>
答：存储为 pair 把下标也记着。</li>
<li>问：这不就是子集问题吗？直接回溯法不行吗？<br>
答：可以是可以，一切问题都是穷举。但是，随着 nSum 的 n 提高，回溯法的复杂度飙升。</li>
</ol>
</blockquote>
<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">T1：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无序 2Sum</span></span><br><span class="line">    <span class="comment">// 排序 + 左右指针</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[l] + numbers[r];</span><br><span class="line">            <span class="comment">// 正确</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)</span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;l+<span class="number">1</span>, r+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="comment">// 大了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="comment">// 小了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T1-泛化题型：</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// nums 数组必须有序</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">threeSum</span>(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛化题目 O(NlogN + n^2)</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 第一个数字固定，再寻找 2Sum 即可</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tuples = <span class="built_in">twoSum</span>(nums, i+<span class="number">1</span>, target-nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tuple : tuples)&#123;</span><br><span class="line">                tuple.<span class="built_in">insert</span>(tuple.<span class="built_in">begin</span>(), nums[i]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tuple);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 避免重复(这里只是保证下一个不同，后续for有+1的)</span></span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;n &amp;&amp; nums[i]==nums[i+<span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 2Sum O(N)</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> l = start, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[l] + nums[r];</span><br><span class="line">            <span class="type">int</span> lnum = nums[l], rnum = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;lnum, rnum&#125;);</span><br><span class="line">                <span class="comment">// 防重复</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==lnum)  l++;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==rnum)  r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T3:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 固定第一个</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tuples = <span class="built_in">threeSum</span>(nums, i+<span class="number">1</span>, target-nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tuple : tuples)&#123;</span><br><span class="line">                tuple.<span class="built_in">insert</span>(tuple.<span class="built_in">begin</span>(), nums[i]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tuple);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;n &amp;&amp; nums[i]==nums[i+<span class="number">1</span>])  i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">long</span> target)&#123;    <span class="comment">// 用 long</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tuples = <span class="built_in">twoSum</span>(nums, i+<span class="number">1</span>, target-nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tuple : tuples)&#123;</span><br><span class="line">                tuple.<span class="built_in">insert</span>(tuple.<span class="built_in">begin</span>(), nums[i]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tuple);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;n &amp;&amp; nums[i]==nums[i+<span class="number">1</span>])  i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">long</span> target)&#123;  <span class="comment">// 用 long</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> l = start, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[l] + nums[r];</span><br><span class="line">            <span class="type">int</span> lnum = nums[l], rnum = nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target)  r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)  l++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;lnum, rnum&#125;);</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==lnum)  l++;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==rnum)  r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T4：(这里仍然用 <span class="number">4</span>Sum 举例)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nSumTarget</span>(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 注意：调用这个函数之前一定要先给 nums 排序</span></span><br><span class="line">    <span class="comment">// n 填写想求的是几数之和，start 从哪个索引开始计算（一般填 0），target 填想凑出的目标和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> start, <span class="type">long</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> sz = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 至少是 2Sum，且数组大小不应该小于 n</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 2Sum 是 base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 双指针那一套操作</span></span><br><span class="line">            <span class="type">int</span> lo = start, hi = sz - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">                <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// n &gt; 2 时，递归计算 (n-1)Sum 的结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; sz; i++) &#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sub = <span class="built_in">nSumTarget</span>(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">                <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; arr : sub) &#123;</span><br><span class="line">                    <span class="comment">// (n-1)Sum 加上 nums[i] 就是 nSum</span></span><br><span class="line">                    arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、前缀和数组">4、前缀和数组</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/description/">一维数组：区域和检索</a><br>
由于每次都检索区域和，因此只需要存储前缀和待用即可。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-preSum-1.jpeg" alt="一维前缀和"><br>
做法：存储前缀和（每次检索只需要 O(1)了）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/description/">二维数组：区域和检索</a><br>
也有前缀和办法。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-preSum-2.jpeg" alt="二维前缀和"><br>
做法：如上</li>
</ol>
<blockquote>
<p>注意：<br>
前缀和技巧是利用预计算的 preSum 数组快速计算索引区间内的元素和，但实际上它不仅仅局限于求和，也可以用来快速计算区间乘积等其他场景。</p>
<ol>
<li>第一个局限性：使用前缀和技巧的前提是原数组 nums 不会发生变化。</li>
<li>第二个局限性：前缀和技巧只适用于存在逆运算的场景。（如求最大值，后续会用线段树来解决）</li>
</ol>
</blockquote>
<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">T1：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preSum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        preSum.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            preSum[i+<span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right+<span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 记录 (0,0) - (i,j) 的矩阵和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; preSum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        preSum.<span class="built_in">resize</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                preSum[i+<span class="number">1</span>][j+<span class="number">1</span>] = preSum[i][j+<span class="number">1</span>] + preSum[i+<span class="number">1</span>][j] - preSum[i][j] + matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Ai = row1, Aj = col1;</span><br><span class="line">        <span class="type">int</span> Bi = row2+<span class="number">1</span>, Bj = col2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> preSum[Bi][Bj] + preSum[Ai][Aj] - preSum[Ai][Bj] - preSum[Bi][Aj];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5、差分数组">5、差分数组</h3>
<blockquote>
<p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-diff-1.jpeg" alt="差分数组"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-diff-2.jpeg" alt="区间i-j元素全+3时"></p>
</blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-addition/description/">区间加法</a><br>
做法：构建 Difference 即可
<ul>
<li>初始化</li>
<li>区间变化</li>
<li>返回结果</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/description/">航班预定统计</a><br>
做法：用所有航班号作为 Difference 的 nums 即可，最后返回结果</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-pooling/description/">拼车</a><br>
做法：用所有站点号作为 Difference 的 nums 即可，最后检测在各个站点时的车人数都是不超载的。</li>
</ol>
<blockquote>
<p>问题：</p>
<ol>
<li>第一个问题，想要使用查分数组技巧，必须创建一个长度和区间长度一样的差分数组 diff。</li>
<li>第二个问题，前缀和技巧可以快速进行区间查询，查分数组可以快速进行区间增减。能不能把他俩结合起来，既可以快速进行区间增减，又可以随时进行区间查询？<br>
这两个问题是处理区间问题的常见问题。<br>
终极答案是 <strong>线段树</strong> 这种数据结构，它可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度内完成任意长度的区间增减和区间查询操作</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">T1：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nums 初始化为全 0</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 构造差分解法</span></span><br><span class="line">        <span class="function">Difference <span class="title">df</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; update : updates) &#123;</span><br><span class="line">            <span class="type">int</span> i = update[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> j = update[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> val = update[<span class="number">2</span>];</span><br><span class="line">            df.<span class="built_in">increment</span>(i, j, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> df.<span class="built_in">result</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">        <span class="comment">// 差分数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Difference</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(!nums.<span class="built_in">empty</span>());</span><br><span class="line">            diff.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="comment">// 构造差分数组</span></span><br><span class="line">            diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给闭区间 [i, j] 增加 val（可以是负数）</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            diff[i] += val;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">            <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">            res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用一个差分数组来做后续操作</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">Difference <span class="title">df</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> booking : bookings)</span><br><span class="line">            df.<span class="built_in">add</span>(booking[<span class="number">0</span>]<span class="number">-1</span>, booking[<span class="number">1</span>]<span class="number">-1</span>, booking[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> df.<span class="built_in">result</span>();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Class: 差分数组</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">// 初始化构造差分数组</span></span><br><span class="line">            <span class="built_in">Difference</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums)&#123;</span><br><span class="line">                diff.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">                diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)  </span><br><span class="line">                    diff[i] = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对区间 [i,j] 都加 val</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">                diff[i] += val;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; diff.<span class="built_in">size</span>())  diff[j+<span class="number">1</span>] -= val;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回完整数组</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(diff.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">                ans[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;diff.<span class="built_in">size</span>(); i++)  </span><br><span class="line">                    ans[i] = ans[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T3：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; trips, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 差分数组 nums[i] 表示在站点 i 时，车上应该多少人</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 站点有 0 - 1000 </span></span><br><span class="line">        <span class="function">Difference <span class="title">df</span><span class="params">(nums)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有的中途上下站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;trip : trips)</span><br><span class="line">            df.<span class="built_in">add</span>(trip[<span class="number">1</span>], trip[<span class="number">2</span>]<span class="number">-1</span>, trip[<span class="number">0</span>]); <span class="comment">// 站点编号 0 开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查所有站点，都是可以完成的</span></span><br><span class="line">        <span class="keyword">auto</span> res = df.<span class="built_in">result</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt; capacity)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Difference</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums)&#123;</span><br><span class="line">                diff.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">                diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">                    diff[i] = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">                diff[i] += val;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; diff.<span class="built_in">size</span>())  diff[j+<span class="number">1</span>] -= val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">                ans[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;diff.<span class="built_in">size</span>(); i++)</span><br><span class="line">                    ans[i] = ans[i<span class="number">-1</span>] + diff[i];</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、滑动窗口延伸：Rabin-Karp-字符匹配算法">6、滑动窗口延伸：Rabin Karp 字符匹配算法</h3>
<p>下面是滑动窗口的框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口算法伪码框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据，根据具体场景变通</span></span><br><span class="line">    <span class="comment">// 比如说，我想记录窗口中元素出现的次数，就用 map</span></span><br><span class="line">    <span class="comment">// 如果我想记录窗口中的元素和，就可以只用一个 int</span></span><br><span class="line">    <span class="keyword">auto</span> window = ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c);</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *** debug 输出的位置 ***</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d);</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看，你是如何：</p>
<ol>
<li>在最低位添加一个数字</li>
<li>在最高位删除一个数字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ****** 在最低位添加一个数字 ******</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">8264</span>;</span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> R = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 想在 number 的最低位添加的数字</span></span><br><span class="line"><span class="type">int</span> appendVal = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 运算，在最低位添加一位</span></span><br><span class="line">number = R * number + appendVal;</span><br><span class="line"><span class="comment">// 此时 number = 82643</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ****** 在最高位删除一个数字 ******</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">8264</span>;</span><br><span class="line"><span class="comment">// number 的进制</span></span><br><span class="line"><span class="type">int</span> R = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// number 最高位的数字</span></span><br><span class="line"><span class="type">int</span> removeVal = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 此时 number 的位数</span></span><br><span class="line"><span class="type">int</span> L = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 运算，删除最高位数字</span></span><br><span class="line">number = number - removeVal * Math.<span class="built_in">pow</span>(R, L<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 此时 number = 264</span></span><br></pre></td></tr></table></figure>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/description/">寻找重复子序列</a><br>
方法一：直接暴力看所有长度 10 的串是否出现过。（哈希集合）<br>
方法二：改为通过一个数字就能直接判断是否出现过。（仍然哈希集合，但是避免了每一次都 substr，而只需要在添加答案时使用substr）</li>
<li><a href="">Rabin-Karp 字符串匹配</a><br>
那么借鉴上面的思路，我们不要每次都去一个字符一个字符地比较子串和模式串，而是维护一个滑动窗口，运用滑动哈希算法一边滑动一边计算窗口中字符串的哈希值，拿这个哈希值去和模式串的哈希值比较，这样就可以避免截取子串，从而把匹配算法降低为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这就是 Rabin-Karp 指纹字符串查找算法的核心逻辑。
<ol>
<li>进制采用 R = 256（因为编码字符 ASCII 共 256 个）</li>
<li>长度看模式串的长度 L = pat.size()</li>
<li>为解决数字过大，采用取余（模一个大素数1658598167）</li>
<li>为解决哈希冲突，要进一步直接对比字符串</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">T1<span class="number">-1</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 暴力法：哈希集合</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; seen;</span><br><span class="line">        unordered_set&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i+<span class="number">9</span>&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            string ts = s.<span class="built_in">substr</span>(i, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">find</span>(ts) != seen.<span class="built_in">end</span>())</span><br><span class="line">                ans.<span class="built_in">insert</span>(ts);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                seen.<span class="built_in">insert</span>(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转回数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T1<span class="number">-2</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 关键在于可以优化掉不需要取 L=10 的子串。</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转为数字</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">s2Nums</span>(s);</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; seen;</span><br><span class="line">        unordered_set&lt;string&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> R = <span class="number">4</span>, L = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> RL = <span class="built_in">pow</span>(R, L<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cur = cur*R + nums[r];</span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(r-l == L)&#123;</span><br><span class="line">                <span class="keyword">if</span>(seen.<span class="built_in">find</span>(cur) != seen.<span class="built_in">end</span>())</span><br><span class="line">                    ans.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(l, L));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    seen.<span class="built_in">insert</span>(cur);</span><br><span class="line">                cur = cur - nums[l]*RL;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用 4 进制表示 ACGT 即可唯一标识了</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s2Nums</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                    nums[i] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2：</span><br><span class="line"><span class="comment">// Rabin-Karp 指纹字符串查找算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rabinKarp</span><span class="params">(string txt, string pat)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 位数</span></span><br><span class="line">    <span class="type">int</span> L = pat.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">// 进制（只考虑 ASCII 编码）</span></span><br><span class="line">    <span class="type">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 取一个比较大的素数作为求模的除数</span></span><br><span class="line">    <span class="type">long</span> Q = <span class="number">1658598167</span>;</span><br><span class="line">    <span class="comment">// R^(L - 1) 的结果</span></span><br><span class="line">    <span class="type">long</span> RL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= L - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算过程中不断求模，避免溢出</span></span><br><span class="line">        RL = (RL * R) % Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算模式串的哈希值，时间 O(L)</span></span><br><span class="line">    <span class="type">long</span> patHash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pat.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        patHash = (R * patHash + pat.<span class="built_in">at</span>(i)) % Q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口中子字符串的哈希值</span></span><br><span class="line">    <span class="type">long</span> windowHash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滑动窗口代码框架，时间 O(N)</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; txt.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="comment">// 扩大窗口，移入字符</span></span><br><span class="line">        windowHash = ((R * windowHash) % Q + txt.<span class="built_in">at</span>(right)) % Q;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当子串的长度达到要求</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == L) &#123;</span><br><span class="line">            <span class="comment">// 根据哈希值判断是否匹配模式串</span></span><br><span class="line">            <span class="keyword">if</span> (windowHash == patHash) &#123;</span><br><span class="line">                <span class="comment">// 当前窗口中的子串哈希值等于模式串的哈希值</span></span><br><span class="line">                <span class="comment">// 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突</span></span><br><span class="line">                <span class="keyword">if</span> (pat.<span class="built_in">compare</span>(txt.<span class="built_in">substr</span>(left, L)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缩小窗口，移出字符</span></span><br><span class="line">            windowHash = (windowHash - (txt.<span class="built_in">at</span>(left) * RL) % Q + Q) % Q;</span><br><span class="line">            <span class="comment">// X % Q == (X + Q) % Q 是一个模运算法则</span></span><br><span class="line">            <span class="comment">// 因为 windowHash - (txt[left] * RL) % Q 可能是负数</span></span><br><span class="line">            <span class="comment">// 所以额外再加一个 Q，保证 windowHash 不会是负数</span></span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到模式串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7、二分搜索思维">7、二分搜索思维</h3>
<blockquote>
<p>注意：下面都采用 ”<strong>左闭右开</strong>“ 的区间。<br>
搜索边界</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索左侧边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/bins-l.jpeg" alt="搜索左边界"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 搜索右侧边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/bins-r.jpeg" alt="搜索右边界"></p>
<p>下面看如何把二分搜索进行泛化：<br>
首先，你要从题目中抽象出一个自变量 <code>x</code>，一个关于 <code>x</code> 的函数 <code>f(x)</code>，以及一个目标值 <code>target</code>。同时，<code>x</code>, <code>f(x)</code>, <code>target</code> 还要满足以下条件：</p>
<ol>
<li><code>f(x)</code> 必须是在 <code>x</code> 上的单调函数（单调增单调减都可以）。</li>
<li>题目是让你计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值。<br>
那么，前面的二分搜索实际上就是：<code>int f(int x, vector&lt;int&gt;&amp; nums) &#123; return nums[x]; &#125;</code><br>
如果遇到一个算法问题，能够把它抽象成上面的图，就可以对它运用二分搜索算法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数 f 是关于自变量 x 的单调递增函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> nums[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> length, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(mid, nums) == target) &#123;</span><br><span class="line">            <span class="comment">// 当找到 target 时，收缩右侧边界</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">f</span>(mid, nums) &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">f</span>(mid, nums) &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是做题：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/koko-eating-bananas/description/">875. 爱吃香蕉的珂珂</a><br>
做法：
<ul>
<li>抽象出 y = f(k) 表示以速度 k 吃所需的总时间，注意 f 单调递减。</li>
<li>二分查找出左边界即可。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/">1011. 在 D 天内送达包裹的能力</a><br>
做法：
<ul>
<li>抽象出 y = f(cap) 表示运载能力 cap 下的所需天数，注意 f 单调递减。</li>
<li>二分查找左边界。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-largest-sum/description/">410. 分割数组的最大值</a><br>
做法：
<ul>
<li>抽象出 y = f(sum) 表示当最大和不能超过 sum 时，所分成的子数组个数。注意 f 单调递减。</li>
<li>二分查找左边界。</li>
</ul>
</li>
</ol>
<blockquote>
<p>总结来说，如果发现题目中存在<strong>单调关系</strong>，就可以尝试使用<strong>二分搜索</strong>的思路来解决。搞清楚单调性和二分搜索的种类，通过分析和画图，就能够写出最终的代码。</p>
</blockquote>
<p>全部代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质上，可以抽象成二分搜索的函数图，那么就能使用二分搜索，找左边界即可</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxK = *<span class="built_in">max_element</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = maxK+<span class="number">1</span>;   <span class="comment">// [l,r) </span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">f</span>(mid, piles);</span><br><span class="line">            <span class="keyword">if</span>(y == h)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &lt; h)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &gt; h)</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回：以 k 速度吃完所需的时间</span></span><br><span class="line">    <span class="comment">// f 是单调递减</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> k, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : piles)</span><br><span class="line">            sum += num/k + (num%k != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 最小值问题：二分查找左边界</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weights, <span class="type">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxCap = <span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = maxCap+<span class="number">1</span>;    <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">f</span>(mid, weights);</span><br><span class="line">            <span class="keyword">if</span>(y == days)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &gt; days)</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &lt; days)</span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回左边界</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数值：以 cap 运载能力时所需要的天数（f单调递减）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> cap, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; weights)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;w : weights)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w &gt; cap)  <span class="keyword">return</span> INT_MAX;    <span class="comment">// 注意判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum+w &lt;= cap)  sum += w;</span><br><span class="line">            <span class="keyword">else</span>  cnt++, sum = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum)  cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T3：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象出二分查找左边界</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = maxSum+<span class="number">1</span>;    <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">f</span>(mid, nums);</span><br><span class="line">            <span class="keyword">if</span>(y == k)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &lt; k)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &gt; k)</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数值：一个子数组和最大能为 sum 时，可以分成几个块（单调递减）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> sum, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; sum)  <span class="keyword">return</span> INT_MAX;  <span class="comment">// 注意判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curSum + num &lt;= sum)</span><br><span class="line">                curSum += num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt++, curSum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curSum)  cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8、带权随机选择算法">8、带权随机选择算法</h3>
<ul>
<li>参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-pick-with-weight/description/">528. 按权重随机选择</a></li>
</ul>
<ol>
<li>根据权重数组 w 生成前缀和数组 preSum。</li>
<li>生成一个取值在 preSum 之内的随机数，用二分搜索算法寻找大于等于这个随机数的最小元素索引。</li>
<li>最后对这个索引减一（因为前缀和数组有一位索引偏移），就可以作为权重数组的索引，即最终答案:<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/sz/sz-quanzrand.jpeg" alt="按权重随机选择"><br>
注意几个细节：</li>
</ol>
<ul>
<li>丢出的随机数 target 应该是范围 <code>[1, lastPreSum]</code></li>
<li>二分搜索大于等于的左边界</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preSum;</span><br><span class="line">    mt19937 gen;</span><br><span class="line">    uniform_int_distribution&lt;&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        <span class="type">int</span> n = w.<span class="built_in">size</span>();</span><br><span class="line">        preSum.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            preSum[i+<span class="number">1</span>] = preSum[i] + w[i];</span><br><span class="line">        <span class="comment">// 随机分布的整数</span></span><br><span class="line">        dis = uniform_int_distribution&lt;&gt;(<span class="number">1</span>, preSum[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> target = <span class="built_in">dis</span>(gen);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">left_bound</span>(target) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = preSum.<span class="built_in">size</span>();   <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y = preSum[mid];</span><br><span class="line">            <span class="keyword">if</span>(y == target)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &gt; target)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y &lt; target)</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9、田忌赛马决策算法">9、田忌赛马决策算法</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/advantage-shuffle/description/">870. 优势洗牌</a><br>
这就像田忌赛马的情景，nums1 就是田忌的马，nums2 就是齐王的马，数组中的元素就是马的战斗力。</li>
</ul>
<p>注意：节约的策略是没问题的，但是没有必要。这也是本题有趣的地方，需要绕个脑筋急转弯：</p>
<ul>
<li>我们暂且把田忌的一号选手称为 <code>T1</code>，二号选手称为 <code>T2</code>，齐王的一号选手称为 <code>Q1</code>。</li>
<li>如果 <code>T2</code> 能赢 <code>Q1</code>，你试图保存己方实力，让 <code>T2</code> 去战 <code>Q1</code>，把 <code>T1</code> 留着是为了对付谁？</li>
<li>显然，你担心齐王还有战力大于 <code>T2</code> 的马，可以让 <code>T1</code> 去对付。</li>
<li>但是你仔细想想，现在 <code>T2</code> 已经是可以战胜 <code>Q1</code> 的，<code>Q1</code> 可是齐王的最快的马耶，齐王剩下的那些马里，怎么可能还有比 <code>T2</code> 更强的马？</li>
<li>所以，没必要节约，最后我们得出的策略就是：<br>
<strong>将齐王和田忌的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 由于需要和 nums2 的每一个比，nums2 记住下标</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pairs2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)  pairs2.<span class="built_in">push_back</span>(&#123;nums2[i], i&#125;);</span><br><span class="line">        <span class="comment">// 从大到小排序</span></span><br><span class="line">        <span class="built_in">sort</span>(pairs2.<span class="built_in">begin</span>(), pairs2.<span class="built_in">end</span>(), greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>; <span class="comment">// 左右指针控制当前 nums1 的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p2 : pairs2)&#123;</span><br><span class="line">            <span class="type">int</span> num2 = p2.first;</span><br><span class="line">            <span class="type">int</span> i = p2.second;</span><br><span class="line">            <span class="comment">// 打得过就直接打</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[l] &gt; num2)</span><br><span class="line">                ans[i] = nums1[l], l++;</span><br><span class="line">            <span class="comment">// 打不过，用最菜的上来</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i] = nums1[r], r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三-队列、栈">(三) 队列、栈</h2>
<h3 id="1、队列与栈的互相实现">1、队列与栈的互相实现</h3>
<ol>
<li>用栈实现队列<br>
做法：使用两个栈S1、S2就能实现，S1 作为队尾，S2 作为队头，push向 S1 进，pop取 S2 的，S2 空时取出全部 S1。<br>
均摊时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（因为每个元素最多搬运一次）</li>
<li>用队列实现栈<br>
做法：比较简单暴力，主要需要取栈顶时，把所有元素重新排队，直到队尾的元素已经到队头了，就可以了。<br>
时间复杂度：pop操作时是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其他操作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<blockquote>
<p>本质上是需要实现两个功能就行，<code>top/front</code>和 <code>pop</code>就行，因为只有这两个操作是对外显示状态的。</p>
</blockquote>
<p>栈实现队列比较巧妙，下图只给出这个的图解和代码：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/stkque-1.jpg" alt="栈实现队列"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/stkque-2.jpg" alt="栈实现队列"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到队尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回队头元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">// 把 s1 元素压入 s2</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除队头元素并返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先调用 peek 保证 s2 非空</span></span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="type">int</span> poppedValue = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> poppedValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 判断队列是否为空</span></span><br><span class="line">     <span class="comment">// 两个栈都为空才说明队列为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、单调栈">2、单调栈</h3>
<p>栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p>
<p>听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等。</p>
<ol>
<li>模版</li>
</ol>
<ul>
<li>输入一个数组 <code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 <code>-1</code>。</li>
<li>输入一个数组 <code>nums = [2,1,2,4,3]</code></li>
<li>你返回数组 <code>[4,2,4,-1,-1]</code><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/ddz-1.jpeg" alt="单调栈"></li>
<li>抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。<br>
下面是代码，这个做法比直接简单粗暴的二次循环要更快，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">calculateGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="comment">// 倒着进</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 保持单调栈是递减的(栈中比当前数字还矮的出去)</span></span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= S.<span class="built_in">top</span>())</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 目前的栈顶就是第一个比 cur 大的</span></span><br><span class="line">        res[i] = S.<span class="built_in">empty</span>()? <span class="number">-1</span> : S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">496. 下一个更大元素 I</a><br>
做法：
<ul>
<li>直接把 <code>nums2</code> 的全部元素都完成单调栈，存储答案在哈希表</li>
<li>然后根据 <code>nums1</code> 去查表即可。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度</a><br>
做法：
<ul>
<li>仍然是单调栈即可</li>
<li>注意存储的是下标（因为答案是问几天之后）</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">环形数组：503. 下一个更大元素 II</a><br>
比如输入 <code>[2,1,2,4,3]</code>你应该返回 <code>[4,2,4,-1,4]</code>，因为拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4。<br>
做法：把数组翻倍即可。（实际上，你可以不用真的翻倍，而是采用取模来实现即可）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/ddz-2.jpeg" alt="环形数组-数组翻倍"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">T2: </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单调栈 + 哈希表</span></span><br><span class="line">    <span class="comment">// 直接把 nums2 全部完成，然后 nums1 去查表即可</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 完成 nums2</span></span><br><span class="line">        <span class="type">int</span> n2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; TB;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n2<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt;= S.<span class="built_in">top</span>())</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            TB[nums2[i]] = S.<span class="built_in">empty</span>() ? <span class="number">-1</span> : S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums1 去查表</span></span><br><span class="line">        <span class="type">int</span> n1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n1)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n1; i++)</span><br><span class="line">            ans[i] = TB[nums1[i]];</span><br><span class="line">        <span class="comment">// 完成</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T3:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单调栈</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt;= temperatures[S.<span class="built_in">top</span>()])</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            ans[i] = S.<span class="built_in">empty</span>() ? <span class="number">0</span> : S.<span class="built_in">top</span>()-i;</span><br><span class="line">            S.<span class="built_in">push</span>(i);  <span class="comment">// 注意是存储下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T4:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单调栈 + 数组翻倍（取模技巧）</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; nums[i%n] &gt;= S.<span class="built_in">top</span>())</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            ans[i%n] = S.<span class="built_in">empty</span>() ? <span class="number">-1</span> : S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">push</span>(nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、单调队列">3、单调队列</h3>
<ul>
<li>给你一个数组 <code>window</code>，已知其最值为 <code>A</code>，如果给 <code>window</code> 中添加一个数 <code>B</code>，那么比较一下 <code>A</code> 和 <code>B</code> 就可以立即算出新的最值；但如果要从 <code>window</code> 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 <code>A</code>，就需要遍历 <code>window</code> 中的所有元素重新寻找新的最值。</li>
<li>这个场景很常见，但不用单调队列似乎也可以，比如 <code>优先级队列（二叉堆）</code> 就是专门用来动态寻找最值的，我创建一个大（小）顶堆，不就可以很快拿到最大（小）值了吗？如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「<strong>先进先出</strong>」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。</li>
<li>现在需要一种新的队列结构，既能够维护队列元素「<strong>先进先出</strong>」的时间顺序，又能够正确维护队列中所有元素的<strong>最值</strong>，这就是「单调队列」结构。</li>
<li>「单调队列」这个数据结构主要用来辅助解决<strong>滑动窗口</strong>相关的问题。</li>
<li>前文 滑动窗口核心框架 把滑动窗口算法作为双指针技巧的一部分进行了讲解，但有些稍微复杂的滑动窗口问题不能只靠两个指针来解决，需要上更先进的数据结构。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p>核心：实现单调队列</p>
<ul>
<li>「单调队列」的核心思路和「单调栈」类似，push 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉。</li>
<li>可以想象，加入数字的大小代表人的体重，体重大的会把前面体重不足的压扁，直到遇到更大的量级才停住。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/dddl-1.png" alt="单调队列"></li>
<li>注意，虽然说下面的 push 有 while 循环，但是时间复杂度是常数级，因为每一个元素只会操作一次。整个代码全部执行完，也才只有每个元素操作一次，即整个解法的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>那么push 时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，k 是窗口大小。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MonoQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; DQ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保证单调队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这里没有等于，思考：因为pop是按值pop的，相同的要保留</span></span><br><span class="line">        <span class="keyword">while</span>(!DQ.<span class="built_in">empty</span>() &amp;&amp; num &gt; DQ.<span class="built_in">back</span>())</span><br><span class="line">            DQ.<span class="built_in">pop_back</span>();</span><br><span class="line">        DQ.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，不是都 pop 的，最大值才pop</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == DQ.<span class="built_in">front</span>())</span><br><span class="line">            DQ.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队头就是当前队列的最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DQ.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口 + 单调队列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        MonoQueue MQ;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 先压 k-1 个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=k<span class="number">-2</span>; i++)  MQ.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 一个一个压</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            MQ.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(MQ.<span class="built_in">max</span>());</span><br><span class="line">            MQ.<span class="built_in">pop</span>(nums[i-k+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>拓展延伸<br>
最后，提出几个问题请大家思考：</p>
</blockquote>
<ol>
<li>本文给出的 <code>MonotonicQueue</code> 类只实现了 <code>max</code> 方法，你是否能够再额外添加一个 <code>min</code> 方法，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间返回队列中所有元素的最小值？</li>
<li>本文给出的 <code>MonotonicQueue</code> 类的 <code>pop</code> 方法还需要接收一个参数，这不那么优雅，而且有悖于标准队列的 API，请你修复这个缺陷。</li>
<li>请你实现 <code>MonotonicQueue</code> 类的 <code>size</code> 方法，返回单调队列中元素的个数（注意，由于每次 <code>push</code> 方法都可能从底层的 <code>q</code> 列表中删除元素，所以 <code>q</code> 中的元素个数并不是单调队列的元素个数）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列的通用实现，可以高效维护最大值和最小值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonotonicQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 标准队列 API，向队尾加入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(E elem)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准队列 API，从队头弹出元素，符合先进先出的顺序</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准队列 API，返回队列中的元素个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调队列特有 API，O(1) 时间计算队列中元素的最大值</span></span><br><span class="line">    <span class="function">E <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调队列特有 API，O(1) 时间计算队列中元素的最小值</span></span><br><span class="line">    <span class="function">E <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-二叉树">(四) 二叉树</h2>
<p>待完成…</p>
<h2 id="五-二叉树强化">(五) 二叉树强化</h2>
<p>待完成…</p>
<h2 id="六-二叉树拓展">(六) 二叉树拓展</h2>
<p>待完成…</p>
<h2 id="七-经典数据结构设计">(七) 经典数据结构设计</h2>
<h3 id="1、LRU-算法">1、LRU 算法</h3>
<ul>
<li>LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。</li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/">146. LRU 缓存</a></li>
<li>哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 LinkedHashMap。</li>
<li>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/dl/LRU-1.jpg" alt="哈希链表"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    Node* next, *prev;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">val</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 头尾虚节点</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line">    <span class="comment">// 链表元素数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoubleList</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化双向链表的数据</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addLast</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev = tail-&gt;prev;</span><br><span class="line">        x-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev-&gt;next = x;</span><br><span class="line">        tail-&gt;prev = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">        x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="function">Node* <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* first = head-&gt;next;</span><br><span class="line">        <span class="built_in">remove</span>(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该数据提升为最近使用的</span></span><br><span class="line">        <span class="built_in">makeRecently</span>(key);</span><br><span class="line">        <span class="keyword">return</span> map[key]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 删除旧的数据</span></span><br><span class="line">            <span class="built_in">deleteKey</span>(key);</span><br><span class="line">            <span class="comment">// 新插入的数据为最近使用的数据</span></span><br><span class="line">            <span class="built_in">addRecently</span>(key, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cap == cache.<span class="built_in">getSize</span>()) &#123;</span><br><span class="line">            <span class="comment">// 删除最久未使用的元素</span></span><br><span class="line">            <span class="built_in">removeLeastRecently</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加为最近使用的元素</span></span><br><span class="line">        <span class="built_in">addRecently</span>(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* x = map[key];</span><br><span class="line">        <span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">        cache.<span class="built_in">remove</span>(x);</span><br><span class="line">        <span class="comment">// 重新插到队尾</span></span><br><span class="line">        cache.<span class="built_in">addLast</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRecently</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node* x = <span class="keyword">new</span> <span class="built_in">Node</span>(key, val);</span><br><span class="line">        <span class="comment">// 链表尾部就是最近使用的元素</span></span><br><span class="line">        cache.<span class="built_in">addLast</span>(x);</span><br><span class="line">        <span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">        map[key] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteKey</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* x = map[key];</span><br><span class="line">        <span class="comment">// 从链表中删除</span></span><br><span class="line">        cache.<span class="built_in">remove</span>(x);</span><br><span class="line">        <span class="comment">// 从 map 中删除</span></span><br><span class="line">        map.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表头部的第一个元素就是最久未使用的</span></span><br><span class="line">        Node* deletedNode = cache.<span class="built_in">removeFirst</span>();</span><br><span class="line">        <span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">        <span class="type">int</span> deletedKey = deletedNode-&gt;key;</span><br><span class="line">        map.<span class="built_in">erase</span>(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、LFU-算法">2、LFU 算法</h3>
<ul>
<li>LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。</li>
<li>从实现难度上来说，LFU 算法的难度大于 LRU 算法。</li>
<li>LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</li>
<li>参考类似题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-frequency-stack/description/?show=1">895. 最大频率栈</a></li>
</ul>
<p>解决方案：</p>
<ol>
<li>使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; keyToVal;</span><br></pre></td></tr></table></figure>
</li>
<li>使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; keyToFreq;</span><br></pre></td></tr></table></figure>
</li>
<li>如果在容量满了的时候进行插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。
<ul>
<li>需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</li>
<li><code>freq</code> 对 <code>key</code> 是一对多的关系，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</li>
<li>用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code>。</li>
<li>希望 <code>freq</code> 对应的 <code>key</code> 的列表是存在时序的。</li>
<li>希望能够快速删除 <code>key</code> 列表中的任何一个 <code>key</code>，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li>
</ul>
</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; freqToKeys;</span><br><span class="line"><span class="type">int</span> minFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>完整代码：<br>
代码比较难写，请记住需要三个关键的表 KV、KF、FK 表，面试需要能说得出口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyToVal.<span class="built_in">find</span>(key) == keyToVal.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">        <span class="built_in">increaseFreq</span>(key);</span><br><span class="line">        <span class="keyword">return</span> keyToVal[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 key 已存在，修改对应的 val 即可</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.<span class="built_in">find</span>(key) != keyToVal.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            keyToVal[key] = val;</span><br><span class="line">            <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">            <span class="built_in">increaseFreq</span>(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 不存在，需要插入</span></span><br><span class="line">        <span class="comment">// 容量已满的话需要淘汰一个 freq 最小的 key</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.<span class="built_in">size</span>() &gt;= <span class="keyword">this</span>-&gt;cap) &#123;</span><br><span class="line">            <span class="built_in">removeMinFreqKey</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入 key 和 val，对应的 freq 为 1</span></span><br><span class="line">        <span class="comment">// 插入 KV 表</span></span><br><span class="line">        keyToVal[key] = val;</span><br><span class="line">        <span class="comment">// 插入 KF 表</span></span><br><span class="line">        keyToFreq[key] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 插入 FK 表</span></span><br><span class="line">        freqToKeys[<span class="number">1</span>].<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; keyList = freqToKeys[<span class="keyword">this</span>-&gt;minFreq];</span><br><span class="line">        <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">        <span class="type">int</span> deletedKey = keyList.<span class="built_in">front</span>();</span><br><span class="line">        keyList.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (keyList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freqToKeys.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;minFreq);</span><br><span class="line">            <span class="comment">// 如果 freqToKeys[minFreq] 为空，需要更新 minFreq</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除 KV 表中的该 key</span></span><br><span class="line">        keyToVal.<span class="built_in">erase</span>(deletedKey);</span><br><span class="line">        <span class="comment">// 删除 KF 表中的该 key</span></span><br><span class="line">        keyToFreq.<span class="built_in">erase</span>(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> freq = keyToFreq[key];</span><br><span class="line">        <span class="comment">// 更新 KF 表</span></span><br><span class="line">        keyToFreq[key] = freq + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新 FK 表</span></span><br><span class="line">        <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; oldList = freqToKeys[freq];</span><br><span class="line">        oldList.<span class="built_in">remove</span>(key);</span><br><span class="line">        <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">        freqToKeys[freq + <span class="number">1</span>].<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="keyword">if</span> (oldList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            freqToKeys.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            <span class="keyword">if</span> (freq == <span class="keyword">this</span>-&gt;minFreq) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、随机集合、黑名单随机数">3、随机集合、黑名单随机数</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">380. O(1) 时间插入、删除和获取随机元素</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储元素的值</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">// 记录每个元素对应在 nums 中的索引</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; valToIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 val 已存在，不用再插入</span></span><br><span class="line">        <span class="keyword">if</span> (valToIndex.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 val 不存在，插入到 nums 尾部，</span></span><br><span class="line">        <span class="comment">// 并记录 val 对应的索引值</span></span><br><span class="line">        valToIndex[val] = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若 val 不存在，不用再删除</span></span><br><span class="line">        <span class="keyword">if</span> (!valToIndex.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先拿到 val 的索引</span></span><br><span class="line">        <span class="type">int</span> index = valToIndex[val];</span><br><span class="line">        <span class="comment">// 将最后一个元素对应的索引修改为 index</span></span><br><span class="line">        <span class="type">int</span> lastElement = nums.<span class="built_in">back</span>();</span><br><span class="line">        valToIndex[lastElement] = index;</span><br><span class="line">        <span class="comment">// 交换 val 和最后一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[index], nums.<span class="built_in">back</span>());</span><br><span class="line">        <span class="comment">// 在数组中删除元素 val</span></span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 删除元素 val 对应的索引</span></span><br><span class="line">        valToIndex.<span class="built_in">erase</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随机获取 nums 中的一个元素</span></span><br><span class="line">        <span class="type">int</span> randomIndex = <span class="built_in">rand</span>() % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-pick-with-blacklist/description/">710. 黑名单中的随机数</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(<span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; blacklist) &#123;</span><br><span class="line">        sz = N - blacklist.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转化成集合，方便快速查询</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; blackSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; b : blacklist)&#123;</span><br><span class="line">            blackSet.<span class="built_in">insert</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> last = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; b : blacklist)&#123;</span><br><span class="line">            <span class="comment">// 如果 b 已经在区间 [sz, N)，可以直接忽略</span></span><br><span class="line">            <span class="keyword">if</span>(b &gt;= sz) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 跳过所有黑名单中的数字</span></span><br><span class="line">            <span class="keyword">while</span>(blackSet.<span class="built_in">count</span>(last)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将黑名单中的索引映射到合法数字</span></span><br><span class="line">            mapping[b] = last;</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随机选取一个索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">rand</span>() % sz;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个索引命中了黑名单，需要被映射到其他位置</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.<span class="built_in">count</span>(index) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> mapping[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若没命中黑名单，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、TreeMap-与-TreeSet">4、TreeMap 与 TreeSet</h3>
<h3 id="5、基本线段树">5、基本线段树</h3>
<ol>
<li>链式实现与数组实现<br>
最直接的想法，就是使用类似二叉树节点的 SegmentNode 类来实现线段树，我们不妨称之为线段树的链式实现：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentNode</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点对应的索引区间</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前区间内元素的聚合值</span></span><br><span class="line">    <span class="type">int</span> mergeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子节点</span></span><br><span class="line">    SegmentNode left = null, right = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    SegmentNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为线段树是一种近似于完全二叉树的结构，所以也可以用数组来存储线段树，不需要真的使用 SegmentNode 构建树结构，我们不妨称这种实现方式为线段树的数组实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="comment">// 用数组存储完全二叉树结构</span></span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链式更容易理解，数组的更抽象但效率更高，实际应用中，直接采用数组的。</p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/description/">307. 区域和检索 - 数组可修改</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 该节点表示的区间范围 [l, r]</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="comment">// [l, r] 区间元素的聚合值（如区间和、区间最大值等）</span></span><br><span class="line">    <span class="type">int</span> mergeVal;</span><br><span class="line">    SegmentNode* left;</span><br><span class="line">    SegmentNode* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegmentNode</span>(<span class="type">int</span> mergeVal, <span class="type">int</span> l, <span class="type">int</span> r) </span><br><span class="line">        : <span class="built_in">mergeVal</span>(mergeVal), <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SegmentNode* root;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; merger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 nums[l..r] 中的元素构建成线段树，返回根节点</span></span><br><span class="line">    <span class="function">SegmentNode* <span class="title">build</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间内只有一个元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegmentNode</span>(nums[l], l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从中间切分，递归构建左右子树</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        SegmentNode* left = <span class="built_in">build</span>(nums, l, mid);</span><br><span class="line">        SegmentNode* right = <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 根据左右子树的聚合值，计算当前根节点的聚合值</span></span><br><span class="line">        SegmentNode* node = <span class="keyword">new</span> <span class="built_in">SegmentNode</span>(<span class="built_in">merger</span>(left-&gt;mergeVal, right-&gt;mergeVal), l, r);</span><br><span class="line">        <span class="comment">// 组装左右子树</span></span><br><span class="line">        node-&gt;left = left;</span><br><span class="line">        node-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(SegmentNode* node, <span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;l == node-&gt;r) &#123;</span><br><span class="line">            <span class="comment">// 找到了目标叶子节点，更新值</span></span><br><span class="line">            node-&gt;mergeVal = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = node-&gt;l + (node-&gt;r - node-&gt;l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// 若 index 较小，则去左子树更新</span></span><br><span class="line">            <span class="built_in">update</span>(node-&gt;left, index, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 index 较大，则去右子树更新</span></span><br><span class="line">            <span class="built_in">update</span>(node-&gt;right, index, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序位置，左右子树已经更新完毕，更新当前节点的聚合值</span></span><br><span class="line">        node-&gt;mergeVal = <span class="built_in">merger</span>(node-&gt;left-&gt;mergeVal, node-&gt;right-&gt;mergeVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(SegmentNode* node, <span class="type">int</span> qL, <span class="type">int</span> qR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qL &gt; qR) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid query range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;l == qL &amp;&amp; node-&gt;r == qR) &#123;</span><br><span class="line">            <span class="comment">// 命中了目标区间，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> node-&gt;mergeVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未直接命中区间，需要继续向下查找</span></span><br><span class="line">        <span class="type">int</span> mid = node-&gt;l + (node-&gt;r - node-&gt;l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (qR &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// node.l &lt;= qL &lt;= qR &lt;= mid</span></span><br><span class="line">            <span class="comment">// 目标区间完全在左子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(node-&gt;left, qL, qR);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qL &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// mid &lt; qL &lt;= qR &lt;= node.r</span></span><br><span class="line">            <span class="comment">// 目标区间完全在右子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(node-&gt;right, qL, qR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// node.l &lt;= qL &lt;= mid &lt; qR &lt;= node.r</span></span><br><span class="line">            <span class="comment">// 目标区间横跨左右子树</span></span><br><span class="line">            <span class="comment">// 将查询区间拆分成 [qL, mid] 和 [mid + 1, qR] 两部分，分别向左右子树查询</span></span><br><span class="line">            <span class="comment">// 最后将左右子树的查询结果合并</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merger</span>(</span><br><span class="line">                <span class="built_in">query</span>(node-&gt;left, qL, mid),</span><br><span class="line">                <span class="built_in">query</span>(node-&gt;right, mid + <span class="number">1</span>, qR)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建线段树</span></span><br><span class="line">    <span class="comment">// 输入数组 nums 和一个聚合函数 merger，merger 用于计算区间的聚合值</span></span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; merger)</span><br><span class="line">        : <span class="built_in">merger</span>(merger) &#123;</span><br><span class="line">        root = <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(root, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> qL, <span class="type">int</span> qR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(root, qL, qR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 示例，创建一棵求和线段树</span></span><br><span class="line">    <span class="function">SegmentTree <span class="title">st</span><span class="params">(arr, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 3 + 5 + 7 = 15</span></span><br><span class="line">    st.<span class="built_in">update</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 3 + 10 + 7 = 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看数组实现线段树：</p>
<blockquote>
<ul>
<li>这里我们也把数组的索引 <code>0</code> 作为根节点，那么对于索引为 <code>i</code> 的节点，它的左子节点索引为 <code>2*i+1</code>，右子节点索引为 <code>2*i+2</code>。</li>
<li>数组实现线段树和数组实现二叉堆有一个重要不同：<br>
假设数组元素个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，那么存储线段树的数组容量应该初始化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span>，而二叉堆数组只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的容量。<br>
（为了确保数组能够存储线段树的所有节点）</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArraySegmentTree</span> &#123;</span><br><span class="line">    <span class="comment">// 用数组存储线段树结构</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; merger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：对 nums[l..r] 区间的元素构建线段树，rootIndex 是根节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rootIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="comment">// 区间内只有一个元素，设置为叶子节点</span></span><br><span class="line">            tree[rootIndex] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从中间切分，递归构建左右子树</span></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftRootIndex = <span class="built_in">leftChild</span>(rootIndex);</span><br><span class="line">        <span class="type">int</span> rightRootIndex = <span class="built_in">rightChild</span>(rootIndex);</span><br><span class="line">        <span class="comment">// 递归构建 nums[l..mid]，根节点为 leftRootIndex</span></span><br><span class="line">        <span class="built_in">build</span>(nums, l, mid, leftRootIndex);</span><br><span class="line">        <span class="comment">// 递归构建 nums[mid+1..r]，根节点为 rightRootIndex</span></span><br><span class="line">        <span class="built_in">build</span>(nums, mid + <span class="number">1</span>, r, rightRootIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序位置，左右子树已经构建完毕，更新当前节点的聚合值</span></span><br><span class="line">        tree[rootIndex] = <span class="built_in">merger</span>(tree[leftRootIndex], tree[rightRootIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rootIndex, <span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前节点为 rootIndex，对应的区间为 [l, r]</span></span><br><span class="line">        <span class="comment">// 去子树更新 nums[index] 为 value</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="comment">// 找到了目标叶子节点，更新值</span></span><br><span class="line">            tree[rootIndex] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// 若 index 较小，则去左子树更新</span></span><br><span class="line">            <span class="built_in">update</span>(l, mid, <span class="built_in">leftChild</span>(rootIndex), index, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 index 较大，则去右子树更新</span></span><br><span class="line">            <span class="built_in">update</span>(mid + <span class="number">1</span>, r, <span class="built_in">rightChild</span>(rootIndex), index, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序位置，左右子树已经更新完毕，更新当前节点的聚合值</span></span><br><span class="line">        tree[rootIndex] = <span class="built_in">merger</span>(tree[<span class="built_in">leftChild</span>(rootIndex)], tree[<span class="built_in">rightChild</span>(rootIndex)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rootIndex, <span class="type">int</span> qL, <span class="type">int</span> qR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qL == l &amp;&amp; r == qR) &#123;</span><br><span class="line">            <span class="comment">// 命中了目标区间，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> tree[rootIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftRootIndex = <span class="built_in">leftChild</span>(rootIndex);</span><br><span class="line">        <span class="type">int</span> rightRootIndex = <span class="built_in">rightChild</span>(rootIndex);</span><br><span class="line">        <span class="keyword">if</span> (qR &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// node.l &lt;= qL &lt;= qR &lt;= mid</span></span><br><span class="line">            <span class="comment">// 目标区间完全在左子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(l, mid, leftRootIndex, qL, qR);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qL &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// mid &lt; qL &lt;= qR &lt;= node.r</span></span><br><span class="line">            <span class="comment">// 目标区间完全在右子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span>, r, rightRootIndex, qL, qR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// node.l &lt;= qL &lt;= mid &lt; qR &lt;= node.r</span></span><br><span class="line">            <span class="comment">// 目标区间横跨左右子树</span></span><br><span class="line">            <span class="comment">// 将查询区间拆分成 [qL, mid] 和 [mid + 1, qR] 两部分，分别向左右子树查询</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merger</span>(<span class="built_in">query</span>(l, mid, leftRootIndex, qL, mid),</span><br><span class="line">                          <span class="built_in">query</span>(mid + <span class="number">1</span>, r, rightRootIndex, mid + <span class="number">1</span>, qR));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leftChild</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rightChild</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArraySegmentTree</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; mergeFunc)</span><br><span class="line">        : <span class="built_in">n</span>(nums.<span class="built_in">size</span>()), <span class="built_in">merger</span>(mergeFunc) &#123;</span><br><span class="line">        <span class="comment">// 分配 4 倍数组长度的空间，存储线段树</span></span><br><span class="line">        tree.<span class="built_in">resize</span>(<span class="number">4</span> * n);</span><br><span class="line">        <span class="built_in">build</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> qL, <span class="type">int</span> qR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qL &lt; <span class="number">0</span> || qR &gt;= n || qL &gt; qR) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid range: [&quot;</span> + std::<span class="built_in">to_string</span>(qL) + <span class="string">&quot;, &quot;</span> + std::<span class="built_in">to_string</span>(qR) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, qL, qR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 示例，创建一棵求和线段树</span></span><br><span class="line">    <span class="function">ArraySegmentTree <span class="title">st</span><span class="params">(arr, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 3 + 5 + 7 = 15</span></span><br><span class="line">    st.<span class="built_in">update</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; st.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 3 + 10 + 7 = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、动态线段树">6、动态线段树</h3>
<h3 id="7、懒更新线段树">7、懒更新线段树</h3>
<h3 id="8、Tire-树">8、Tire 树</h3>
<h3 id="9、朋友圈时间线算法">9、朋友圈时间线算法</h3>
<h3 id="10、考场座位分配算法">10、考场座位分配算法</h3>
<h3 id="11、计算器的设计">11、计算器的设计</h3>
<h3 id="12、两个二叉堆实现中位数算法">12、两个二叉堆实现中位数算法</h3>
<h3 id="13、数组去重问题">13、数组去重问题</h3>
<h2 id="八-图">(八) 图</h2>
<h3 id="1、有向图：环检测与拓扑排序">1、有向图：环检测与拓扑排序</h3>
<blockquote>
<ul>
<li>进行拓扑排序之前，先要确保图中没有环。</li>
<li>图的「逆后序遍历」顺序，就是拓扑排序的结果。</li>
</ul>
</blockquote>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/description/">207. 课程表</a><br>
做法：把题目的输入转化成一幅有向图，然后再判断图中是否存在环。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;  <span class="comment">// 图</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visit;     <span class="comment">// 为了访问所有节点的路</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;       <span class="comment">// 是否能完成</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; onPath;    <span class="comment">// traverse 用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prerequisites.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 把数组转为图</span></span><br><span class="line">        G.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            G[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测图是否有环即可</span></span><br><span class="line">        visit.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">        onPath.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses &amp;&amp; flag; i++)</span><br><span class="line">            <span class="built_in">traverse</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 start 为起点开始遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span>;  <span class="comment">// 已经失败就别进行了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若当前节点成环了</span></span><br><span class="line">        <span class="keyword">if</span>(onPath[start])&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不成环需要继续走</span></span><br><span class="line">        <span class="comment">// 优化：若走过，那肯定是不会成环</span></span><br><span class="line">        <span class="keyword">if</span>(visit[start])  <span class="keyword">return</span>;</span><br><span class="line">        visit[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 这条优化很重要！是在traverse里面就要优化，而不是在主函数里！</span></span><br><span class="line"></span><br><span class="line">        onPath[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> nxt : G[start])</span><br><span class="line">            <span class="built_in">traverse</span>(nxt);</span><br><span class="line">        onPath[start] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>拓扑排序</li>
</ol>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/description/">210. 课程表 II</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;  <span class="comment">// 图</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; visit;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; onPath;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;    <span class="comment">// 答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拓扑排序：后序遍历</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prerequisites.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构建图(按照指向先修课来做，因为每次会先完成先修课，再完成本次课)</span></span><br><span class="line">        G.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> from = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            G[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面遍历，同时把答案得到</span></span><br><span class="line">        visit.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">        onPath.<span class="built_in">resize</span>(numCourses, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses  &amp;&amp; flag; i++)</span><br><span class="line">            <span class="built_in">traverse</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不能完成</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从节点 start 开始遍历图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(onPath[start])&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(visit[start])  <span class="keyword">return</span>;</span><br><span class="line">        visit[start] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        onPath[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : G[start])</span><br><span class="line">            <span class="built_in">traverse</span>(i);</span><br><span class="line">        onPath[start] = <span class="literal">false</span>;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，上述两个都是 DFS 算法，其实也可以改换思想，写 BFS 的方法：</p>
<ul>
<li>主要是记录所有的节点的入度，同时记录下有多少元素曾经入栈cnt。</li>
<li>先把所有入度为 0 的压入栈 Q</li>
<li>再依次取出栈顶元素 e 操作，所有 e 的指向元素的入度减一，若减到 0 了则入栈 Q</li>
<li>最终栈空，查看cnt == nodeNum 就是答案。</li>
</ul>
<blockquote>
<p>对于拓扑排序，实际上就只需要记录下入栈顺序就是答案：<code>ans[cnt] = e</code> 即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建图，有向边代表「被依赖」关系</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;* graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">        <span class="comment">// 构建入度数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> from = edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 节点 to 的入度加一</span></span><br><span class="line">            indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据入度初始化队列中的节点</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 节点 i 没有入度，即没有依赖的节点</span></span><br><span class="line">                <span class="comment">// 可以作为拓扑排序的起点，加入队列</span></span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录遍历的节点个数</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始执行 BFS 循环</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 弹出节点 cur，并将它指向的节点的入度减一</span></span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">                indegree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果入度变为 0，说明 next 依赖的节点都已被遍历</span></span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有节点都被遍历过，说明不成环</span></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建图函数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt;* <span class="title">buildGraph</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> from = edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">            <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">            graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建图，和环检测算法相同</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">        <span class="comment">// 计算入度，和环检测算法相同</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> from = edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据入度初始化队列中的节点，和环检测算法相同</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录拓扑排序结果</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录遍历节点的顺序（索引）</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始执行 BFS 算法</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 弹出节点的顺序即为拓扑排序结果</span></span><br><span class="line">            res[count] = cur;</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">                indegree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count != numCourses) &#123;</span><br><span class="line">            <span class="comment">// 存在环，拓扑排序不存在</span></span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> from = edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">            <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">            graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、名流问题">2、名流问题</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-town-judge/description/">997. 找到小镇的法官</a></li>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-celebrity/description/">277. 搜寻名人</a></li>
<li>给你 n 个人的社交关系（你知道任意两个人之间是否认识），然后请你找出这些人中的「名人」。<br>
所谓「名人」有两个条件：<br>
1、所有其他人都认识「名人」。<br>
2、「名人」不认识任何其他人。</li>
</ul>
<blockquote>
<p>这个节点没有一条指向其他节点的有向边；且其他所有节点都有一条指向这个节点的有向边。<br>
或者说的专业一点，名人节点的出度为 0，入度为 n - 1。</p>
</blockquote>
<ul>
<li>这里的第一个题目是可以直接这样做的，但是第二个就不行了！</li>
<li>力扣第 277 题「搜寻名人」就是这个经典问题，不过<strong>并不是直接把邻接矩阵传给你</strong>，而是只告诉你总人数 <code>n</code>，同时提供一个 API <code>knows</code> 来查询人和人之间的社交关系。很明显，knows API 本质上还是在访问邻接矩阵。</li>
</ul>
<blockquote>
<p><code>bool knows(int i, int j);</code>能够返回 i 是否认识 j<br>
三种方法：</p>
</blockquote>
<ol>
<li>暴力</li>
<li>优化 1</li>
<li>优化 2</li>
</ol>
<blockquote>
<p>注意：<br>
我再重复一遍所谓「名人」的定义：1、所有其他人都认识名人。2、名人不认识任何其他人。<br>
这个定义就很有意思，<strong>它保证了人群中最多有一个名人</strong>。<br>
实际上你仔细分析会发现：两个人之间一共就 4 种关系。</p>
<ol>
<li>对于情况一，cand 认识 other，所以 cand 肯定不是名人，排除。因为名人不可能认识别人。</li>
<li>对于情况二，other 认识 cand，所以 other 肯定不是名人，排除。</li>
<li>对于情况三，他俩互相认识，肯定都不是名人，可以随便排除一个。</li>
<li>对于情况四，他俩互不认识，肯定都不是名人，可以随便排除一个。因为名人应该被所有其他人认识。<br>
综上，<strong>只要观察任意两个之间的关系，就至少能确定一个人不是名人</strong>。（优化1）</li>
</ol>
<p>进一步优化：理解上面的优化解法，其实可以不需要额外的空间解决这个问题。（优化 2）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">T1暴力：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cand = <span class="number">0</span>; cand &lt; n; cand++) &#123;</span><br><span class="line">            <span class="type">int</span> other;</span><br><span class="line">            <span class="keyword">for</span> (other = <span class="number">0</span>; other &lt; n; other++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cand == other) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 保证其他人都认识 cand，且 cand 不认识任何其他人</span></span><br><span class="line">                <span class="comment">// 否则 cand 就不可能是名人</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">knows</span>(cand, other) || !<span class="built_in">knows</span>(other, cand)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (other == n) &#123;</span><br><span class="line">                <span class="comment">// 找到名人</span></span><br><span class="line">                <span class="keyword">return</span> cand;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有一个人符合名人特性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2优化 <span class="number">1</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将所有候选人装进队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一直排除，直到只剩下一个候选人停止循环</span></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次取出两个候选人，排除一个</span></span><br><span class="line">            <span class="type">int</span> cand = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> other = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">knows</span>(cand, other) || !<span class="built_in">knows</span>(other, cand)) &#123;</span><br><span class="line">                <span class="comment">// cand 不可能是名人，排除，让 other 归队</span></span><br><span class="line">                q.<span class="built_in">push</span>(other);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// other 不可能是名人，排除，让 cand 归队</span></span><br><span class="line">                q.<span class="built_in">push</span>(cand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在排除得只剩一个候选人，判断他是否真的是名人</span></span><br><span class="line">        <span class="type">int</span> cand = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> other = <span class="number">0</span>; other &lt; n; other++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other == cand) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证其他人都认识 cand，且 cand 不认识任何其他人</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cand 是名人</span></span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T3优化 <span class="number">2</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cand = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> other = <span class="number">1</span>; other &lt; n; other++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) &#123;</span><br><span class="line">                <span class="comment">// cand 不可能是名人，排除</span></span><br><span class="line">                <span class="comment">// 假设 other 是名人</span></span><br><span class="line">                cand = other;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// other 不可能是名人，排除</span></span><br><span class="line">                <span class="comment">// 什么都不用做，继续假设 cand 是名人</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在的 cand 是排除的最后结果，但不能保证一定是名人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> other = <span class="number">0</span>; other &lt; n; other++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cand == other) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 需要保证其他人都认识 cand，且 cand 不认识任何其他人</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、二分图判定">3、二分图判定</h3>
<ul>
<li>二分图的定义：二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/eft-1.png" alt="二分图"><br>
给你一幅「图」，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同，你能做到吗？<br>
这就是图的「双色问题」，其实这个问题就等同于二分图的判定问题，如果你能够成功地将图染色，那么这幅图就是一幅二分图，反之则不是：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/eft-2.jpg" alt="双色问题"></li>
</ul>
<p><strong>说白了就是遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同</strong>。</p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-graph-bipartite/description/">785. 判断二分图</a></li>
<li>有 DFS、BFS 两种写法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; color;  <span class="comment">// 0 未上色 1 红色 2 蓝色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分图算法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        color.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">// 所有子图需要都能满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; flag; i++)</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                color[i] = <span class="number">1</span>;   <span class="comment">// 第一个染色为 1</span></span><br><span class="line">                <span class="built_in">dfs</span>(graph, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历子图 DFS</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; G, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : G[start])&#123;</span><br><span class="line">            <span class="comment">// 若未上色，上不同色</span></span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                color[i] = color[start]==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(G, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若已上色，判断是否满足条件</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[i] == color[start])</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; color;  <span class="comment">// 0 未上色 1 红色 2 蓝色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分图算法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        color.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">// 所有子图需要都能满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; flag; i++)</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                color[i] = <span class="number">1</span>;   <span class="comment">// 第一个染色为 1</span></span><br><span class="line">                <span class="built_in">bfs</span>(graph, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历子图 BFS</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; G, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(start);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>() &amp;&amp; flag)&#123;</span><br><span class="line">            <span class="type">int</span> cur = Q.<span class="built_in">front</span>();  Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i : G[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    color[i] = color[cur]==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(color[i]==color[cur])</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参考题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/possible-bipartition/description/">886. 可能的二分法</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; color;  <span class="comment">// 0未染色 1 蓝 2 红</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        color.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        G.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">// 构建图(不喜欢的人连接在一起，后面染色成不同即可)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p : dislikes)&#123;</span><br><span class="line">            <span class="type">int</span> a = p[<span class="number">0</span>]<span class="number">-1</span>, b = p[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            G[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始染色</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; flag; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                color[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : G[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                color[i] = color[start]==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[i]==color[start])</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、Union-Find-并查集">4、Union-Find 并查集</h3>
<ul>
<li>并查集（Union-Find）算法是一个专门针对「动态连通性」的算法。</li>
<li>动态连通性<br>
「连通」是一种等价关系（自反、对称、传递）<br>
连通性、连通分量。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/uf-1.jpg" alt="连通性"></li>
<li>我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</li>
<li>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。</li>
<li>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上。</li>
<li>如果节点 p 和 q 连通的话，它们一定拥有相同的根节点。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/uf-2.jpg" alt="两个节点连通"><br>
下面是基本的版本：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，n 为图的节点总数</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回某个节点 x 的根节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">            x = parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前的连通分量个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">// parent[rootQ] = rootP 也一样</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个分量合二为一</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于可能不太平衡，每个树可能会退化成为一个链表，那么时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>下面是平衡性优化：<br>
我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些。解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，我们不妨称为「重量」。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">        <span class="comment">// 重量应该初始化 1</span></span><br><span class="line">        size.<span class="built_in">resize</span>(n); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>树的高度大致在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 这个数量级，极大提升执行效率。<br>
此时，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>下面，还可以进行路径压缩：<br>
其实我们并不在乎每棵树的结构长什么样，只在乎根节点。因为无论树长啥样，树上的每个节点的根节点都是相同的，所以能不能进一步压缩每棵树的高度，使树高始终保持为常数？<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/uf-3.jpg" alt="路径压缩"></p>
<p>这样每个节点的父节点就是整棵树的根节点，<code>find</code> 就能以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。<br>
如果使用路径压缩技巧，那么 size 数组的平衡优化就没有必要了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="type">int</span> _count;</span><br><span class="line">    <span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">    <span class="built_in">UF</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        _count = n;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        _count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="type">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终优化</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Union-Find 算法的复杂度可以这样分析：</p>
<ul>
<li>
<p>构造函数初始化数据结构需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间和空间复杂度；</p>
</li>
<li>
<p>连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/?show=1">547. 省份数量</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">// 初始全不通，每个人根节点为自己</span></span><br><span class="line">        count = n;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 背下来</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[a] != a)</span><br><span class="line">            parent[a] = <span class="built_in">find</span>(parent[a]);</span><br><span class="line">        <span class="keyword">return</span> parent[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ap = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> bp = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(ap != bp)&#123;</span><br><span class="line">            parent[ap] = bp;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ap = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> bp = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">return</span> ap == bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 连通分量的求解</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UnionFind <span class="title">UF</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j])</span><br><span class="line">                    UF.<span class="built_in">union_</span>(i, j);</span><br><span class="line">        <span class="keyword">return</span> UF.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多参考题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-tree-nodes/description/?show=1">1361. 验证二叉树</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/?show=1">200. 岛屿数量</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/graph-valid-tree/description/?show=1">*261. 以图判树</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-height-trees/description/?show=1">310. 最小高度树</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-divisible-subset/description/?show=1">368. 最大整除子集</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/?show=1">547. 省份数量</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kill-process/description/?show=1">*582. 杀掉进程</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sentence-similarity-ii/description/?show=1">*737. 句子相似性 II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/description/?show=1">947. 移除最多的同行或同列石头</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/couples-holding-hands/description/?show=1">765. 情侣牵手</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-malware-spread/description/?show=1">924. 尽量减少恶意软件的传播</a></li>
</ul>
<h3 id="5、Kruskal-MST最小生成树（并查集-排序贪心）">5、Kruskal MST最小生成树（并查集+排序贪心）</h3>
<ul>
<li>
<p>最小生成树算法主要有 Prim 算法（普里姆算法）和 Kruskal 算法（克鲁斯卡尔算法）两种，这两种算法虽然都运用了贪心思想，但从实现上来说差异还是蛮大的。</p>
</li>
<li>
<p>最小生成树</p>
<ul>
<li>先说「树」和「图」的根本区别：<strong>树不会包含环，图可以包含环</strong>。</li>
<li>如果一幅图没有环，完全可以拉伸成一棵树的模样。说的专业一点，<strong>树就是「无环连通图」</strong>。</li>
<li><strong>生成树</strong>是含有图中所有顶点的「无环连通子图」。</li>
<li>那么最小生成树很好理解了，所有可能的生成树中，权重和最小的那棵生成树就叫「<strong>最小生成树</strong>」。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-1.png" alt="生成树"></li>
</ul>
</li>
<li>
<p>Kruskal 算法的一个难点是保证生成树的合法性，因为在构造生成树的过程中，你首先得保证生成的那玩意是棵树（不包含环）对吧，那么 Union-Find 算法就是帮你干这个事儿的。</p>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/graph-valid-tree/description/">261. 以图判树</a></p>
</li>
<li>
<p>给你输入编号从 <code>0</code> 到 <code>n-1</code> 的 <code>n</code> 个结点，和一个无向边列表 <code>edges</code>（每条边用节点二元组表示），请你判断输入的这些边组成的结构是否是一棵树。</p>
</li>
<li>
<p>我们可以思考一下，<strong>什么情况下加入一条边会使得树变成图（出现环）</strong>？</p>
</li>
<li>
<p>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；</p>
</li>
<li>
<p>反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环。</p>
</li>
<li>
<p>判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活。</p>
</li>
<li>
<p>Kruskal 算法<br>
所谓最小生成树，就是图中若干边的集合<code>mst</code>，你要保证这些边：</p>
<ol>
<li>包含图中的所有节点。</li>
<li>形成的结构是树结构（即不存在环）。</li>
<li>权重和最小。<br>
关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的：<br>
贪心思路：<strong>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 mst 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 mst 集合；否则，这条边不是最小生成树的一部分，不要把它加入 mst 集合</strong>。</li>
</ol>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/description/">1135. 最低成本联通所有城市</a></p>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584. 连接所有点的最小费用</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先实现并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">// 最初全独立，自己指自己</span></span><br><span class="line">        count = n;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[a] != a)</span><br><span class="line">            parent[a] = <span class="built_in">find</span>(parent[a]);</span><br><span class="line">        <span class="keyword">return</span> parent[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">union_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ap = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> bp = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(ap != bp)&#123;</span><br><span class="line">            parent[ap] = bp;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ap = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> bp = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">return</span> ap == bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 把所有可能的边生成，且按权重排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="type">int</span> d = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">                edges.<span class="built_in">push_back</span>(&#123;i, j, d&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; B)&#123;</span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">2</span>] &lt; B[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照从小到大把还没连通的边加入</span></span><br><span class="line">        <span class="function">UnionFind <span class="title">UF</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> mst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="type">int</span> i = e[<span class="number">0</span>], j = e[<span class="number">1</span>], d = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(!UF.<span class="built_in">connected</span>(i, j))&#123;</span><br><span class="line">                UF.<span class="built_in">union_</span>(i, j);</span><br><span class="line">                mst += d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若已经全部连完，可以提前结束</span></span><br><span class="line">            <span class="keyword">if</span>(UF.<span class="built_in">size</span>() == <span class="number">1</span>)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最小总权重</span></span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Kruskal 算法，主要的难点是利用 Union-Find 并查集算法向最小生成树中添加边，配合排序的贪心思路，从而得到一棵权重之和最小的生成树。<br>
空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E+V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span><br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E\log E + E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 主要是排序的时间。</p>
<h3 id="6、Prim-MST最小生成树（BFS-切分贪心）">6、Prim MST最小生成树（BFS+切分贪心）</h3>
<blockquote>
<p>Kruskal 和 Prim 都是最小生成树的算法，两种算法的时间复杂度是一样的。会使用一个即可。<br>
推荐使用前面的 Kruskal 即可，因为就是结合并查集 UF + 权重排序贪心即可。<br>
这里的话需要重新理解，因此作为理解即可，实战使用前面的算法。</p>
</blockquote>
<ul>
<li>
<p>切分定理：</p>
<ul>
<li>「切分」就是将一幅图分为两个不重叠且非空的节点集合。</li>
<li>对于任意一种「切分」，其中权重最小的那条「横切边」一定是构成最小生成树的一条边。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-2.jpeg" alt="切分定理"><br>
<strong>既然每一次「切分」一定可以找到最小生成树中的一条边，那我就随便切呗，每次都把权重最小的「横切边」拿出来加入最小生成树，直到把构成最小生成树的所有边都切出来为止</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-3.jpeg" alt="切分1"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-4.jpeg" alt="切分2"><br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-5.jpeg" alt="切分3"><br>
Prim 算法的逻辑就是这样，每次切分都能找到最小生成树的一条边，然后又可以进行新一轮切分，直到找到最小生成树的所有边为止。<br>
同时，注意计算有方法：<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/mst-6.jpeg" alt="横切边的更新选取"></li>
</ul>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost/description/">1135. 最低成本联通所有城市</a></p>
</li>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584. 连接所有点的最小费用</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;list&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; graph = <span class="built_in">buildGraph</span>(n, points);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Prim</span>(graph).<span class="built_in">weightSum</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">buildGraph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points) &#123;</span><br><span class="line">        vector&lt;list&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="comment">// 生成所有边及权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> xi = points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> xj = points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> weight = <span class="built_in">abs</span>(xi - xj) + <span class="built_in">abs</span>(yi - yj);</span><br><span class="line">                <span class="comment">// 用 points 中的索引表示坐标点</span></span><br><span class="line">                graph[i].<span class="built_in">push_back</span>(&#123;i, j, weight&#125;);</span><br><span class="line">                graph[j].<span class="built_in">push_back</span>(&#123;j, i, weight&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 核心数据结构，存储「横切边」的优先级队列</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, function&lt;<span class="type">bool</span>(vector&lt;<span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;)&gt;&gt; pq;</span><br><span class="line">    <span class="comment">// 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; inMST;</span><br><span class="line">    <span class="comment">// 记录最小生成树的权重和</span></span><br><span class="line">    <span class="type">int</span> weightSum_ = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// graph 是用邻接表表示的一幅图，</span></span><br><span class="line">    <span class="comment">// graph[s] 记录节点 s 所有相邻的边，</span></span><br><span class="line">    <span class="comment">// 三元组 int[]&#123;from, to, weight&#125; 表示一条边</span></span><br><span class="line">    vector&lt;list&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Prim</span>(vector&lt;list&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;&amp; graph) : <span class="built_in">graph</span>(graph), </span><br><span class="line">        <span class="built_in">pq</span>([](vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b) &#123;</span><br><span class="line">            <span class="comment">// 按照边的权重从小到大排序</span></span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] &gt; b[<span class="number">2</span>]; </span><br><span class="line">        &#125;) &#123;</span><br><span class="line">        <span class="comment">// 图中有 n 个节点</span></span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;inMST.<span class="built_in">resize</span>(n, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随便从一个点开始切分都可以，我们不妨从节点 0 开始</span></span><br><span class="line">        inMST[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cut</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 不断进行切分，向最小生成树中添加边</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; edge = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (inMST[to]) &#123;</span><br><span class="line">                <span class="comment">// 节点 to 已经在最小生成树中，跳过</span></span><br><span class="line">                <span class="comment">// 否则这条边会产生环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将边 edge 加入最小生成树</span></span><br><span class="line">            weightSum_ += weight;</span><br><span class="line">            inMST[to] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 节点 to 加入后，进行新一轮切分，会产生更多横切边</span></span><br><span class="line">            <span class="built_in">cut</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 s 的横切边加入优先队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历 s 的邻边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph[s]) &#123;</span><br><span class="line">            <span class="type">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (inMST[to]) &#123;</span><br><span class="line">                <span class="comment">// 相邻接点 to 已经在最小生成树中，跳过</span></span><br><span class="line">                <span class="comment">// 否则这条边会产生环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入横切边队列</span></span><br><span class="line">            pq.<span class="built_in">push</span>(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小生成树的权重和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">weightSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weightSum_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最小生成树是否包含图中的所有节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">allConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">bool</span> connected : inMST) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(E\log E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<h3 id="7、Dijkstra-单源最短路径">7、Dijkstra 单源最短路径</h3>
<blockquote>
<p>Dijkstra 算法是一种用于计算图中单源最短路径的算法，本质上是一个经过特殊改造的 BFS 算法，改造点有两个：</p>
<ol>
<li>使用 优先级队列，而不是普通队列进行 BFS 算法。</li>
<li>添加了一个备忘录，记录起点到每个可达节点的最短路径权重和。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/graph/Dij-1.jpeg" alt="更新最短路径"></li>
</ol>
</blockquote>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/description/?show=1">743. 网络延迟时间</a></li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li><code>distTo[id]</code> 永远维护到达 <code>id</code> 节点的最小距离。</li>
<li>而 <code>State</code> 里面那个 <code>distFromStart</code>，维护的是 <code>State.id</code> 这个节点<strong>入队时</strong>距离起点的距离。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> distFromStart;</span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> i, <span class="type">int</span> d): <span class="built_in">id</span>(i), <span class="built_in">distFromStart</span>(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> State&amp; a, <span class="type">const</span> State&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.distFromStart &gt; b.distFromStart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// distTo[i] 表示从 start 到 i 的最小路径，动态更新</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; distTo; </span><br><span class="line">    <span class="comment">// 优先队列，把目前节点按照距离start更近排序</span></span><br><span class="line">    priority_queue&lt;State, vector&lt;State&gt;, <span class="keyword">decltype</span>(cmp)&gt; PQ;</span><br><span class="line">    <span class="comment">// 邻接矩阵，含距离</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单源最短路径，再看最大的</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; times, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转为邻接矩阵</span></span><br><span class="line">        G.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;times.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> from = times[i][<span class="number">0</span>]<span class="number">-1</span>, to = times[i][<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            G[from][to] = times[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算start到所有点的最短</span></span><br><span class="line">        distTo.<span class="built_in">resize</span>(n, INT_MAX);</span><br><span class="line">        distTo[k<span class="number">-1</span>] = <span class="number">0</span>;    <span class="comment">// 从起始节点出发</span></span><br><span class="line">        PQ.<span class="built_in">push</span>(<span class="built_in">State</span>(k<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!PQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 取出一个路程最短的，用来更新他可达的下一跳的最短</span></span><br><span class="line">            State cur = PQ.<span class="built_in">top</span>();  PQ.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> cid = cur.id, cdist = cur.distFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前距离大于已知最短距离，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (cdist &gt; distTo[cid]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>; v&lt;n; v++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(G[cid][v] != INT_MAX)&#123;</span><br><span class="line">                    <span class="type">int</span> path = cdist + G[cid][v];</span><br><span class="line">                    <span class="keyword">if</span>(path &lt; distTo[v])&#123;</span><br><span class="line">                        distTo[v] = path;</span><br><span class="line">                        PQ.<span class="built_in">push</span>(<span class="built_in">State</span>(v, path));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大值就是答案</span></span><br><span class="line">        <span class="type">int</span> maxT = *<span class="built_in">max_element</span>(distTo.<span class="built_in">begin</span>(), distTo.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> maxT==INT_MAX ? <span class="number">-1</span> : maxT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他题目：<br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/description/?show=1">1514. 概率最大的路径</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/description/?show=1">1631. 最小体力消耗路径</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-height-trees/description/?show=1">310. 最小高度树</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/01-matrix/description/?show=1">542. 01 矩阵</a><br>
<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/?show=1">329. 矩阵中的最长递增路径</a></li>
</ul>
<h1>第二章、经典暴力搜索算法</h1>
<h2 id="一-DFS、回溯">(一) DFS、回溯</h2>
<p>待完成…</p>
<h2 id="二-BFS">(二) BFS</h2>
<p>待完成…</p>
<h1>第三章、经典动态规划算法</h1>
<h2 id="一-基本技巧">(一) 基本技巧</h2>
<p>待完成…</p>
<h2 id="二-子序列类型">(二) 子序列类型</h2>
<p>待完成…</p>
<h2 id="三-背包类型">(三) 背包类型</h2>
<blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>dp 定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-1背包</td>
<td><code>dp[i][j]</code> 表示在前 i 个物品、背包容量 j 时，能够达到的最大价值</td>
</tr>
<tr>
<td>子集背包</td>
<td><code>dp[i][j]</code> 表示在前 i 个物品、凑成 j 大小，能否完成</td>
</tr>
<tr>
<td>完全背包</td>
<td><code>dp[i][j]</code> 表示在前 i 个物品、凑成 j 大小，能有多少种</td>
</tr>
</tbody>
</table>
<p>三个的递推公式分别如下：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>  </mtext><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>W</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>V</mi><mi>a</mi><mi>l</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]\ =\ max(dp[i-1][j],\ \ dp[i-1][j-Wt[i-1]]+Val[i-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext>  </mtext><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mtext>  </mtext><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]\ =\ dp[i-1][j]\ \ ||\ \ dp[i-1][j-nums[i-1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">∣∣</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mtext> </mtext><mo>+</mo><mtext> </mtext><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]\ =\ dp[i-1][j]\ +\ dp[i][j-nums[i-1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]]</span></span></span></span><br>
尤其注意，最后一个是充分利用前面的计算信息，甚至利用了本层<code>i</code>刚刚计算的信息！</p>
</blockquote>
<h3 id="1、0-1-背包">1、0-1 背包</h3>
<blockquote>
<p>背包问题的 dp 数组定义：<br>
<code>dp[i][w]</code> 的定义如下：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code>。</p>
<ul>
<li>比如说，如果 <code>dp[3][5] = 6</code>，其含义为：对于给定的一系列物品中，若只从前 <code>3</code> 个物品中选择，当背包容量为 <code>5</code> 时，最多可以装下的价值为 <code>6</code>。</li>
<li>最终答案就是 <code>dp[N][W]</code></li>
<li><code>base case</code> 就是 <code>dp[0][..] = dp[..][0] = 0</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">    <span class="keyword">for</span> w in [<span class="number">1.</span>.W]:</span><br><span class="line">        dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">            dp[i<span class="number">-1</span>][w], <span class="comment">// 把物品 i 装进背包</span></span><br><span class="line">            dp[i<span class="number">-1</span>][w - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>] <span class="comment">//不把物品 i 装进背包</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-1背包问题，重量，价值，背包容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">zeroOneBag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; Wt, vector&lt;<span class="type">int</span>&gt;&amp; Val, <span class="type">int</span> cap)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = Wt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// dp[i][j] 表示从前i个物品中选，容量为j时，能达到的最大价值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cap; i++)  dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自底向上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>; w&lt;=cap; w++)&#123;</span><br><span class="line">            <span class="comment">// 不能装</span></span><br><span class="line">            <span class="keyword">if</span>(Wt[i<span class="number">-1</span>] &gt; w)  dp[i][w] = dp[i<span class="number">-1</span>][w];</span><br><span class="line">            <span class="comment">// 能装</span></span><br><span class="line">            <span class="keyword">else</span>  dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">                dp[i<span class="number">-1</span>][w], </span><br><span class="line">                dp[i<span class="number">-1</span>][w-Wt[i<span class="number">-1</span>]] + Val[i<span class="number">-1</span>]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回答案</span></span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参考题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/?show=1">3180. 执行操作可获得的最大总奖励 I</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTotalReward</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rewardValues)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = rewardValues.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 排序(因为一定是从小到大的取值)</span></span><br><span class="line">        <span class="built_in">sort</span>(rewardValues.<span class="built_in">begin</span>(), rewardValues.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> m = <span class="number">2</span> * rewardValues[n<span class="number">-1</span>] - <span class="number">1</span>;   <span class="comment">// 无论如何，最大总奖励只能是最大元素的 2 倍 - 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][j] 表示从前 i 个物品选择，能否达到总奖励 j</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)  dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">                <span class="type">int</span> jd = j - rewardValues[i<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// 选当前物品：满足 1.有更小的总奖励 2.当前物品奖励 大于 总奖励</span></span><br><span class="line">                <span class="keyword">if</span>(jd &gt;= <span class="number">0</span> &amp;&amp; rewardValues[i<span class="number">-1</span>] &gt; jd)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][jd];</span><br><span class="line">                <span class="comment">// 不选当前物品</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 dp[n][j] 里面的最大的 j 就是答案</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=m; j++)  <span class="keyword">if</span>(dp[n][j])  ans = j;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2、子集背包">2、子集背包</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></li>
<li>输入一个只包含正整数的非空数组 <code>nums</code>，请你写一个算法，判断这个数组是否可以被分割成两个子集，使得两个子集的元素和相等。</li>
<li>为什么说是背包问题？<br>
给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质是背包问题，即能否装满背包 sum/2</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必须偶数</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 个物品，能否凑成 j 大小</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)  dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">                <span class="type">int</span> ok = j-nums[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ok&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i<span class="number">-1</span>][ok];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>dp[i][j]</code> 都是通过上一行 <code>dp[i-1][..]</code> 转移过来的，之前的数据都不会再使用了。<br>
优化：（唯一需要注意的是 j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 本质是背包问题，即能否装满背包 sum/2</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m; j&gt;=<span class="number">0</span>; j--)&#123;    <span class="comment">// 反过来</span></span><br><span class="line">                <span class="type">int</span> ok = j-nums[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ok&gt;=<span class="number">0</span>)  dp[j] = dp[j] || dp[ok];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、完全背包">3、完全背包</h3>
<ul>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II</a></p>
</li>
<li>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。<br>
假设每一种面额的硬币有无限个。</p>
</li>
<li>
<p>有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？</p>
</li>
<li>
<p>暴力：实际上无非需要多次选用硬币。</p>
</li>
<li>
<p>优化：但是只需要修改一处，就可以不用浪费遍历，你要做的只是利用前面已经用过这个新硬币的结果！</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">暴力：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 种物品，凑出 j 的方法数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(amount+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=amount; j++)  dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=amount; j++)&#123;</span><br><span class="line">                <span class="type">int</span> coin = coins[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> ok=j; ok &gt;= <span class="number">0</span>; ok-=coin)</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][ok];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">优化：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 种物品，凑出 j 的方法数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++)  dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=amount; j++)  dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=amount; j++)&#123;</span><br><span class="line">                <span class="type">int</span> ok = j-coins[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ok &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][ok]; <span class="comment">// 注意这里不是 dp[i-1][ok]</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、目标和">4、目标和</h3>
<blockquote>
<p>我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。<br>
那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。</p>
</blockquote>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a></li>
<li>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</li>
<li>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <code>表达式</code> ：
<ul>
<li>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。<br>
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</li>
</ul>
</li>
</ul>
<p>显然可以使用回溯法，就是每层选择就行了。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">回溯法：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 回溯法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前选择 k ，剩余需要凑成 remain</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> remain, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(k == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)  ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择本层，并进入下层</span></span><br><span class="line">        <span class="comment">// 选择1. 加</span></span><br><span class="line">        remain -= nums[k];</span><br><span class="line">        <span class="built_in">backtrace</span>(nums, remain, k+<span class="number">1</span>);</span><br><span class="line">        remain += nums[k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择2. 减</span></span><br><span class="line">        remain += nums[k];</span><br><span class="line">        <span class="built_in">backtrace</span>(nums, remain, k+<span class="number">1</span>);</span><br><span class="line">        remain -= nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。回溯算法遍历递归树的过程中，也有可能出现相同的子树，我们也可以提前识别并避免重复遍历这些子树，从而提高效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; memo;    <span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 动态规划备忘录</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(nums, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp(i, remain) 表示从 nums[i..] 选出达到 remain 的方法数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> remain)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(i == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本层计算</span></span><br><span class="line">        <span class="comment">// 算前先看是否算过了</span></span><br><span class="line">        string cur = <span class="built_in">to_string</span>(i) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">to_string</span>(remain);</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(cur) != memo.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> memo[cur];</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain-nums[i]) + <span class="built_in">dp</span>(nums, i+<span class="number">1</span>, remain+nums[i]);</span><br><span class="line">        memo[cur] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……</p>
<p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum(A) - sum(B) = target</span><br><span class="line">sum(A) = target + sum(B)</span><br><span class="line">sum(A) + sum(A) = target + sum(B) + sum(A)</span><br><span class="line">2 * sum(A) = target + sum(nums)</span><br></pre></td></tr></table></figure>
<p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：<code>nums</code> 中存在几个子集 <code>A</code>，使得 <code>A</code> 中元素的和为 <code>(target + sum(nums)) / 2</code>？</p>
<ul>
<li>变成背包问题的标准形式：<br>
有一个背包，容量为 <code>sum</code>，现在给你 <code>N</code> 个物品，第 <code>i</code> 个物品的重量为 <code>nums[i - 1]</code>（注意 <code>1 &lt;= i &lt;= N</code>），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数学发现：就是凑成 (target+sum) / 2 的子集数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> TS = target + sum;</span><br><span class="line">        <span class="comment">// 必须非负，必须偶数</span></span><br><span class="line">        <span class="keyword">if</span>(TS&lt;<span class="number">0</span> || TS%<span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> <span class="built_in">subNum</span>(nums, TS/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 nums 中选出子集达到 target 有多少种(全是正整数或 0)</span></span><br><span class="line">    <span class="comment">// 这个肯定是可以用回溯的，但是千万别！要不然这个数学规律你也是发现了</span></span><br><span class="line">    <span class="comment">// 应该使用动态规划，才能优化时间！！！</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// dp[i][j] 从前 i 个元素选出达到和为 j 的方法数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;=n; i++)  dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">// for(int j=1; j&lt;=target; j++)  dp[0][j] = 0;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 由于有 0 的存在，必须这样写（因为可能会更新后面的和为 0 的情况）</span></span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=target; j++)&#123;</span><br><span class="line">                <span class="type">int</span> ok = j-nums[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ok &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][ok];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-游戏类型">(四) 游戏类型</h2>
<p>待完成…</p>
<h2 id="五-贪心类型">(五) 贪心类型</h2>
<h3 id="1、解题框架">1、解题框架</h3>
<p>请见前文：第零章-贪心算法</p>
<ul>
<li>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
</li>
<li>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
</li>
<li>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
</li>
</ul>
<h3 id="2、老司机加油算法">2、老司机加油算法</h3>
<ul>
<li>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/">134. 加油站</a></p>
</li>
<li>
<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
</li>
<li>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
</li>
<li>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 保证 它是 唯一 的。</p>
</li>
<li>
<p>解法 1：暴力把每个站点试一遍<br>
注意，肯定是无法通过动态规划优化的，因为动态规划这里的状态是两个变量（站点、剩余汽油数），那和暴力的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的复杂度是一样的。<br>
所以说这道题肯定不是通过简单的剪枝来优化暴力解法的效率（动态规划），而是需要我们发现一些隐藏较深的规律，从而减少一些冗余的计算。</p>
</li>
<li>
<p>解法 2：画图，把每过一站的实际变化计算出来 <code>change[i] = gas[i]-cost[i]</code>。那我们就是希望找到一个位置，是一直是正数的即可。那就是在最低点开始！</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tx/tx-1.jpeg" alt="画图"></p>
<ul>
<li>解法 3：贪心。如果选择站点 <code>i</code> 作为起点，走到站点 <code>j</code> 时发现变负数了，那么 <code>i</code> 和 <code>j</code> 中间的任意站点 <code>k</code> 都不可能作为起点，因为他们走到 <code>j</code> 都会变成负数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">T1:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 暴力解法：从每个出发点都试一遍</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="number">0</span>;    <span class="comment">// 当前汽油量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="type">int</span> p = (i+j)%n;    <span class="comment">// 当前位置</span></span><br><span class="line">                cur += gas[p] - cost[p];</span><br><span class="line">                <span class="keyword">if</span>(cur &lt; <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T2:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 暴力解法：从每个出发点都试一遍</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 计算每一站的收益、亏损</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">-1</span>, lowSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= lowSum)&#123;</span><br><span class="line">                <span class="comment">// 这站一过会进入最低，那么从下一站为起点出发</span></span><br><span class="line">                low = (i+<span class="number">1</span>)%n;</span><br><span class="line">                lowSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 sum 负数，显然是不能完成</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">T3：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心， i 走到 j 时刚刚变成负数，那么i-j的全部不会是起点，他们走到 j 都会变成负数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 总和负数，肯定失败</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)  sum += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照贪心方法走</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> startSum = <span class="number">0</span>;   <span class="comment">// 从 start 开始走的 sum</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            startSum += gas[i] - cost[i];</span><br><span class="line">            <span class="comment">// 若发现负数了，那么认为从下一站开始走</span></span><br><span class="line">            <span class="keyword">if</span>(startSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">                startSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> start % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3、区间调度问题">3、区间调度问题</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/">435. 无重叠区间</a></li>
<li>给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。</li>
<li>做法：按照结束时间排序，然后依次筛选。</li>
</ul>
<blockquote>
<p>区间问题肯定按照区间的起点或者终点进行排序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心：区间调度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 按照结束时间排序，从小到大</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;    <span class="comment">// 至少第一个肯定可以</span></span><br><span class="line">        <span class="type">int</span> curEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= curEnd)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                curEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 答案(要移除的个数)</span></span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452. 用最少数量的箭引爆气球</a></li>
</ul>
<p>下面两种写法，实际上是一样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心：区间调度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 这次按照开始位置排序，从小到大</span></span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// 先选第一个气球</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> curEnd = points[<span class="number">0</span>][<span class="number">1</span>];  <span class="comment">// 保证第一个球要能被射中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> s = points[i][<span class="number">0</span>], e = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 只要气球在末尾之内，那就一起射</span></span><br><span class="line">            <span class="keyword">if</span>(s &lt;= curEnd)&#123;</span><br><span class="line">                curEnd = <span class="built_in">min</span>(curEnd, e);    <span class="comment">// 注意更新末尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 末尾不够了，开始新的一箭</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                curEnd = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 贪心：可以直接按照结束早晚排序（认为每次就卡在最后的位置进行射击）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; end)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4、扫描线技巧-安排会议室">4、扫描线技巧-安排会议室</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/description/">253. 会议室 II</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/920/">炼码：920. 会议室1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/919/">炼码：919. 会议室2</a></li>
<li>给你输入若干形如 <code>[begin, end]</code> 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。</li>
<li>换句话说，如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间，仅此而已。</li>
</ul>
<blockquote>
<p>首先，差分数组是可以解决这个问题的，就是把每个时间都看做一个点，给每个区间进行加+1，最后看哪个点的数字最大，就是所需要的会议室数量了。</p>
<p>这个方法所需要的数组太大了，下面看别的方法。</p>
</blockquote>
<p>基于差分数组的思路，我们可以推导出一种更高效，更优雅的解法。</p>
<ol>
<li>我们首先把这些会议的时间区间进行投影：红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。</li>
<li>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到<strong>红色</strong>的点，计数器 <code>count</code> 加一，每遇到<strong>绿色</strong>的点，计数器 <code>count</code> 减一。<br>
这样一来，每个时刻有多少个会议在同时进行，就是计数器 <code>count</code> 的值，<code>count</code> 的最大值，就是需要申请的会议室数量。<br>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/algorithm/labuladong/tx/sm-1.jpeg" alt="差分数组衍生技巧"></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">start</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">end</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            start[i] = intervals[i].start;</span><br><span class="line">            end[i] = intervals[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 各自从小到大排序</span></span><br><span class="line">        <span class="built_in">sort</span>(start.<span class="built_in">begin</span>(), start.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(end.<span class="built_in">begin</span>(), end.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 扫描计算即可(双指针)</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="comment">// 下一个点是开始点/结束点？</span></span><br><span class="line">            <span class="comment">// 开始点</span></span><br><span class="line">            <span class="keyword">if</span>(start[i] &lt; end[j])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结束点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5、视频剪辑">5、视频剪辑</h3>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/video-stitching/description/">1024. 视频拼接</a></li>
<li>区间问题肯定按照区间的起点或者终点进行排序。</li>
</ul>
<blockquote>
<p>这题的细节问题，卡得我叫苦不迭。<br>
这里的两层循环的关于 i 是否增加的设计，要细细琢磨。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照起点升序，相同起点，结束点降序</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 按照起点排序</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; clips, <span class="type">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = clips.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(clips.<span class="built_in">begin</span>(), clips.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// 起始一定要有 0</span></span><br><span class="line">        <span class="keyword">if</span>(clips[<span class="number">0</span>][<span class="number">0</span>] &gt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curEnd = <span class="number">0</span>;   <span class="comment">// 表示当前拼接好的结束位置，在这个范围内，可以一直挑选下一个片段</span></span><br><span class="line">        <span class="type">int</span> nxtEnd = <span class="number">0</span>;   <span class="comment">// 表示挑选的下一个判断的末尾位置，还没拼接上来，正在待选</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; clips[i][<span class="number">0</span>]&lt;=curEnd)&#123;</span><br><span class="line">            <span class="comment">// 在范围内挑选</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;n &amp;&amp; clips[i][<span class="number">0</span>]&lt;=curEnd)&#123;</span><br><span class="line">                nxtEnd = <span class="built_in">max</span>(nxtEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挑完了，开始拼接</span></span><br><span class="line">            cnt++;</span><br><span class="line">            curEnd = nxtEnd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成</span></span><br><span class="line">            <span class="keyword">if</span>(curEnd &gt;= time)</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>第四章、其他常见算法技巧</h1>
<h2 id="一-数学运算技巧">(一) 数学运算技巧</h2>
<p>待完成…</p>
<h2 id="二-经典面试题">(二) 经典面试题</h2>
<p>待完成…</p>
</div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">isSeymour</div><div class="author-info__description">志之所趋，无远弗届，穷山距海，不能限也。</div></div><div class="card-info-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/isSeymour/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://isSeymour.github.io/profile/" target="_blank" title="学术主页"><i class="fa-regular fa-address-card" style="color: #000000;"></i></a><a class="social-icon" href="https://github.com/isSeymour/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/79699613/" target="_blank" title="B站"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_63205991/" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #000000;"></i></a><a class="social-icon" href="mailto:isSeymour@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">前言：标准模板库 STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector"><span class="toc-text">1. vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-stack"><span class="toc-text">2. stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-queue"><span class="toc-text">3. queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-deque"><span class="toc-text">4. deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-unordered-set"><span class="toc-text">5. unordered_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-unordered-map"><span class="toc-text">6. unordered_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-priority-queue"><span class="toc-text">7. priority_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-string"><span class="toc-text">8. string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81list"><span class="toc-text">9、list</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BF%83%E5%BE%97"><span class="toc-text">算法与心得</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-algorithm"><span class="toc-text">1. algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-cmath"><span class="toc-text">2. cmath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%85%E5%A4%87%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 必备实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BF%83%E5%BE%97%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%A4%B1%E8%AF%AF%E6%80%BB%E7%BB%93"><span class="toc-text">4. 心得操作与失误总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">基础：数据结构及排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%EF%BC%89"><span class="toc-text">(一) 数组（静态、动态）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E3%80%81%E5%8F%8C%EF%BC%89"><span class="toc-text">(二) 链表（单、双）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8F%98%E7%A7%8D%EF%BC%9A%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E3%80%81%E8%B7%B3%E8%A1%A8"><span class="toc-text">(三) 变种：环形数组、跳表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E9%98%9F%E5%88%97%E3%80%81%E6%A0%88%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-text">(四) 队列、栈、双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%E3%80%81%E5%8A%A0%E5%BC%BA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">(五) 哈希表、哈希集合、加强哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">(六) 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1. 满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">2. 完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">3. 平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">4. 二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-DFS"><span class="toc-text">5. 递归遍历(DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-BFS"><span class="toc-text">6. 层序遍历(BFS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-text">(七) 多叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-text">1. 递归遍历（DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-text">2. 层序遍历（BFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%98%E7%A7%8D"><span class="toc-text">(八) 二叉树变种</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">1. 二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">2. 红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Tire-%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">3. Tire(字典树&#x2F;前缀树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-text">4. 二叉堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">5. 线段树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%9B%BE%E8%AE%BA"><span class="toc-text">(九) 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="toc-text">1. 图结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">2. 图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">3. 并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F"><span class="toc-text">(十) 十大排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E8%A7%A3%E5%86%B3%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-text">2. 冒泡排序（解决稳定）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%86%E5%90%91%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%89"><span class="toc-text">3. 插入排序（逆向提高效率）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AA%81%E7%A0%B4n-2%EF%BC%89"><span class="toc-text">4. 希尔排序（突破n^2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">5. 快速排序（二叉树前序位置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">6. 归并排序（二叉树后序位置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E8%BF%90%E7%94%A8%E4%BA%8C%E5%8F%89%E5%A0%86%EF%BC%89"><span class="toc-text">7. 堆排序（运用二叉堆）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%96%B0%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-text">8. 计数排序（新原理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%9A%E9%87%87%E4%BC%97%E9%95%BF%EF%BC%89"><span class="toc-text">9. 桶排序（博采众长）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="toc-text">10. 基数排序(Radix Sort)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第零章、核心刷题框架汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6-%E4%B8%87%E5%89%91%E5%BD%92%E5%AE%97"><span class="toc-text">(零) 万剑归宗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">1. 数据结构的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 数据结构的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">3. 算法的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A9%B7%E4%B8%BE%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-text">4. 穷举的难点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-text">(一) 双指针（链表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">1、合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E8%A7%A3"><span class="toc-text">2、单链表的分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">3、合并 k 个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">4、单链表的倒数第 k 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="toc-text">5、单链表的中点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF"><span class="toc-text">6、判断链表是否包含环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-text">7、两个链表是否相交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">(二) 双指针（数组）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9"><span class="toc-text">1、原地修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">2、滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">3、二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81n-%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">4、n 数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8F%8D%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">5、反转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%9B%9E%E6%96%87%E4%B8%B2%E5%88%A4%E6%96%AD"><span class="toc-text">6、回文串判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">(三) 滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1、框架概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">2、最小覆盖子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97"><span class="toc-text">3、字符串排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%BE%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">4、找所有字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">5、最长无重复子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-text">(四) 二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-text">1、代码框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89"><span class="toc-text">2、寻找一个数（基本）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AF%BB%E6%89%BE%E5%B7%A6%E8%BE%B9%E7%95%8C"><span class="toc-text">3、寻找左边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%BB%E6%89%BE%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="toc-text">4、寻找右边界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E9%80%92%E5%BD%92%EF%BC%88%E4%B8%80%E4%B8%AA%E8%A7%86%E8%A7%92-%E4%B8%A4%E7%A7%8D%E6%80%9D%E7%BB%B4%EF%BC%89"><span class="toc-text">(五) 递归（一个视角+两种思维）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E6%A0%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92"><span class="toc-text">1、从树的角度理解递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E5%86%99%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、编写递归的两种思维模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">(六) 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">1、斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%91%E9%9B%B6%E9%92%B1"><span class="toc-text">2、凑零钱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%9B%9E%E6%BA%AF-DFS"><span class="toc-text">(七) 回溯(DFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">1、全排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-BFS"><span class="toc-text">(八) BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-text">1、算法框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%BB%91%E5%8A%A8%E8%B0%9C%E9%A2%98"><span class="toc-text">2、滑动谜题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E5%BC%80%E5%AF%86%E7%A0%81%E9%94%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%AC%A1%E6%95%B0"><span class="toc-text">3、解开密码锁的最少次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8F%8C%E5%90%91-BFS-%E4%BC%98%E5%8C%96"><span class="toc-text">4、双向 BFS 优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97"><span class="toc-text">(九) 二叉树系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F"><span class="toc-text">1、二叉树的重要性、深入理解前中后序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E7%A7%8D%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">2、两种解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%90%8E%E5%BA%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="toc-text">3、后序位置的特殊之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%A5%E6%A0%91%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E5%8A%A8%E5%BD%92-%E5%9B%9E%E6%BA%AF-DFS%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">4、以树的视角看动归&#x2F;回溯&#x2F;DFS算法的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">5、层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E3%80%81%E5%AD%90%E9%9B%86%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-text">(十) 排列、组合、子集（回溯）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%90%E9%9B%86%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">1、子集（元素无重不可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%84%E5%90%88%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">2、组合（元素无重不可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8E%92%E5%88%97%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">3、排列（元素无重不可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%EF%BC%88%E5%85%83%E7%B4%A0%E6%9C%89%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">4、子集&#x2F;组合（元素有重不可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8E%92%E5%88%97%EF%BC%88%E5%85%83%E7%B4%A0%E6%9C%89%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">5、排列（元素有重不可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">6、子集&#x2F;组合（元素无重可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%8E%92%E5%88%97%EF%BC%88%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%8F%AF%E5%A4%8D%E9%80%89%EF%BC%89"><span class="toc-text">7、排列（元素无重可复选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-text">8、最后总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">(十一) 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8"><span class="toc-text">1、贪心选择性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BE%8B%E9%A2%98%E5%AE%9E%E6%88%98"><span class="toc-text">2、例题实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-text">3、贪心算法的解题步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">(十二) 分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3"><span class="toc-text">1、分治思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">2、分治算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%97%A0%E6%95%88%E7%9A%84%E5%88%86%E6%B2%BB"><span class="toc-text">3、无效的分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E5%88%86%E6%B2%BB"><span class="toc-text">4、有效的分治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">(十三) 时空复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E8%A7%A3%E9%A2%98"><span class="toc-text">1、复杂度反推解题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E5%A4%B1%E8%AF%AF%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8"><span class="toc-text">2、编码失误导致异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Big-O-%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">3、Big O 表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">4、算法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="toc-text">5、最后总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第一章、经典数据结构算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%93%BE%E8%A1%A8"><span class="toc-text">(一) 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="toc-text">1. 82. 删除排序链表中的重复元素 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-264-%E4%B8%91%E6%95%B0-II"><span class="toc-text">2. 264. 丑数 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3. 有序矩阵中第 K 小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E5%AF%B9%E6%95%B0%E5%AD%97"><span class="toc-text">4. 查找和最小的 K 对数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">5. 两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="toc-text">6. 两数相加 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E8%8A%B1%E5%BC%8F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">7、方法：花式反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD"><span class="toc-text">8、方法：回文链表判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%95%B0%E7%BB%84"><span class="toc-text">(二) 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%83%E9%81%93%E9%A2%98"><span class="toc-text">1、双指针的七道题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86"><span class="toc-text">2、二维数组的花式遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%9B%A2%E7%81%AD-nSum-%E9%97%AE%E9%A2%98"><span class="toc-text">3、团灭 nSum 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">4、前缀和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-text">5、差分数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%BB%B6%E4%BC%B8%EF%BC%9ARabin-Karp-%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">6、滑动窗口延伸：Rabin Karp 字符匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%80%9D%E7%BB%B4"><span class="toc-text">7、二分搜索思维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%B8%A6%E6%9D%83%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-text">8、带权随机选择算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E5%86%B3%E7%AD%96%E7%AE%97%E6%B3%95"><span class="toc-text">9、田忌赛马决策算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%98%9F%E5%88%97%E3%80%81%E6%A0%88"><span class="toc-text">(三) 队列、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1、队列与栈的互相实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">2、单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-text">3、单调队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">(四) 二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BC%BA%E5%8C%96"><span class="toc-text">(五) 二叉树强化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8B%93%E5%B1%95"><span class="toc-text">(六) 二叉树拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">(七) 经典数据结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81LRU-%E7%AE%97%E6%B3%95"><span class="toc-text">1、LRU 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81LFU-%E7%AE%97%E6%B3%95"><span class="toc-text">2、LFU 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%9A%8F%E6%9C%BA%E9%9B%86%E5%90%88%E3%80%81%E9%BB%91%E5%90%8D%E5%8D%95%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">3、随机集合、黑名单随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81TreeMap-%E4%B8%8E-TreeSet"><span class="toc-text">4、TreeMap 与 TreeSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">5、基本线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%8A%A8%E6%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">6、动态线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%87%92%E6%9B%B4%E6%96%B0%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">7、懒更新线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Tire-%E6%A0%91"><span class="toc-text">8、Tire 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%97%B6%E9%97%B4%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-text">9、朋友圈时间线算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E8%80%83%E5%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">10、考场座位分配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">11、计算器的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-text">12、两个二叉堆实现中位数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98"><span class="toc-text">13、数组去重问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%9B%BE"><span class="toc-text">(八) 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%9A%E7%8E%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">1、有向图：环检测与拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%90%8D%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-text">2、名流问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A"><span class="toc-text">3、二分图判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Union-Find-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">4、Union-Find 并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Kruskal-MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%8E%92%E5%BA%8F%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-text">5、Kruskal MST最小生成树（并查集+排序贪心）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Prim-MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88BFS-%E5%88%87%E5%88%86%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-text">6、Prim MST最小生成树（BFS+切分贪心）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Dijkstra-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">7、Dijkstra 单源最短路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第二章、经典暴力搜索算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-DFS%E3%80%81%E5%9B%9E%E6%BA%AF"><span class="toc-text">(一) DFS、回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-BFS"><span class="toc-text">(二) BFS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第三章、经典动态规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7"><span class="toc-text">(一) 基本技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AD%90%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">(二) 子序列类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%83%8C%E5%8C%85%E7%B1%BB%E5%9E%8B"><span class="toc-text">(三) 背包类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%810-1-%E8%83%8C%E5%8C%85"><span class="toc-text">1、0-1 背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%90%E9%9B%86%E8%83%8C%E5%8C%85"><span class="toc-text">2、子集背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">3、完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">4、目标和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%B8%B8%E6%88%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">(四) 游戏类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E8%B4%AA%E5%BF%83%E7%B1%BB%E5%9E%8B"><span class="toc-text">(五) 贪心类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6"><span class="toc-text">1、解题框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%80%81%E5%8F%B8%E6%9C%BA%E5%8A%A0%E6%B2%B9%E7%AE%97%E6%B3%95"><span class="toc-text">2、老司机加油算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">3、区间调度问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%8A%80%E5%B7%A7-%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4"><span class="toc-text">4、扫描线技巧-安排会议室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91"><span class="toc-text">5、视频剪辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">第四章、其他常见算法技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7"><span class="toc-text">(一) 数学运算技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">(二) 经典面试题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/07/22/Attention-is-all-you-need/" title="Transformer 开山之作"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/attention-is-all-you-need/attention-page-0.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="Transformer 开山之作"/></a><div class="content"><a class="title" href="/butterflyblog/2025/07/22/Attention-is-all-you-need/" title="Transformer 开山之作">Transformer 开山之作</a><time datetime="2025-07-21T16:00:00.000Z" title="发表于 2025-07-22 00:00:00">2025-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/04/27/LLM4Rec_abc_5/" title="大模型推荐系统 (应用)"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/llm4rec_abc/5/llm4rec-abc-5-Page.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="大模型推荐系统 (应用)"/></a><div class="content"><a class="title" href="/butterflyblog/2025/04/27/LLM4Rec_abc_5/" title="大模型推荐系统 (应用)">大模型推荐系统 (应用)</a><time datetime="2025-04-27T08:00:00.000Z" title="发表于 2025-04-27 16:00:00">2025-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/04/26/LLM4Rec_abc_4/" title="大模型推荐系统（4）直接推荐范式"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/llm4rec_abc/4/llm4rec-abc-4-Page.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="大模型推荐系统（4）直接推荐范式"/></a><div class="content"><a class="title" href="/butterflyblog/2025/04/26/LLM4Rec_abc_4/" title="大模型推荐系统（4）直接推荐范式">大模型推荐系统（4）直接推荐范式</a><time datetime="2025-04-26T10:00:00.000Z" title="发表于 2025-04-26 18:00:00">2025-04-26</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/butterflyblog/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/CS224W/"><span class="card-category-list-name">CS224W</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"><span class="card-category-list-name">信息安全</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"><span class="card-category-list-name">大学课程</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"><span class="card-category-list-name">推荐系统</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">机器学习</span><span class="card-category-list-count">23</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">深度学习</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="card-category-list-name">编程语言</span><span class="card-category-list-count">9</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/butterflyblog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="card-category-list-name">计算机网络</span><span class="card-category-list-count">2</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/butterflyblog/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" style="font-size: 1.15em; color: rgb(18, 22, 189)">前后端分离</a><a href="/butterflyblog/tags/C-C/" style="font-size: 1.35em; color: rgb(39, 100, 44)">C/C++</a><a href="/butterflyblog/tags/Transformer/" style="font-size: 1.15em; color: rgb(105, 99, 111)">Transformer</a><a href="/butterflyblog/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80Assembly/" style="font-size: 1.15em; color: rgb(139, 6, 70)">汇编语言Assembly</a><a href="/butterflyblog/tags/GNN/" style="font-size: 1.25em; color: rgb(66, 93, 58)">GNN</a><a href="/butterflyblog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" style="font-size: 1.45em; color: rgb(50, 166, 189)">计算机视觉</a><a href="/butterflyblog/tags/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/" style="font-size: 1.25em; color: rgb(26, 15, 158)">计网实验</a><a href="/butterflyblog/tags/%E5%8E%9F%E7%A5%9E/" style="font-size: 1.15em; color: rgb(189, 100, 3)">原神</a><a href="/butterflyblog/tags/%E9%A2%9C%E8%89%B2%E7%B4%A0%E6%9D%90/" style="font-size: 1.15em; color: rgb(181, 186, 109)">颜色素材</a><a href="/butterflyblog/tags/ML/" style="font-size: 1.4em; color: rgb(147, 131, 187)">ML</a><a href="/butterflyblog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 1.15em; color: rgb(70, 62, 22)">密码学</a><a href="/butterflyblog/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C/" style="font-size: 1.15em; color: rgb(187, 148, 114)">数字逻辑实验</a><a href="/butterflyblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" style="font-size: 1.15em; color: rgb(17, 147, 71)">数据库系统原理</a><a href="/butterflyblog/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.25em; color: rgb(94, 52, 19)">后端</a><a href="/butterflyblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.15em; color: rgb(73, 186, 100)">数据结构</a><a href="/butterflyblog/tags/GCN/" style="font-size: 1.15em; color: rgb(95, 188, 167)">GCN</a><a href="/butterflyblog/tags/Node2Vec/" style="font-size: 1.2em; color: rgb(70, 51, 81)">Node2Vec</a><a href="/butterflyblog/tags/DeepWalk/" style="font-size: 1.15em; color: rgb(53, 66, 17)">DeepWalk</a><a href="/butterflyblog/tags/PageRank/" style="font-size: 1.15em; color: rgb(144, 9, 134)">PageRank</a><a href="/butterflyblog/tags/DL/" style="font-size: 1.15em; color: rgb(32, 28, 122)">DL</a><a href="/butterflyblog/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" style="font-size: 1.15em; color: rgb(49, 192, 148)">身份认证</a><a href="/butterflyblog/tags/LLM/" style="font-size: 1.35em; color: rgb(46, 158, 51)">LLM</a><a href="/butterflyblog/tags/LaTeX/" style="font-size: 1.25em; color: rgb(171, 148, 81)">LaTeX</a><a href="/butterflyblog/tags/Linux/" style="font-size: 1.15em; color: rgb(15, 5, 40)">Linux</a><a href="/butterflyblog/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 1.15em; color: rgb(167, 26, 56)">现代密码学</a><a href="/butterflyblog/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" style="font-size: 1.15em; color: rgb(130, 3, 48)">监督学习理论</a><a href="/butterflyblog/tags/PHP/" style="font-size: 1.15em; color: rgb(8, 156, 11)">PHP</a><a href="/butterflyblog/tags/PyTorch/" style="font-size: 1.2em; color: rgb(152, 10, 18)">PyTorch</a><a href="/butterflyblog/tags/Python/" style="font-size: 1.3em; color: rgb(50, 55, 168)">Python</a><a href="/butterflyblog/tags/Markdwon/" style="font-size: 1.15em; color: rgb(161, 61, 64)">Markdwon</a><a href="/butterflyblog/tags/Pandas/" style="font-size: 1.15em; color: rgb(113, 57, 114)">Pandas</a><a href="/butterflyblog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.15em; color: rgb(175, 79, 75)">正则表达式</a><a href="/butterflyblog/tags/SQL/" style="font-size: 1.15em; color: rgb(97, 103, 179)">SQL</a><a href="/butterflyblog/tags/CTF/" style="font-size: 1.15em; color: rgb(54, 29, 161)">CTF</a><a href="/butterflyblog/tags/WEB%E6%8A%80%E6%9C%AF/" style="font-size: 1.15em; color: rgb(44, 60, 171)">WEB技术</a><a href="/butterflyblog/tags/sqlmap/" style="font-size: 1.15em; color: rgb(159, 98, 126)">sqlmap</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/butterflyblog/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/butterflyblog/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">10</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">73</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2023-07-31T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">378.2k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-08-07T11:40:53.176Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/isSeymour/PicGo/blog/page_img/TW1016.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By isSeymour</div><div class="footer_custom_text">欢迎乘坐我的生活地铁！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/butterflyblog/js/utils.js"></script><script src="/butterflyblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liAZxomGv7Hapw8g',
      clientSecret: 'f7cafde192c4ada8bef4b76952c422d90575cf8b',
      repo: 'gitalk',
      owner: 'isSeymour',
      admin: ['isSeymour'],
      id: '3ad0a31b456a2d89beb67511f6facc45',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/butterflyblog/js/search/local-search.js"></script></div></div></body></html>