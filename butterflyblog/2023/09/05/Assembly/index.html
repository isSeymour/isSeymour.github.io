<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《汇编语言》Notes | isSeymour</title><meta name="author" content="isSeymour"><meta name="copyright" content="isSeymour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《汇编语言》Notes  知识来源：同济大学汇编教学课件 2023.9.5@Seymour0314  前言：重点跳转    基本指令 3.3 MOV指令、PUSH指令、POP指令、LEA指令等   DOS功能调用 3.13 DOS系统功能调用   基础知识 4.2 常数、变量和标号   更多指令 4.9 算术运算指令 4.10 逻辑运算指令 5.1 转移指令 5.2 循环指令   模板使用 一、模">
<meta property="og:type" content="article">
<meta property="og:title" content="《汇编语言》Notes">
<meta property="og:url" content="https://isseymour.github.io/butterflyblog/2023/09/05/Assembly/index.html">
<meta property="og:site_name" content="isSeymour">
<meta property="og:description" content="《汇编语言》Notes  知识来源：同济大学汇编教学课件 2023.9.5@Seymour0314  前言：重点跳转    基本指令 3.3 MOV指令、PUSH指令、POP指令、LEA指令等   DOS功能调用 3.13 DOS系统功能调用   基础知识 4.2 常数、变量和标号   更多指令 4.9 算术运算指令 4.10 逻辑运算指令 5.1 转移指令 5.2 循环指令   模板使用 一、模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/assembly_01.avif">
<meta property="article:published_time" content="2023-09-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-04T16:00:00.000Z">
<meta property="article:author" content="isSeymour">
<meta property="article:tag" content="汇编语言Assembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/assembly_01.avif"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/IC1011.ico"><link rel="canonical" href="https://isseymour.github.io/butterflyblog/2023/09/05/Assembly/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/butterflyblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/butterflyblog/',
  algolia: undefined,
  localSearch: {"path":"/butterflyblog/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《汇编语言》Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-05 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/butterflyblog/code/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/assembly_01.avif')"><nav id="nav"><span id="blog-info"><a href="/butterflyblog/" title="isSeymour"><span class="site-name">isSeymour</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《汇编语言》Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-04T16:00:00.000Z" title="发表于 2023-09-05 00:00:00">2023-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-04T16:00:00.000Z" title="更新于 2023-09-05 00:00:00">2023-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/butterflyblog/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/">大学课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《汇编语言》Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>《汇编语言》Notes</h1>
<blockquote>
<p>知识来源：同济大学汇编教学课件</p>
<p>2023.9.5@Seymour0314</p>
</blockquote>
<h2 id="前言：重点跳转">前言：重点跳转</h2>
<blockquote>
<ul>
<li>
<p>基本指令</p>
<h5 id="3-3-MOV指令、PUSH指令、POP指令、LEA指令等"><a href="#jump_move">3.3 MOV指令、PUSH指令、POP指令、LEA指令等</a></h5>
</li>
<li>
<p>DOS功能调用</p>
<h5 id="3-13-DOS系统功能调用"><a href="#jump_dos">3.13 DOS系统功能调用</a></h5>
</li>
<li>
<p>基础知识</p>
<h5 id="4-2-常数、变量和标号"><a href="#%E5%B8%B8%E6%95%B0%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E5%8F%B7">4.2 常数、变量和标号</a></h5>
</li>
<li>
<p>更多指令</p>
<h5 id="4-9-算术运算指令"><a href="#jump_count">4.9 算术运算指令</a></h5>
<h5 id="4-10-逻辑运算指令"><a href="#jump_logic">4.10 逻辑运算指令</a></h5>
<h5 id="5-1-转移指令"><a href="#jump_jmp">5.1 转移指令</a></h5>
<h5 id="5-2-循环指令"><a href="#jump_loop">5.2 循环指令</a></h5>
</li>
<li>
<p>模板使用</p>
<h5 id="一、模板"><a href="#jump_temp">一、模板</a></h5>
</li>
</ul>
</blockquote>
<h2 id="第一课-基础知识">第一课 基础知识</h2>
<h3 id="1-1-信息单位与数据类型">1.1 信息单位与数据类型</h3>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903202323153.png" alt="image-20230903202323153" style="zoom:50%;" /> 
<h3 id="1-2-进制转换">1.2 进制转换</h3>
<ul>
<li>进制
<ul>
<li>十六进制 Hexadecimal，简写H</li>
<li>十进制 Decimal，简写D</li>
<li>八进制 Octonary，简写Q</li>
<li>二进制 Binary，简写B</li>
</ul>
</li>
</ul>
<h4 id="（1）X进制-转-十进制">（1）X进制 转 十进制</h4>
<ul>
<li>位权法</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903201906663.png" alt="image-20230903201906663" style="zoom: 50%;" /> 
<h4 id="（2）十进制-转换-X进制">（2）十进制 转换 X进制</h4>
<ul>
<li>整数部分：除X取余，逆序排列</li>
<li>小数部分：乘X取整，顺序排列</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903202121187.png" alt="image-20230903202121187" style="zoom:50%;" />  
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903202104467.png" alt="image-20230903202104467" style="zoom: 50%;" /> 
<h3 id="1-3-编码">1.3 编码</h3>
<ul>
<li>编码
<ul>
<li>数值类型编码
<ul>
<li>无符号数
<ul>
<li>本身就是数值</li>
</ul>
</li>
<li>补码（有符号数）
<ul>
<li>正数：最高位0，本身就是数值</li>
<li>负数：最高位1，取反加1得到的是其绝对值。</li>
</ul>
</li>
</ul>
</li>
<li>非数值类型编码
<ul>
<li>ASCII码</li>
<li>Unicode编码</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-溢出">1.4 溢出</h3>
<ul>
<li>
<p>人为理解：</p>
<ul>
<li>超出表示范围即是溢出。</li>
</ul>
</li>
<li>
<p>汇编体现：</p>
<ul>
<li>无符号数：CF位置1，溢出。</li>
<li>有符号数（补码）：OF位置1，溢出。</li>
</ul>
</li>
<li>
<p>最值：</p>
<ul>
<li>无符号数：</li>
</ul>
<table>
<thead>
<tr>
<th>位数</th>
<th>最小</th>
<th>对应十进制</th>
<th>最大</th>
<th>对应十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>8bit</td>
<td>0000 0000 B</td>
<td>0 D</td>
<td>1111 1111 B</td>
<td>255 D</td>
</tr>
<tr>
<td>16bit</td>
<td>0000 0000 0000 0000 B</td>
<td>0 D</td>
<td>1111 1111 1111 1111 B</td>
<td>65535D</td>
</tr>
</tbody>
</table>
<ul>
<li>有符号数（补码）：</li>
</ul>
<table>
<thead>
<tr>
<th>位数</th>
<th>最小</th>
<th>对应十进制</th>
<th>最大</th>
<th>对应十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>8bit</td>
<td>1000 0000 B</td>
<td>-128 D</td>
<td>0111 1111 B</td>
<td>+127 D</td>
</tr>
<tr>
<td>16bit</td>
<td>1000 0000 0000 0000 B</td>
<td>-32768 D</td>
<td>0111 1111 1111 1111 B</td>
<td>+32767 D</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>补码范围
<ul>
<li>1B（8bit）：-128 ~ +127</li>
<li>2B（16bit）：-32768 ~ +32767</li>
<li>4B（32bit）：-2147483648 ~ +2147483647</li>
<li>8B（64bit）：-2^32^ ~ 2^32^-1</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p>特点</p>
<ul>
<li>
<p>对于二进制数，保持位数不变计算（8bit计算后仍然取8bit），</p>
<p>那么，<code>取反加一</code> 和 <code>减一取反</code> 效果一样。</p>
</li>
<li>
<p>正数x求补，得到对应的负数-x；</p>
<p>负数-x求补，得到对应的正数x。</p>
<blockquote>
<p>求补是取反加一。</p>
</blockquote>
</li>
<li>
<p>无符号数 和 补码数，使用相同的加减法运算规则，</p>
<p>其中补码的符号位参与运算，结果正确。</p>
</li>
<li>
<p>无符号数 和 补码数，使用不同的溢出判断方法。</p>
</li>
</ul>
</li>
<li>
<p>分析溢出</p>
<ul>
<li>无符号数
<ul>
<li>相加时，两数的最高位的数都是 1，则会溢出；</li>
<li>相减时，被减数更小，会溢出。</li>
</ul>
</li>
<li>有符号数
<ul>
<li>相加时，若两个数是相同符号位，计算结果的符号位却变化了，则是溢出；</li>
<li>相减时，若两个数是不同符号位，计算结果的符号位与被减数不同，则是溢出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-字符表示">1.5 字符表示</h3>
<ul>
<li>
<p>采用非数值类编码的一种——ASCII码</p>
</li>
<li>
<p>8bit信息，其中7bit编码，最高位0。</p>
<p>能表示出128个字符。</p>
</li>
<li>
<p>常用ASCII码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td><code> </code></td>
<td>32 D</td>
<td>20 H</td>
<td><code>CR回车</code></td>
<td>13 D</td>
<td>0D H</td>
</tr>
<tr>
<td><code>0</code></td>
<td>48 D</td>
<td>30 H</td>
<td><code>LF换行</code></td>
<td>10 D</td>
<td>0A H</td>
</tr>
<tr>
<td><code>A</code></td>
<td>65 D</td>
<td>41 H</td>
<td><code>Tab</code></td>
<td>9 D</td>
<td>09 H</td>
</tr>
<tr>
<td><code>a</code></td>
<td>97 D</td>
<td>61 H</td>
<td><code>BS退格</code></td>
<td>8 D</td>
<td>08 H</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="1-6-基本逻辑运算">1.6 基本逻辑运算</h3>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903205019789.png" alt="image-20230903205019789" style="zoom:50%;" /> 
<h3 id="1-7-BCD码">1.7 BCD码</h3>
<ul>
<li>
<p>压缩BCD码</p>
<p>每一位用4位二进制表示，一个字节表示两位十进制数</p>
</li>
<li>
<p>非压缩BCD码</p>
<p>用1个字节表示一位十进制数，高四位总是0000，低4位的0000到1001表示0到9</p>
</li>
</ul>
<h2 id="第二课-x86微机系统的组成">第二课 x86微机系统的组成</h2>
<h3 id="2-1-x86寄存器组">2.1 x86寄存器组</h3>
<ul>
<li>
<p>寄存器</p>
<p>用以临时存放指令执行所产生的中间结果存储单元</p>
</li>
<li>
<p>x86基本寄存器</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903205223350.png" alt="image-20230903205223350" style="zoom:50%;" /> 
<h3 id="2-2-通用寄存器（数据寄存器）">2.2 通用寄存器（数据寄存器）</h3>
<ul>
<li>
<p>用于算术运算、逻辑运算和数据的传送</p>
</li>
<li>
<p>虽然是通用寄存器，但各自又有专用用途</p>
<p>(1)  A。</p>
<p>作为累加器使用，是算术运算所使用的主要寄存器。8位、16位和32位累加器分别对应AL, AX和EAX。</p>
<p>(2)  B。</p>
<p>基址寄存器， 16位和32位基址寄存器分别对应BX,EBX。</p>
<p>(3)  C。</p>
<p>计数器。8位、16位和32位计数器分别对应CL，CX和ECX。</p>
<p>(4)  D。</p>
<p>数据寄存器。 8位、16位和32位数据寄存器分别对应DL, DX和EDX。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903205320087.png" alt="image-20230903205320087" style="zoom: 50%;" /> 
<h3 id="2-3-指针寄存器">2.3 指针寄存器</h3>
<ul>
<li>
<p>指针寄存器(Pointer Register):ESP和EBP</p>
</li>
<li>
<p>指针寄存器</p>
<ul>
<li>
<p>SP/ESP</p>
<p>堆栈指针。</p>
<p>专门用以访问堆栈上数据的寄存器。32位模式下使用ESP，16位模式下使用SP，其内容始终指向堆栈栈顶。从这一点上看，ESP/SP是专用的。</p>
</li>
<li>
<p>BP/EBP</p>
<p>基址指针。</p>
<p>可以用来存放数据，但更经常、更重要的用途是作为堆栈区的一个基地址，以便访问堆栈中的数据。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-变址寄存器">2.4 变址寄存器</h3>
<ul>
<li>
<p>变址寄存器(Index Register)包括ESI和EDI，其对应的16位寄存器分别是SI和DI。</p>
</li>
<li>
<p>变址寄存器</p>
<ul>
<li>
<p>SI/ESI</p>
<p>源变址寄存器，对应的16位寄存器是SI, 32位的是ESI。</p>
<p>可以存放数据，也可作为指针，存放内存单元地址。</p>
</li>
<li>
<p>DI/EDI</p>
<p>目的变址寄存器，对应的16位寄存器是DI, 32位的是EDI。</p>
<p>可以存放数据，也可作为指针，存放内存单元地址。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-控制寄存器">2.5 控制寄存器</h3>
<ul>
<li>
<p>控制寄存器(Control Register)包括EIP和EFLAGS</p>
</li>
<li>
<p>控制寄存器</p>
<ul>
<li>
<p>IP/EIP</p>
<p>用于指示待执行指令的位置。</p>
<ul>
<li>32位模式下是EIP，16位模式下是IP。</li>
<li>运行期间，CPU自动修改(E)IP，程序不直接修改(E)IP，随着指令的执行，(E)IP相应地变动。</li>
</ul>
</li>
<li>
<p>FLAGS/EFLAGS</p>
<p>一条指令执行后，CPU所处的状态</p>
<ul>
<li>16位模式下是FLAGS</li>
<li>主要有：运算结果标志、状态控制标志和系统状态标志等寄存器。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903205830268.png" alt="image-20230903205830268" style="zoom: 50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903205956709.png" alt="image-20230903205956709" style="zoom: 67%;" /> 
</li>
</ul>
</li>
</ul>
<blockquote>
<p>记住：</p>
<ul>
<li>Overflow Flag（OF）：位序11，补码溢出。</li>
<li>Carry Flag（CF）：位序0，进位、借位（无符号数溢出）。</li>
<li>Sign Flag（SF）：位序7，符号位。</li>
<li>Zero Flag（ZF）：位序6，零位。</li>
</ul>
</blockquote>
<h3 id="2-6-段寄存器">2.6 段寄存器</h3>
<ul>
<li>一个连续单元的内存区域为段，段寄存器是用于存放指示该段首地址的相关内容</li>
<li>16位CPU有四个段寄存器：CS, DS, SS和ES，32位CPU又增加了两个：FS和GS
<ul>
<li>CS(Code Segment)，指示代码段</li>
<li>DS(Data Segment)，指示数据段</li>
<li>SS(Stack Segment)，指示堆栈段</li>
<li>ES(Extra Segment), FS, GS，指示附加段</li>
</ul>
</li>
</ul>
<h3 id="2-7-内存储器">2.7 内存储器</h3>
<ul>
<li>
<p>用途：存放执行的指令、所处理的数据</p>
</li>
<li>
<p>基本单位：字节(Byte)(8bit)</p>
</li>
<li>
<p>地址：每个字节单元的一个唯一编号</p>
<ul>
<li>寻址空间受限于地址总线宽度</li>
<li>20-bit地址总线，可访问00000h～FFFFFh，共2^20^字节(1MB)</li>
<li>32-bit，可访问00000000h～FFFFFFFFh，共2^32^字节(4GB)</li>
<li>指令访问地址范围受字长限制</li>
</ul>
<blockquote>
<p>注意区分 寻址编号、字节、比特。</p>
<p>这里说的寻址空间到FFFFFH，那就是2^20^的单位，而寻址空间的单位是B，所以说是2^20^字节。</p>
<p>也就是说，这里算寻址空间，你不要多此一举的算1B=8bit！</p>
</blockquote>
</li>
<li>
<p>内存单元与数据存放格式</p>
<p>存储单元：连续若干个字节存储空间</p>
<p>类型：</p>
<ul>
<li>字节单元</li>
<li>2字节单元，又叫做字(Word)单元</li>
<li>4字节单元，又叫双字(DWord)单元</li>
<li>8字节单元，又叫四字(QWord)单元</li>
</ul>
<p>标识：以内存块的起始地址来标识</p>
<p>存放格式：低位存入低单元，高位存入高单元(<strong>小端格式</strong>，Intel格式)</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903211135204.png" alt="image-20230903211135204" style="zoom:50%;" /> 
</li>
<li>
<p>示例</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903211215198.png" alt="image-20230903211215198" style="zoom:50%;" /> 
</li>
</ul>
<h3 id="2-8-内存与分段">2.8 内存与分段</h3>
<ul>
<li>
<p>内存的分段使用</p>
<ul>
<li>内存段：连续若干字节的内存区域</li>
<li>基地址由段寄存器来确定</li>
<li>地址形式为：段 : 偏移地址</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903211314155.png" alt="image-20230903211314155" style="zoom: 50%;" /> 
</li>
<li>
<p>矛盾</p>
<ul>
<li>
<p>20-bit地址线：寻址空间：00000h~FFFFFh</p>
</li>
<li>
<p>16-bit字长能表示范围：0000h ~ FFFFh</p>
</li>
<li>
<p>解决办法：</p>
<p>16位段地址和16位偏移地址，合成20位物理地址</p>
<p>规则: 20位地址＝段地址×16+偏移地址</p>
<blockquote>
<p>CPU 可以用不同的段地址和偏移地址形成同一个物理地址</p>
</blockquote>
</li>
<li>
<p>示例：</p>
<p>段地址：1000h，偏移地址：1234h</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903211613512.png" alt="image-20230903211613512" style="zoom:80%;" /> 
</li>
</ul>
</li>
</ul>
<h3 id="2-9-栈及操作">2.9 栈及操作</h3>
<ul>
<li>
<p>由连续若干个内存单元组成的、按FILO原则进行存取的数据结构</p>
<ul>
<li>栈底	堆栈中最先存入数据的单元栈顶</li>
<li>堆栈中最后存入数据的单元</li>
<li>进栈(PUSH)	将数据存入堆栈</li>
<li>出栈(POP)	从堆栈取出数据</li>
</ul>
</li>
<li>
<p>栈底固定不变，栈顶随进栈和出栈操作而变化，由堆栈指针(Stack Pointer, SP) 指示</p>
</li>
<li>
<p>x86堆栈</p>
<ul>
<li>基地址：寄存器SS专用于确定堆栈区的基地址</li>
<li>栈顶：(E)SP专门用于指示栈顶的位置，即总是指向最近进栈的数据位置。</li>
<li>栈底：栈底固定为栈区的最高地址单元。执行PUSH操作后，(E)SP向低地址方向移动，执行POP操作后，(E)SP要向高地址方向移动</li>
<li><strong>栈单元基本单位是字(2字节)</strong>
<ul>
<li>16位CPU，只能以2字节为单位进行进栈和出栈操作</li>
<li>32位CPU，存取单位默认是4字节，但也可以是2字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>说明</p>
<ul>
<li>栈操作主要指令是PUSH和POP指令</li>
<li>与(E)SP密切相关，不宜将(E)SP用作数据寄存器</li>
</ul>
</li>
</ul>
<h2 id="第三课-寻址方式及指令">第三课 寻址方式及指令</h2>
<h3 id="3-1-指令系统概述">3.1 指令系统概述</h3>
<ul>
<li>
<p>机器指令：</p>
<p>用二进制编码表示的指令，由操作码和操作数两部分组成</p>
</li>
<li>
<p>汇编指令：</p>
<p>用指令助记符和符号地址表示的指令</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903212249659.png" alt="image-20230903212249659" style="zoom:50%;" /> 
<h3 id="3-2-操作数寻址方式">3.2 操作数寻址方式</h3>
<ul>
<li>
<p>三种操作数</p>
<ul>
<li>立即操作数，对应立即寻址方式</li>
<li>寄存器操作数，对应的是寄存器寻址方式</li>
<li>内存操作数，对应的内存操作数寻址方式</li>
</ul>
</li>
<li>
<p>寻址方式</p>
<ul>
<li>
<p>立即寻址  如<code>1A2Bh</code></p>
</li>
<li>
<p>寄存器寻址  如<code>AX</code></p>
</li>
<li>
<p>内存操作数寻址</p>
<ul>
<li>
<p>直接寻址  如<code>[59A8h]</code></p>
</li>
<li>
<p>寄存器间接寻址  如<code>[BX]</code></p>
</li>
<li>
<p>寄存器相对寻址  如<code>4[BX]</code></p>
</li>
<li>
<p>基址变址寻址 如 <code>[BX][SI]</code></p>
<ul>
<li>基址：BX和BP，32-bit通用寄存器</li>
<li>变址：SI和DI，32-bit通用寄存器(ESP除外)</li>
</ul>
<blockquote>
<p>注意这里，不能交换位置！！！</p>
</blockquote>
</li>
<li>
<p>相对基址变址寻址  如<code>100[BX][DI]</code></p>
</li>
</ul>
<blockquote>
<p>以上内存操作数寻址方式，都是默认使用段寄存器DS。</p>
<p>但是以BP/EBP寻址，默认用段寄存器SS。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-span-id-jump-move-MOV指令-span">3.3 <span id="jump_move">MOV指令</span></h3>
<ul>
<li>
<p>格式：MOV 目的操作数，源操作数</p>
</li>
<li>
<p>功能：源操作数传送到目的储存单元(reg,seg,mem)</p>
</li>
<li>
<p>操作数的寻址方式：</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903213407946.png" alt="image-20230903213407946" style="zoom: 50%;" /> 
<blockquote>
<p>重点：</p>
<ul>
<li>imm不能做目的操作数</li>
<li>CS不能用作目的操作数</li>
<li>类型必须一致且明确</li>
</ul>
<blockquote>
<p>seg是段地址，mem是具体内存地址，不一样！</p>
</blockquote>
</blockquote>
</li>
<li>
<p>说明</p>
<ul>
<li>一般情况下，指令源、目的操作数类型要一致</li>
<li>立即数要在目的操作数类型值范围内</li>
<li>类型均不明确时，须用Ptr指定操作数类型
<ul>
<li>Byte Ptr		指定字节类型(8位数据)</li>
<li>Word Ptr		指定2字节(字)类型(16位数据)</li>
<li>DWord Ptr	指定4字节(双字)类型(32位数据)</li>
<li>FWord Ptr	指定6字节类型(48位数据)</li>
<li>QWord Ptr 	指定8字节(四字)类型(64位数据)</li>
<li>TByte Ptr		指定10字节类型(80位数据)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>示例</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903213530216.png" alt="image-20230903213530216" style="zoom:50%;" /> 
<h3 id="3-4-XCHG指令">3.4 XCHG指令</h3>
<ul>
<li>
<p>格式：XCHG 操作数1，操作数2</p>
</li>
<li>
<p>功能：数据交换，操作数1与操作数2单元的内容互相交换</p>
<p>由于两操作数即是源操作数，又是目的操作数，故它们的位置顺序无关紧要</p>
</li>
<li>
<p>操作数的寻址方式：</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903213731391.png" alt="image-20230903213731391" style="zoom:50%;" /> 
<blockquote>
<p>重点：</p>
<ul>
<li>不能有imm</li>
<li>源操作数必须是reg</li>
<li>类型必须一致且明确</li>
</ul>
</blockquote>
</li>
<li>
<p>示例</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903213822325.png" alt="image-20230903213822325" style="zoom:50%;" /> 
<h3 id="3-5-PUSH指令">3.5 PUSH指令</h3>
<ul>
<li>
<p>格式：PUSH 源操作数</p>
</li>
<li>
<p>功能：数据进栈</p>
<ul>
<li>源操作数为16位，(E)SP内容减2</li>
<li>源操作数为32位，(E)SP中内容减4</li>
</ul>
<blockquote>
<p>注意，栈操作单位只能是16/32位。8086CPU只能是<strong>16位</strong>。</p>
<p>即，不可 PUSH AL，只能PUSH AX。</p>
</blockquote>
</li>
<li>
<p>操作数的寻址方式：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214216809.png" alt="image-20230903214216809" style="zoom: 50%;" /> 
<ul>
<li>示例</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214257432.png" alt="image-20230903214257432" style="zoom: 50%;" /> 
<h3 id="3-6-POP指令">3.6 POP指令</h3>
<ul>
<li>
<p>格式：POP 目的操作数</p>
</li>
<li>
<p>功能：从栈中弹出数据到目的操作数所确定的单元中</p>
<ul>
<li>操作数为16位，(E)SP向高地址端调整2字节</li>
<li>操作数为32位，(E)SP向高地址端调整4字节</li>
</ul>
<blockquote>
<p>注意，栈操作单位只能是16/32位。8086CPU只能是<strong>16位</strong>。</p>
<p>即，不可 POP AL，只能POP AX。</p>
</blockquote>
</li>
<li>
<p>操作数寻址方式：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214456667.png" alt="image-20230903214456667" style="zoom:50%;" /> 
<ul>
<li>示例</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214518927.png" alt="image-20230903214518927" style="zoom:50%;" /> 
<ul>
<li>使用实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用PUSH和POP指令，将字(16位)单元[1000h]内容和字单元[2000h]内容分别放入EAX低16位和高16位。</span><br><span class="line">解：先将两个16位数按存放顺序要求进栈，再从栈弹出一个32位数到EAX</span><br><span class="line">PUSH	Word Ptr[2000h]</span><br><span class="line">PUSH	Word Ptr[1000h]</span><br><span class="line">POP		EAX</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214743932.png" alt="image-20230903214743932" style="zoom:50%;" /> 
<h3 id="3-7-XLAT指令">3.7 XLAT指令</h3>
<ul>
<li>
<p>格式：XLAT</p>
</li>
<li>
<p>功能：查表换码。</p>
<p>将以(E)BX基址，以AL内容为位移量的字节单元内容传送给AL。</p>
<p>这条指令使用隐含操作数。在指令执行前约定：必须已经建立一个字节表，表首地址已经放入基址寄存器(E)BX；查找项的位移量已经放入AL</p>
</li>
<li>
<p>实例</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903214910464.png" alt="image-20230903214910464" style="zoom:50%;" /> 
<h3 id="3-8-地址传送指令LEA">3.8 地址传送指令LEA</h3>
<ul>
<li>格式：LEA 寄存器，源内存操作数</li>
<li>功能：有效地址送寄存器。将内存操作数的偏移地址(EA)传送至目的寄存器中。</li>
<li>操作数的寻址方式：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903215004437.png" alt="image-20230903215004437" style="zoom:50%;" /> 
<ul>
<li>
<p>若是16位寄存器则只装入EA的低16位</p>
</li>
<li>
<p>实例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) LEA	AX, [EBX][ESI]</span><br><span class="line">(2) MOV	AX, [EBX][ESI]</span><br><span class="line">解：</span><br><span class="line">指令(1)取源操作数的EA，并存入AX，</span><br><span class="line">指令(2)取EA所对应的字字单元内容AX。</span><br></pre></td></tr></table></figure>
<h3 id="3-9-地址传送指令2">3.9 地址传送指令2</h3>
<ul>
<li>
<p>格式：LDS/LSS/LES/LFS/LGS 目的寄存器，源内存操作数</p>
</li>
<li>
<p>功能：</p>
<p>将源内存操作数中的低2/4字节内容 存入 目的寄存器</p>
<p>高2字节内容 存入 段寄存器DS/SS/ES/FS/GS</p>
</li>
<li>
<p>操作数的寻址方式：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903215343729.png" alt="image-20230903215343729" style="zoom:50%;" /> 
<ul>
<li>示例</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903215437424.png" alt="image-20230903215437424" style="zoom:50%;" /> 
<h3 id="3-10-标志位传送指令">3.10 标志位传送指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1)  LAHF指令</span><br><span class="line">格式：LAHF</span><br><span class="line">功能：将FLAGS的低8位送至AH</span><br><span class="line">2)  SAHF指令</span><br><span class="line">格式：SAHF。</span><br><span class="line">功能：将AH内容送至标志寄存器低8位</span><br><span class="line">3)  PUSHF/PUSHFD指令</span><br><span class="line">格式：PUSHF/PUSHFD。</span><br><span class="line">功能：16/32位标志寄存器FLAGS/EFLAGS内容进栈</span><br><span class="line">4)  POPF/POPFD指令</span><br><span class="line">格式：POPF/POPFD。</span><br><span class="line">功能：从栈弹出16/32位数据FLAGS/EFLAGS </span><br></pre></td></tr></table></figure>
<h3 id="3-11-扩展指令">3.11 扩展指令</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CBW</span><br><span class="line">字节扩展到字，符号位填充，不影响真值</span><br><span class="line">AL扩展，AH填充，存在AX</span><br><span class="line"></span><br><span class="line">CWD </span><br><span class="line">字扩展到双字，符号位填充，不影响真值</span><br><span class="line">AX扩展，DX填充，存在DX:AX</span><br><span class="line"></span><br><span class="line">CWDE</span><br><span class="line">字扩展到双字，符号位填充，不影响真值</span><br><span class="line">AX扩展，EAX填充，存在EAX</span><br></pre></td></tr></table></figure>
<h3 id="3-12-输入输出指令">3.12 输入输出指令</h3>
<ul>
<li>IN、OUT指令专门用来读写I/O端口</li>
<li>只能使用累加器(AL/AX/EAX)来接收、发送数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1)  IN指令</span><br><span class="line">格式：IN 累加器，端口地址。</span><br><span class="line">功能：1/2/4字节端口数据AL/AX/EAX</span><br><span class="line">端口地址范围：0000h~FFFFh。</span><br><span class="line">imm8形式，指令中的端口范围：00h～FFh</span><br><span class="line">DX存放端口，指令中的端口：0000h~FFFFh</span><br><span class="line">和内存操作数不同的是，IN指令的源操作数据是来自I/O端口 </span><br><span class="line"></span><br><span class="line">2)  OUT指令</span><br><span class="line">格式：OUT 端口地址，累加器。</span><br><span class="line">功能：AL/AX/EAX内容1/2/4字节端口</span><br><span class="line">imm8形式，指令中的端口范围：00h～FFh</span><br><span class="line">DX存放端口，指令中的端口：0000h~FFFFh</span><br><span class="line">和内存操作数不同的是，OUT指令的目的操作数据将传送到I/O端口中去 </span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903215802562.png" alt="image-20230903215802562" style="zoom:50%;" /> 
<h3 id="3-13-span-id-jump-dos-DOS系统功能调用-span">3.13 <span id="jump_dos">DOS系统功能调用</span></h3>
<ul>
<li>介绍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(1) 01h。输入一个字符，有回显。</span><br><span class="line">入口：AH＝01h</span><br><span class="line">出口：AL＝输入字符的ASCII码</span><br><span class="line"></span><br><span class="line">(2) 02h。输出一个字符。</span><br><span class="line">入口：AH＝02h</span><br><span class="line">	 DL＝待输出字符的ASCII码</span><br><span class="line">出口：无</span><br><span class="line"></span><br><span class="line">(3) 08h。输入一个字符，无回显。</span><br><span class="line">入口：AH＝08h</span><br><span class="line">出口：AL＝输入字符的ASCII码</span><br><span class="line"></span><br><span class="line">(4) 09h。输出一个字符串。</span><br><span class="line">入口：AH＝09h</span><br><span class="line">	DS:DX＝字符串地址(以&#x27;$&#x27;作为结束标志)</span><br><span class="line">出口：无 </span><br><span class="line"></span><br><span class="line">(5) 0Ah。读入字符串(以回车结束，有回显)</span><br><span class="line">入口：AH＝0Ah</span><br><span class="line">	 DS:DX＝输入缓冲区地址(字节0允许字符数)</span><br><span class="line">出口：输入缓冲区字节1:字符数,字节2:字符串</span><br><span class="line"></span><br><span class="line">(6) 0Bh。检查是否有字符可读。</span><br><span class="line">入口：AH＝0Bh</span><br><span class="line">出口：AL＝00h,无；FFh,有</span><br><span class="line"></span><br><span class="line">(7) 4Ch。终止程序的执行，返回DOS。</span><br><span class="line">入口：AH＝4Ch</span><br><span class="line">	 AL＝返回的代码</span><br><span class="line">出口：无</span><br></pre></td></tr></table></figure>
<h3 id="3-14-汇编使用">3.14 汇编使用</h3>
<ul>
<li>前置操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C: D:\MASM</span><br><span class="line">PATH=%PATH%;D:\Work</span><br><span class="line">C:</span><br><span class="line">DIR</span><br></pre></td></tr></table></figure>
<ul>
<li>以编写的001.ASM为例介绍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE 001.ASM	查看类型信息</span><br><span class="line">MASM 001.ASM	汇编</span><br><span class="line">LINK 001.OBJ	连接</span><br><span class="line">DEBUG 001.EXE	调试</span><br><span class="line">001.EXE			运行</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903233053074.png" alt="image-20230903233053074" style="zoom:50%;" /> 
<blockquote>
<p>汇编ASM文件的文件名字不能过长，否则无法打开。</p>
</blockquote>
<ul>
<li>DEBUG操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看和修改寄存器内容的命令 R</span><br><span class="line">显示内存单元内容的命令 D</span><br><span class="line">输入汇编指令的命令 A</span><br><span class="line">反汇编命令 U</span><br><span class="line">执行命令 G</span><br><span class="line">追踪（单步执行）命令 T</span><br><span class="line">执行命令 P</span><br><span class="line">退出 DEBUG 命令 Q</span><br></pre></td></tr></table></figure>
<h2 id="第四课-源程序结构、运算指令">第四课 源程序结构、运算指令</h2>
<h3 id="4-1-源程序结构">4.1 源程序结构</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_STACK    SEGMENT  STACK  &#x27;STACK&#x27;</span><br><span class="line">	DB 1000H DUP(?)</span><br><span class="line">TOS	DW ?</span><br><span class="line">_STACK    ENDS</span><br><span class="line"></span><br><span class="line">_DATA    SEGMENT</span><br><span class="line">a	DW	10H</span><br><span class="line">b	DW	20H</span><br><span class="line">x	DW	?</span><br><span class="line">_DATA    ENDS</span><br><span class="line"></span><br><span class="line">_TEXT    SEGMENT</span><br><span class="line">	ASSUME  CS: _TEXT, DS: _DATA</span><br><span class="line">START: </span><br><span class="line">	MOV	AX, _DATA	; 设置数据段、堆栈 start</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">	CLI</span><br><span class="line">	MOV	AX, _STACK</span><br><span class="line">	MOV	SS, AX</span><br><span class="line">	MOV	SP, OFFSET TOS</span><br><span class="line">	STI		; 设置数据段、堆栈 end</span><br><span class="line">	</span><br><span class="line">	; 比较ab大小</span><br><span class="line">	MOV	AX, a</span><br><span class="line">	CMP	AX, b	; 注意这里仍然是a</span><br><span class="line">	JG	loc1</span><br><span class="line">	MOV	AX, b</span><br><span class="line"></span><br><span class="line">loc1:</span><br><span class="line">	MOV	x, AX</span><br><span class="line"></span><br><span class="line">	MOV	AX, 4C00H  ; 退出</span><br><span class="line">	INT	21H</span><br><span class="line">_TEXT    ENDS</span><br><span class="line">	END START</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903233146848.png" alt="image-20230903233146848" style="zoom:50%;" /> 
<h3 id="4-2-span-id-jump-var-常数、变量和标号-span">4.2 <span id="jump_var">常数、变量和标号</span></h3>
<ul>
<li>
<p>相关内容</p>
<ul>
<li>与数据相关的常量与变量</li>
<li>与转移地址相关的标号与过程</li>
</ul>
</li>
<li>
<p>标识符</p>
<p>标号名、变量名、过程名、段名等称为标识符</p>
<ul>
<li>
<p>组成标识符字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字母(A～Z, a～z)、数字(0～9)及?、.、@、$和_(下画线)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数字不能作首字符，'.'只能作为标识符的首字符。</p>
</li>
<li>
<p>标识符的长度没有严格限制，一般不应超过31字符</p>
</li>
<li>
<p>保留字不能作为标识符使用。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（1）常数">（1）常数</h4>
<ul>
<li>
<p>常量是数的本身，不对应任何存储单元(寄存器或内存单元)，</p>
<p>其数值在汇编期间已能够完全确定，且在程序运行期间也不会发生变化。</p>
</li>
<li>
<p>常量一般可分为：</p>
<ul>
<li>
<p>数值常数</p>
<ul>
<li>
<p>整数常数</p>
<p>各种进制均可，如： 255D，0B8h，1100B，144Q</p>
<blockquote>
<p>为区别于标识符，字母开头的十六进制数前须加0</p>
<p>通常常数默认为十进制，此时后面D或d可省略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以用伪指令RADIX改变默认的数制，其格式为：</span><br><span class="line">.RADIX  用十进制形式表示的基数 </span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>实数常数</p>
<p>实数其实就是带小数点的数，有两种形式表示：</p>
<p>（1）带小数点的十进制数形式，例如： -1.414</p>
<p>（2）指数形式，例如： 4.56E-2, -1.732E+10</p>
<p>实常数以浮点格式存放。</p>
</li>
</ul>
</li>
<li>
<p>字符串常数</p>
<p>字符串常数是用<code>‘(单撇号)</code>或<code>&quot;(双撇号)</code>括起来的单个字符或多个字符</p>
<p>(1）对于ASCII字符来说，其数值是字符对应的ASCII码的值</p>
<ul>
<li>'d’对应的是64h</li>
<li>'AB’对应的是41h, 42h</li>
</ul>
<p>（2）对于汉字来说，其数值是汉字的内码</p>
<ul>
<li>‘你好!’，对应是：0C4h, 0E3h 0Bah, 0C3h, 21h</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(1) 作为立即数出现在指令中</span><br><span class="line">MOV	AX, 1234h</span><br><span class="line">SUB	AL, &#x27;0&#x27;</span><br><span class="line">AND	EAX, 7FFFFFFFh</span><br><span class="line"></span><br><span class="line">(2) 作为内存操作数的位移量(地址编号)</span><br><span class="line">MOV	AX, [1000h]</span><br><span class="line">ADD	100h[BX], AL</span><br><span class="line">TEST	EAX, [1000h+EBX+EDX*4]</span><br><span class="line"></span><br><span class="line">(3) 为数据定义预置初始值</span><br><span class="line">Variable	DW	1234h</span><br><span class="line">Str		DB	&quot;Hello, World!&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">x			DQ	4.756E3 </span><br></pre></td></tr></table></figure>
<h4 id="（2）变量">（2）变量</h4>
<ul>
<li>
<p>变量是存放数据的内存单元名称</p>
<ul>
<li>变量名是符号地址</li>
<li>具有类型属性：字节、字、双字…</li>
</ul>
</li>
<li>
<p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[变量名]  数据定义伪指令  初值表  [;注释] </span><br><span class="line"></span><br><span class="line">DB、DW、DD、DF、DQ、DT</span><br><span class="line">1B、2B、4B、6B、8B、10B类型</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分配一个或多个指定类型的内存单元，并可用变量表示该内存单元</p>
</li>
<li>
<p>如果有变量名，那么它仅代表所定义的数据存储区的第一个单元地址</p>
</li>
</ul>
</li>
<li>
<p>定义的形式——初值表</p>
<ol>
<li>
<p>常数或常数表达式</p>
</li>
<li>
<p>“?”形式：内容不确定。一般情况下，程序在汇编时以0填充。</p>
</li>
<li>
<p>符号地址及地址表达式：符号地址对应的地址编号，是无符号整型常数。</p>
</li>
<li>
<p>可用DUP把某项重复n次：其格式为 <code>n  DUP(数据项) </code></p>
</li>
</ol>
</li>
<li>
<p>属性</p>
<ul>
<li>
<p>地址属性</p>
<ul>
<li>
<p>段地址可由<strong>运算符SEG</strong>返回</p>
</li>
<li>
<p>偏移地址可由<strong>运算符OFFSET</strong>返回</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,SEG Msg	;将Msg的段地址送到AX</span><br><span class="line">MOV BX,OFFSET Msg	;将Msg的偏移地址送到BX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：当需要存取某一变量时，必须先将该段的段地址放到相应的段寄存器(如DS、ES等)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	AX, _DATA</span><br><span class="line">MOV	DS, AX</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>类型属性</p>
<p>伪指令DB, DW, DD, DF, DQ, DT可定义1, 2, 4, 6, 8, 10字节类型</p>
<p>可以指定数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Byte Ptr	指定数据或变量为字节类型(8位)</span><br><span class="line">Word Ptr	指定数据或变量为2字节(字)类型(16位)</span><br><span class="line">DWord Ptr	指定数据或变量为4字节(双字)类型(32位)</span><br><span class="line">FWord Ptr	指定数据或变量为6字节类型(48位)</span><br><span class="line">QWord Ptr 	指定数据或变量为8字节(四字)类型(64位)</span><br><span class="line">TByte Ptr	指定数据或变量为10字节类型(80位)</span><br></pre></td></tr></table></figure>
<p>变量名对应的是内存单元地址，是无符号符号整常数，</p>
<p>加、减一个整常数就是地址编号加、减一个整常数，</p>
<p>仍然对应一个内存单元地址，其类型与原变量相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L	DD	1234A1B2h, 87654321h</span><br><span class="line">L是4字节类型单元，L+1对应的也是4字节类型单元，其内容是211234A1h</span><br><span class="line">L+1可以写成L[1]，注意，L[1]是L的偏移地址加1而不是加1×4</span><br></pre></td></tr></table></figure>
<p>每种数据类型的类型值就是其占用的字节数，可用<strong>运算符TYPE</strong>将它分离出来</p>
</li>
</ul>
</li>
<li>
<p>示例1</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Msg		DB	 	&quot;Hello&quot;     	;定义变量,分配5个1B空间,置初值</span><br><span class="line">		DB		13, 10, &#x27;$&#x27;   	;分配3个B空间,置初值</span><br><span class="line">Cnt		DW		5*20, -2    	;定义变量,分配2个2B空间,置初值</span><br><span class="line">S1		DB		?, ?, ?, ?     	;定义变量,分配4个1B空间,未置初值</span><br><span class="line">		DD		123456h,? 		;分配2个4B空间</span><br><span class="line"></span><br><span class="line">取’H‘：</span><br><span class="line">MOV AL, Msg</span><br><span class="line">取’e’：</span><br><span class="line">MOV AL, Msg+1</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Msg		DB		&quot;Hello&quot;</span><br><span class="line">		DB		13, 10, &quot;$&quot;</span><br><span class="line">Cnt		DW		5*20, -2</span><br><span class="line">L		DD		1234A1B2h, 87654321h</span><br><span class="line">F		DQ		1.5</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903234937787.png" alt="image-20230903234937787" style="zoom:50%;" /> 
<ul>
<li>示例3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Msg	DB	&quot;Hello&quot; 13, 10, &quot;$&quot;</span><br><span class="line">p1	DW	Msg, Msg+5</span><br><span class="line">p2	DD	Msg, Msg+5</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903235205880.png" alt="image-20230903235205880" style="zoom:50%;" /> 
<ul>
<li>示例4</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1	DB	&quot;你好&quot;, 2 DUP(&#x27;!&#x27;), 2 DUP (&#x27;A&#x27;, &#x27;B&#x27;), 3 DUP(1, 2, 2 DUP(&#x27;$&#x27;))</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230903235425341.png" alt="image-20230903235425341" style="zoom:50%;" /> 
<ul>
<li>示例5</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Variable	DW	100 DUP(0)</span><br><span class="line">用变量名表示的内存操作数寻址为</span><br><span class="line">直接寻址：			 MOV	AX, Variable</span><br><span class="line">寄存器相对寻址：	   MOV	  AX, Variable [SI]</span><br><span class="line">相对基址变址寻址：	  MOV	 AX, Variable [BX][DI]</span><br><span class="line">比例因子寻址：			MOV	   EAX, DWord Ptr Variable [EBX][4*ECX]</span><br></pre></td></tr></table></figure>
<h4 id="（3）标号">（3）标号</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>
<p>标号表示的是指令在内存中存放的位置</p>
</li>
<li>
<p>标号定义的格式是：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名:</span><br></pre></td></tr></table></figure>
<p>表示标号后首条指令在内存中地址。</p>
<blockquote>
<p>标号既可以定义在目的指令同一行的最前面，</p>
<p>也可以在目的指令前一行单独用一行定义。</p>
</blockquote>
</li>
<li>
<p>属性</p>
<ul>
<li>
<p>地址属性</p>
<p>标号代表的是其后首条指令在内存中地址</p>
<ul>
<li>用<strong>SEG</strong>来返回标号所在段的段地址</li>
<li>用<strong>OFFSET</strong>来返回标号所在段的偏移地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,SEG loc1			;将loc1的段地址送到AX</span><br><span class="line">MOV BX,OFFSET loc1		;将loc1的偏移地址送到BX</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型属性</p>
<p>标号具有NEAR和FAR两种属性，其类型值分别为-1和-2</p>
<p>可用<strong>运算符TYPE</strong>返回其类型值</p>
</li>
</ul>
</li>
</ul>
<h4 id="（4）变量名和标号的其他定义方式">（4）变量名和标号的其他定义方式</h4>
<ul>
<li>
<p>用LABEL和EQU来定义变量名或标号</p>
<ul>
<li>标识符 LABEL 类型</li>
<li>标识符 EQU THIS 类型</li>
</ul>
</li>
<li>
<p>功能：</p>
<ul>
<li>
<p>定义一个指定类型的变量名或标号类型为BYTE, WORD, DWORD, FWORD, QWORD和TBYTE等，则定义变量名</p>
</li>
<li>
<p>类型是NEAR和FAR，则定义标号</p>
</li>
</ul>
</li>
<li>
<p>只是<strong>将当前地址定义为一个变量名或标号</strong>，<strong>并不为它们分配内存空间</strong></p>
</li>
<li>
<p>示例1</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bVariable	LABEL	BYTE</span><br><span class="line">wVariable	DW	100</span><br><span class="line">第一条伪指令仅仅定义了一个具有字节类型的变量名，但并没有为它分配存储空间；</span><br><span class="line">第二条伪指令定义了一个字类型的变量，而且为它分配了2字节的存储空间。</span><br><span class="line">符号地址bVariable与wVariable代表的是同一个地址，但具有不同的数据类型属性。</span><br><span class="line"></span><br><span class="line">Loc   LABEL   FAR</span><br><span class="line">定义了一个具有远转移类型的标号，该标号指向其后第一条汇编指令的存放地址。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wVariable	EQU THIS	DWORD</span><br><span class="line">dwVariable	DD			100</span><br><span class="line">第一条伪指令仅仅定义了一个具有2字节类型的变量名，但并没有为它分配存储空间；</span><br><span class="line">第二条伪指令定义了一个4字节类型的变量，而且为它分配了4字节的存储空间。</span><br><span class="line">符号地址dwVariable与wVariable代表的是同一个地址，但具有不同的数据类型属性。</span><br><span class="line"></span><br><span class="line">Loc   EQU THIS   NEAR</span><br><span class="line">定义了一个具有近转移类型的标号，该标号指向其后第一条汇编指令的存放地址。</span><br></pre></td></tr></table></figure>
<h3 id="4-3-表达式和运算符">4.3 表达式和运算符</h3>
<ul>
<li>
<p>将常数、符号地址及其符号常量用运算符连接起来的有意义的式子</p>
</li>
<li>
<p>值的计算是在源程序汇编过程中完成的</p>
</li>
<li>
<p>运算符分为：</p>
<ul>
<li>算术运算符</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012401011.png" alt="image-20230904012401011" style="zoom:50%;" /> 
<ul>
<li>逻辑运算符</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012425615.png" alt="image-20230904012425615" style="zoom:50%;" /> 
<ul>
<li>关系运算符</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012444725.png" alt="image-20230904012444725" style="zoom:50%;" /> 
<ul>
<li>数值返回运算符</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012504628.png" alt="image-20230904012504628" style="zoom:50%;" /> 
<ul>
<li>属性运算符</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012522665.png" alt="image-20230904012522665" style="zoom:50%;" /> 
<ul>
<li>字节分离运算符</li>
</ul>
</li>
</ul>
<h3 id="4-4-MASM的基本伪指令">4.4 MASM的基本伪指令</h3>
<blockquote>
<p>伪指令在汇编程序对源程序汇编期间由汇编程序处理的操作，它们可以完成诸如定义程序段、定义数据、分配存储区和指示程序结束等功能。伪指令在形式上与一般指令相似，但伪指令只是为汇编程序提供有关信息，不产生相应的机器代码。</p>
</blockquote>
<h4 id="指令集选择伪指令">指令集选择伪指令</h4>
<ul>
<li>
<p>MASM在默认情况下只接受8086指令集。</p>
<p>如果程序员需要使用8086以后微处理器新增加的指令，必须使用指令集选择伪指令。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230904012739548.png" alt="image-20230904012739548" style="zoom:50%;" /> 
<h4 id="完整的段定义伪指令">完整的段定义伪指令</h4>
<ul>
<li>
<p>使用完整的段定义伪指令来定义一个段，</p>
<p>可具体控制汇编程序MASM和连接程序LINK在内存中组织代码和数据的方式</p>
</li>
<li>
<p>格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 SEGMENT [定位类型] [组合方式] [地址模式] [&#x27;分类名&#x27;]</span><br><span class="line">		…</span><br><span class="line">段名 ENDS</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>功能</p>
<p>在程序中定义一个逻辑段，指定段的名字和范围，段在内存中的起始位置，以及段与段之间的连接关系。</p>
</li>
<li>
<p>段指定伪指令ASSUME</p>
</li>
<li>
<p>段组定义伪指令GROUP</p>
</li>
<li>
<p>源程序开始与结束伪指令</p>
<ul>
<li>
<p>源程序开始伪指令</p>
</li>
<li>
<p>源程序结束伪指令END</p>
</li>
<li>
<p>数据定义伪指令</p>
</li>
<li>
<p>符号定义指令</p>
<ul>
<li>等值伪指令EQU</li>
<li>等号伪指令＝</li>
</ul>
<blockquote>
<p>与EQU THIS不一样，</p>
<p>EQU THIS是定义一个<strong>符号地址</strong>。</p>
<p>EQU是定义一个为常量、表达式及其他符号定义一个<strong>符号名</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-地址计数器与对准伪指令">4.5 地址计数器与对准伪指令</h3>
<ul>
<li>
<p>地址计数器<code>$</code></p>
<ul>
<li>指示当前正在处理的汇编指令或伪指令所在处的偏移地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）当$用在指令中时，它表示该指令的第一个字节的地址。例如，</span><br><span class="line">JNE $+6</span><br><span class="line">转向地址是JNE指令的首地址加上6。</span><br><span class="line"></span><br><span class="line">（2）当$用在数据定义等伪指令的参数字段时，表示的是地址计数器的当前值。例如，</span><br><span class="line">ARRAY	DW	1, 2, $, 3, 4, $</span><br><span class="line">假设汇编时ARRAY分配的偏移地址为0074，则汇编后的存储区内容如下：</span><br><span class="line">ARRAY→ 01 00 02 00 78 00 03 00 04 00 7E 00</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定位伪指令<code>ORG</code></p>
<ul>
<li>将地址计数器设置到指定的位置</li>
</ul>
<p>用在数据段中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_DEMO	SEGMENT</span><br><span class="line">ORG	10</span><br><span class="line">V1		DW		47A5h</span><br><span class="line">ORG	$+3</span><br><span class="line">V2		DW		5C96h</span><br><span class="line">_DEMO	ENDS </span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905164729590.png" alt="image-20230905164729590" style="zoom:50%;" /> 
<p>用在代码段中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">		ORG		100h</span><br><span class="line">		JMP		Loc</span><br><span class="line">		ORG		200h</span><br><span class="line">Loc:	MOV		AX, 1200h</span><br></pre></td></tr></table></figure>
<p>那么指令<code>JMP Loc</code>存放的地址为100h，</p>
<p>同理指令<code>MOV AX, 1200h</code>存放的地址为200h，</p>
<p>而100h～200h的存储空间中，除了JMP指令外，其余内容均为未初始化内容。</p>
</li>
<li>
<p>其他伪指令</p>
<ul>
<li>
<p>EVEN伪指令</p>
<p>使下一个变量或指令开始于偶数地址处。</p>
</li>
<li>
<p>ALIGN伪指令</p>
<p>使下一个变量或指令开始于2^n^整数倍地址处。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-6-子程序定义PROC和ENDP">4.6 子程序定义PROC和ENDP</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 PROC　[NEAR/FAR] </span><br><span class="line">　… ;子程序体   </span><br><span class="line">子程序名 ENDP</span><br></pre></td></tr></table></figure>
<p>子程序名是子程序的入口地址的符号表示，是符号地址，也具有地址属性和类型属性。</p>
<h3 id="4-7-其他伪指令">4.7 其他伪指令</h3>
<ul>
<li>
<p>注释伪指令COMMENT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：COMMENT 分隔符 注释内容 分隔符。</span><br><span class="line">功能：分隔符之间的任何内容均作为注释内容，但分隔符本身不能出现在注释内容中。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文件包含伪指令INCLUDE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：INCLUDE文件名。</span><br><span class="line">功能：在源程序中，将一个外部文件插入到此伪指令所在处。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>全局符号名说明伪指令PUBLIC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：PUBLIC符号名1[, 符号名2, …]。</span><br><span class="line">功能：将本模块中定义的一个或多个符号名说明为全局符号，这样在其他模块中可以引用该符号。</span><br><span class="line"> - 符号名可以是变量、符号常量、标号或过程名。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>外部符号名说明伪指令EXTRN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：EXTRN符号名1:类型[, 符号名2:类型, …]。</span><br><span class="line">功能：说明本模块中将要引用的外部模块中的符号名，类型：Byte, Word, DWord, FWord, QWord, TByte, Near, Far；常数则是ABS。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-8-MASM的宏汇编伪指令">4.8 MASM的宏汇编伪指令</h3>
<ul>
<li>
<p>宏指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宏指令名 MACRO [形式参数1,形式参数2,…,形式参数n] </span><br><span class="line">  …		; 宏指令体(宏体) </span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>宏操作符</p>
<p><code>连接运算符&amp;</code>、<code>文本操作符&lt;&gt;</code>、<code>表达式操作符%</code>、<code>字符操作符!</code></p>
</li>
<li>
<p>宏库中的宏指令</p>
<p>可在源程序中使用包含伪指令INCLUDE</p>
</li>
</ul>
</li>
<li>
<p>重复汇编</p>
<p>固定重复伪指令REPT，不定重复伪指令IRP和单字符参数的不定重复伪指令IRPC，均以ENDM作为结束标志</p>
</li>
<li>
<p>条件汇编</p>
<p>根据某些条件是否成立(为真)来决定是否汇编某一段代码</p>
</li>
<li>
<p>结构、联合和记录</p>
<p>类似C语言的结构体、共用体复合数据类型的定义</p>
</li>
<li>
<p>示例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例：定义了宏指令ExitToDos和InOutStr，并在在代码段中调用它们</span><br><span class="line"></span><br><span class="line">ExitToDOS MACRO</span><br><span class="line">	MOV	AX, 4C00h</span><br><span class="line">	INT	21h</span><br><span class="line">	ENDM</span><br><span class="line">InOutStr MACRO Fun,str</span><br><span class="line">	MOV	AH, Fun</span><br><span class="line">	LEA	DX, str</span><br><span class="line">	INT	21h</span><br><span class="line">	ENDM</span><br><span class="line"></span><br><span class="line">_STACK SEGMENT STACK</span><br><span class="line">	DB 32766 DUP (?)</span><br><span class="line">TOS	DW ?</span><br><span class="line">_STACK ENDS</span><br><span class="line"></span><br><span class="line">_DATA	SEGMENT</span><br><span class="line">Msg	DB &#x27;Hello, World!&#x27;,13,10,&#x27;$&#x27;</span><br><span class="line">_DATA	ENDS</span><br><span class="line"></span><br><span class="line">_TEXT	SEGMENT &#x27;CODE&#x27;</span><br><span class="line">ASSUME CS:_TEXT,DS:_DATA,SS:_STACK</span><br><span class="line">Start:	MOV	AX, _DATA</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">	CLI</span><br><span class="line">	MOV	AX, _STACK</span><br><span class="line">	MOV	SS, AX</span><br><span class="line">	MOV	SP, Offset TOS</span><br><span class="line">	STI</span><br><span class="line">	InOutStr	9, Msg</span><br><span class="line">	ExitToDOS</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
<h3 id="4-9-span-id-jump-count-算术运算指令-span">4.9 <span id="jump_count">算术运算指令</span></h3>
<h4 id="（1）加法">（1）加法</h4>
<ol>
<li>
<p><strong>ADD指令</strong><br>
格式：ADD目的操作数，源操作数。<br>
功能：将源操作数与目的操作数相加，结果存入目的操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD reg, reg/mem/imm</span><br><span class="line">ADD mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果置CF, AF, PF, ZF, SF, OF的状态</p>
</li>
<li>
<p><strong>ADC指令</strong><br>
格式：ADC目的操作数，源操作数。<br>
功能：即将源操作数、目的操作数<strong>和CF相加</strong>，结果存入目的操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADC reg, reg/mem/imm</span><br><span class="line">ADC mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果置CF, AF, PF, ZF, SF, OF状态</p>
</li>
<li>
<p><strong>INC指令</strong><br>
格式：INC 操作数。<br>
功能：操作数自身加1，即将操作数加1，结果再存入操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC reg/mem </span><br></pre></td></tr></table></figure>
<p>影响AF, PF, ZF, SF和OF，<strong>不影响CF</strong></p>
</li>
</ol>
<h4 id="（2）减法">（2）减法</h4>
<ol>
<li>
<p><strong>SUB指令</strong></p>
<p>格式：SUB 目的操作数，源操作数。<br>
功能：目的操作数减去源操作数，结果存入目的操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB reg, reg/mem/imm；</span><br><span class="line">SUB mem, reg/imm。</span><br></pre></td></tr></table></figure>
<p>根据结果置CF, AF, PF, ZF, SF, OF的状态</p>
</li>
<li>
<p><strong>SBB指令</strong></p>
<p>格式：SBB 目的操作数，源操作数。<br>
功能：目的操作数减去源操作数，再减去CF，结果存入目的操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SBB reg, reg/mem/imm；</span><br><span class="line">SBB mem, reg/imm。</span><br></pre></td></tr></table></figure>
<p>根据结果置CF, AF, PF, ZF, SF, OF的状态</p>
</li>
<li>
<p><strong>DEC指令</strong></p>
<p>格式：DEC 操作数。<br>
功能：操作数自身减1，即操作数减去1，结果再存入操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEC reg/mem</span><br></pre></td></tr></table></figure>
<p>影响AF, PF, ZF, SF和OF，<strong>不影响CF</strong></p>
</li>
</ol>
<h4 id="（3）求补">（3）求补</h4>
<ol>
<li>
<p><strong>NEG指令</strong></p>
<p>格式：NEG 操作数。<br>
功能：操作数各位取反再加1(求补)，即将0减去操作数，结果存入操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEG reg/mem</span><br></pre></td></tr></table></figure>
<p>影响CF, AF, PF, ZF, SF, OF。</p>
<blockquote>
<p>只有当操作数为0时，才使CF＝0，其他情况则均为1；<br>
只有当操作数为-2^7^(8位运算)或-2^15^(16位运算)或-2^31^(32位运算)时，才使OF＝1，其他情况则均为0。</p>
</blockquote>
</li>
</ol>
<h4 id="（4）比较">（4）比较</h4>
<ol>
<li>
<p><strong>CMP指令</strong></p>
<p>格式：CMP 目的操作数，源操作数。<br>
功能：两操作数比较大小，根据目的操作数减去源操作数的运算结果，从而设置标志位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP reg, reg/mem/imm</span><br><span class="line">CMP mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>该指令影响CF, AF, PF, ZF, SF, OF。<br>
这条指令除了<strong>相减结果不保存</strong>外，其他情况与SUB指令完全相同</p>
</li>
</ol>
<h4 id="（5）乘法">（5）乘法</h4>
<ul>
<li>
<p><strong>MUL无符号数乘法</strong></p>
</li>
<li>
<p><strong>IMUL有符号数乘法</strong></p>
</li>
</ul>
<p>格式：MUL/IMUL 源操作数<br>
功能：无/有符号数乘指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL/IMUL reg/mem</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905171946359.png" alt="image-20230905171946359" style="zoom: 50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905172010743.png" alt="image-20230905172010743" style="zoom: 50%;" /> 
<p>两者的区别在于：</p>
<p>MUL的操作数内容看作无符号数</p>
<p>IMUL操作数内容看作补码</p>
<p><strong>影响CF和OF,不影响其他标志位</strong></p>
<ul>
<li>MUL，乘积的高半部分为0，则CF和OF均为0，否则CF和OF均为1</li>
<li>IMUL，乘积的高半部分是低半部分的符号扩展，则CF和OF均为0，否则均为1。</li>
</ul>
<p>通过测试这两个标志位，就能够知道乘积的高半部分是否有效数字 。</p>
<h4 id="（6）除法">（6）除法</h4>
<ul>
<li>
<p><strong>DIV无符号数除法</strong></p>
</li>
<li>
<p><strong>IDIV有符号数除法</strong></p>
</li>
</ul>
<p>要求被除数的位数必须是除数的两倍</p>
<p>格式：DIV/IDIV源操作数<br>
功能：无/有符号数除法指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV/IDIV reg/mem</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905172351909.png" alt="image-20230905172351909" style="zoom:50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905172400510.png" alt="image-20230905172400510" style="zoom:50%;" /> 
<p>两者的区别在于：</p>
<p>DIV的操作数是无符号数，商和余数均为无符号数；</p>
<p>IDIV操作数是补码，商和余数均为有符号数，余数符号与被除数符号相同。</p>
<ul>
<li>
<p>可能导致两类错误：除数为零，商溢出。</p>
</li>
<li>
<p>当除法运算所得的商超过表示范围时，就产生商溢出。</p>
</li>
<li>
<p>除法指令<strong>对所有标志位无定义</strong></p>
</li>
</ul>
<h3 id="4-10-span-id-jump-logic-逻辑运算指令-span">4.10 <span id="jump_logic">逻辑运算指令</span></h3>
<blockquote>
<p>逻辑指令包括逻辑运算指令和移位指令</p>
</blockquote>
<h4 id="（1）逻辑运算指令">（1）逻辑运算指令</h4>
<h5 id="五个指令">五个指令</h5>
<ul>
<li>
<p>逻辑运算是按位操作的，包括：AND, OR, NOT, XOR和TEST指令。</p>
</li>
<li>
<p><strong>AND指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND reg, reg/mem/imm</span><br><span class="line">AND mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果置SF, ZF和PF，<strong>CF=0，OF=0</strong>，AF无定义。</p>
</li>
<li>
<p><strong>OR指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OR reg, reg/mem/imm</span><br><span class="line">OR mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果置SF, ZF和PF，<strong>CF=0，OF=0</strong>，AF无定义</p>
</li>
<li>
<p><strong>NOT指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT reg/mem</span><br></pre></td></tr></table></figure>
<p><strong>不影响标志位</strong></p>
</li>
<li>
<p><strong>XOR指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XOR reg, reg/mem/imm</span><br><span class="line">XOR mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果设置SF, ZF和PF，<strong>CF=0，OF=0</strong>，AF无定义</p>
</li>
<li>
<p><strong>TEST指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEST reg, reg/mem/imm</span><br><span class="line">TEST mem, reg/imm</span><br></pre></td></tr></table></figure>
<p>根据结果置SF, ZF和PF，<strong>CF=0，OF=0</strong>，AF无定义</p>
<blockquote>
<p>TEST与AND都是两操作数按位“逻辑与”，但<strong>TEST的结果不保存</strong>。</p>
</blockquote>
</li>
</ul>
<h5 id="常用逻辑">常用逻辑</h5>
<ul>
<li>
<p>指定位清0</p>
<p>AND需清0的位赋0,其他位赋1</p>
</li>
<li>
<p>指定位置1</p>
<p>OR需置1的位赋1,其他位赋0</p>
</li>
<li>
<p>指定位变反</p>
<p>XOR需变反的位赋1,其他位赋0</p>
</li>
</ul>
<h4 id="（2）移位运算指令">（2）移位运算指令</h4>
<ul>
<li>
<p>按规定的方式，对目的操作数执行向左或向右移动若干个二进制位数的操作。</p>
<p>包括：</p>
<ul>
<li>
<p>逻辑移位指令</p>
<p>SHL、SHR</p>
</li>
<li>
<p>算术移位指令（移位后正负号 不变 ）</p>
<p>SAL、SAR</p>
</li>
<li>
<p>循环移位指令</p>
<p>ROL、ROR、RCL、RCR</p>
</li>
</ul>
</li>
</ul>
<h5 id="逻辑移位"><strong>逻辑移位</strong></h5>
<ol>
<li>
<p><strong>SHL指令</strong><br>
格式：SHL 目的操作数，移动位数。<br>
功能：目的操作数逻辑<strong>左移，最后移出的位进入CF，最低位用0填充</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHL reg/mem, imm8/CL</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在左移1位时有效，否则不确定。<br>
<strong>左移1位后，若符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905173934473.png" alt="image-20230905173934473" style="zoom:50%;" /> 
</li>
<li>
<p><strong>SHR指令</strong></p>
<p>格式：SHR目的操作数，移动位数。<br>
功能：目的操作数逻辑<strong>右移，最后移出的位进入CF，最高位用0填充</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHR reg/mem, imm8/CL。</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在右移1位时有效，否则不确定。<br>
<strong>右移1位后符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905173944234.png" alt="image-20230905173944234" style="zoom:50%;" /> 
</li>
</ol>
<h5 id="算术移位">算术移位</h5>
<p>（移位后正负号 不变 ）</p>
<ol>
<li>
<p><strong>SAL指令</strong></p>
<p>格式：SAL目的操作数，移动位数。<br>
功能：<strong>算术左移</strong>指令。</p>
<p>SAL与SHL是同一条指令，即一个操作码对应的两个助记符</p>
</li>
<li>
<p><strong>SAR指令</strong></p>
<p>格式：SAR 目的操作数，移动位数。<br>
功能：目的操作数<strong>算术右移，最后移出的位进入CF，高位用符号位填充</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAR reg/mem, imm8/CL</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在右移1位时有效，否则不确定。<br>
<strong>右移1位后，OF=0</strong></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905174152094.png" alt="image-20230905174152094" style="zoom:50%;" /> 
</li>
</ol>
<h5 id="循环移位1">循环移位1</h5>
<ol>
<li>
<p><strong>ROL指令</strong></p>
<p>格式：ROL目的操作数，移动位数。<br>
功能：目的操作数<strong>循环左移，最后移出的位进CF</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROL reg/mem</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在左移1位时有效，否则不确定。<br>
<strong>左移1位后，若符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905174459195.png" alt="image-20230905174459195" style="zoom:50%;" /> 
</li>
<li>
<p><strong>ROR指令</strong></p>
<p>格式：ROR 目的操作数，移动位数。<br>
功能：目的操作数<strong>循环右移，最后移出的位进CF</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROR reg/mem, imm8/CL</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在右移1位时有效，否则不确定。<br>
<strong>右移1位后，若符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905174745980.png" alt="image-20230905174745980" style="zoom:50%;" /> 
</li>
</ol>
<h5 id="循环移位2">循环移位2</h5>
<ol>
<li>
<p><strong>RCL指令</strong></p>
<p>格式：RCL 目的操作数，移动位数。<br>
功能：目的操作数<strong>和CF一起循环左移</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCL reg/mem, imm8/CL</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在左移1位时有效，否则不确定。<br>
<strong>左移1位后，若符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905174905476.png" alt="image-20230905174905476" style="zoom:50%;" />  
</li>
<li>
<p><strong>RCR指令</strong></p>
<p>格式：RCR目的操作数，移动位数。<br>
功能：目的操作数<strong>和CF一起循环右移</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCR reg/mem, imm8/CL</span><br></pre></td></tr></table></figure>
<p>影响CF, OF, SF, ZF, PF，而AF不确定。</p>
<blockquote>
<p>OF在右移1位时有效，否则不确定。<br>
<strong>右移1位后，若符号位改变，OF=1</strong>，否则OF=0</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905174948402.png" alt="image-20230905174948402" style="zoom:50%;" />  
</li>
</ol>
<h2 id="第五课-转移、选择、循环">第五课 转移、选择、循环</h2>
<h3 id="5-1-span-id-jump-jmp-转移指令-span">5.1 <span id="jump_jmp">转移指令</span></h3>
<ul>
<li>
<p><code>CS:(E)IP</code>指向下一条要执行的指令在内存中的地址，</p>
<p>控制转移指令实际上通过改变<code>CS:(E)IP</code>来达到控制程序的执行流程。</p>
<p>包括：</p>
<ul>
<li>无条件转移指令</li>
<li>条件转移指令</li>
<li>循环指令</li>
<li>子程序调用和返回指令</li>
<li>中断调用和中断返回指令</li>
</ul>
<p><code>JMP，JccCALL，RETINT，IRET</code></p>
</li>
<li>
<p>转移</p>
<ul>
<li>仅能改变<code>(E)IP</code>，是近转移或段内转移</li>
<li>能改变<code>(E)IP</code>和<code>CS</code>，是远转移或段间转移</li>
</ul>
</li>
</ul>
<h4 id="（1）无条件转移">（1）无条件转移</h4>
<ul>
<li>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP	目标地址</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>功能：无条件转移到目标地址，执行从该地址开始的指令序列</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	MOV		AX, A</span><br><span class="line">	CMP		AX, B</span><br><span class="line">	JNA		loc2</span><br><span class="line">	MOV		X, 1</span><br><span class="line">	JMP		loc3</span><br><span class="line">loc2:</span><br><span class="line">	MOV	X, 2</span><br><span class="line">loc3:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h4 id="（2）条件转移">（2）条件转移</h4>
<ul>
<li>
<p>条件</p>
<ul>
<li>条件满足时则转移，条件不满足时，则顺序执行后面的指令</li>
<li>具体条件见下面的指令
<ul>
<li>单个标志位的条件</li>
<li>无符号数比较的条件</li>
<li>有符号数比较的条件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>格式</p>
<p>常用Jcc来代表这类指令的助记符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jcc	标号</span><br></pre></td></tr></table></figure>
<p>条件转移指令都是段内直接近转移</p>
</li>
</ul>
<h5 id="单个标志位">单个标志位</h5>
<ul>
<li>Z、S、C、O、P均有各种的指令</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905180521286.png" alt="image-20230905180521286" style="zoom:50%;" /> 
<blockquote>
<p>简记：</p>
<p>记住<code>JE</code>、<code>JNE</code>为相等则跳转、不相等则跳转。</p>
</blockquote>
<h5 id="无符号数比较">无符号数比较</h5>
<ul>
<li>无符号数比较时，根据CF来判断大小</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905180708147.png" alt="image-20230905180708147" style="zoom:50%;" /> 
<blockquote>
<p>简记：</p>
<ul>
<li>A为无符号大</li>
<li>B为无符号小</li>
<li>拼加N、E</li>
</ul>
</blockquote>
<h5 id="有符号数比较">有符号数比较</h5>
<ul>
<li>有符号数比较时，根据SF和OF来确定大小</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905181049991.png" alt="image-20230905181049991" style="zoom:50%;" /> 
<blockquote>
<p>简记：</p>
<ul>
<li>G为有符号大 Greater</li>
<li>L为有符号小 Less</li>
<li>拼加N、E</li>
</ul>
</blockquote>
<h3 id="5-2-span-id-jump-loop-循环指令-span">5.2 <span id="jump_loop">循环指令</span></h3>
<ul>
<li>
<p>主要使用LOOP指令比较多</p>
</li>
<li>
<p>LOOP会以<code>CX</code>寄存器存着的值作为循环次数，进行循环跳转</p>
<p>执行到<code>LOOP  LOC1</code>，</p>
<p>会先执行<code>CX - 1</code>，</p>
<p>再判断：</p>
<ul>
<li><code>CX</code>不等于0：跳转到<code>LOC1</code>位置执行</li>
<li><code>CX</code>等于0：循环结束，执行<code>LOOP  LOC1</code>后面的语句</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905181644577.png" alt="image-20230905181644577" style="zoom: 67%;" /> 
<h3 id="5-3-其他指令">5.3 其他指令</h3>
<h4 id="（1）标志位处理指令">（1）标志位处理指令</h4>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905182143234.png" alt="image-20230905182143234" style="zoom: 67%;" /> 
<h4 id="（2）其他指令">（2）其他指令</h4>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905182302120.png" alt="image-20230905182302120" style="zoom:67%;" /> 
<h2 id="第六课-子程序调用">第六课 子程序调用</h2>
<h3 id="6-1-子程序定义">6.1 子程序定义</h3>
<ul>
<li>
<p>子程序定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子程序名 PROC　[NEAR/FAR] </span><br><span class="line">　… ;子程序体   </span><br><span class="line">子程序名 ENDP</span><br></pre></td></tr></table></figure>
<p>子程序名是子程序的入口地址的符号表示，</p>
<p>是符号地址，也具有地址属性和类型属性。</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>当主调程序转向子程序时，使用调用指令，而在子程序执行结束时，安排一条返回指令，使子程序返回到主程序。</p>
</li>
<li>
<p>为保证正确的返回，</p>
<p>(1)调用子程序时，自动将下一条指令地址保存到栈中，</p>
<p>(2)返回时根据栈中先前保存的地址，转移到主程序继续执行。</p>
</li>
<li>
<p>子程序调用与返回指令是配套使用的</p>
</li>
</ul>
</blockquote>
<h3 id="6-2-CALL指令">6.2 CALL指令</h3>
<ul>
<li>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL 目标地址</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>功能：</p>
<p>把该指令之后的地址进栈，再转移到目标地址，执行从该处指令。</p>
<p>有直接调用和间接调用两种方式。</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>直接调用的CALL指令后也可以是标号，</p>
<p>但是要遇到RET才会返回，否则会无法退出。</p>
</li>
</ul>
</blockquote>
<h3 id="6-3-RET指令">6.3 RET指令</h3>
<ul>
<li>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RET/RET [imm16]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>功能：</p>
<p>首先从栈栈顶弹出返回的目标地址，然后转移到该地址处执行。</p>
<blockquote>
<p>若其后有imm16，则还要执行</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905184126486.png" alt="image-20230905184126486" style="zoom:50%;" /> 
</blockquote>
<p>与CALL指令配套使用，实现从子程序中返回，继续主程序的执行 。</p>
</li>
</ul>
<h3 id="6-4-寄存器的保护与恢复">6.4 寄存器的保护与恢复</h3>
<ul>
<li>
<p>主程序和子程序通常是分别编制的，所以它们所使用的寄存器往往会发生冲突。</p>
<ul>
<li>
<p>进入子程序后，把子程序所需要使用的寄存器内容保存在栈中，此过程称作寄存器保护</p>
</li>
<li>
<p>在退出子程序前把寄存器内容恢复原状，此过程称作寄存器恢复</p>
</li>
</ul>
</li>
<li>
<p>寄存器保护与现场恢复分别使用压栈和出栈指令实现</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CRLF	PROC	Far	;子程序定义开始,属性类型为Far</span><br><span class="line">	PUSH	AX	;AX寄存器内容的保护</span><br><span class="line">	PUSH	DX	;DX寄存器内容的保护</span><br><span class="line">	MOV	AH, 2</span><br><span class="line">	MOV	DL, 13</span><br><span class="line">	INT	21h</span><br><span class="line">	MOV	DL, 10</span><br><span class="line">	INT	21h</span><br><span class="line">	POP	DX	;AX寄存器内容的恢复</span><br><span class="line">	POP	AX	;DX寄存器内容的恢复</span><br><span class="line">	RET	;返回调用程序(远返回指令,由汇编程序确定)</span><br><span class="line">CRLF	ENDP	;子程序定义结束</span><br></pre></td></tr></table></figure>
<p>根据需要，可用PUSHF和POPF来保护和恢复标志位。</p>
<h3 id="6-5-参数传递">6.5 参数传递</h3>
<ul>
<li>
<p>参数传递</p>
<p>主程序在调用子程序时，经常要向子程序传递一些参数或控制信息，子程序执行后，也常需要把运行的结果返回调用程序。这种信息传递称为参数传递。</p>
</li>
<li>
<p>常用的方法有：</p>
<ul>
<li>约定寄存器传递参数</li>
<li>约定内存单元传递参数</li>
<li>栈传递参数</li>
</ul>
<p>经常同时并用。</p>
</li>
</ul>
<h3 id="6-6-静态变量与动态变量">6.6 静态变量与动态变量</h3>
<ul>
<li>
<p>静态</p>
<p>在**段(数据段)**中定义分配的数据是静态数据。</p>
<p>通过DW等伪指令定义并分配存储空间，可用变量名,或直接地址访问相应的内存单元。</p>
</li>
<li>
<p>动态</p>
<p>在<strong>栈</strong>上分配存储空间来临时使用是动态数据。</p>
<ul>
<li>原则：进入子程序，分配临时空间；子程序执行结束，释放临时空间</li>
<li>方法：通过调整栈指针来分配空间</li>
<li>访问：以 (E)BP为基址，用位移量来存取临时变量（因为动态分配，没有名字）</li>
</ul>
</li>
<li>
<p>示例</p>
<p>编写程序计算(x % m + y % m + z % m) % m的值，其中x, y, z为32位无符号数，m是16位无符号数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">foo	PROC	FAR</span><br><span class="line">	PUSH	BP	;保护基址指针</span><br><span class="line">	MOV	BP,SP	;设置新栈帧</span><br><span class="line">	SUB	SP,6	;分配临时空间</span><br><span class="line">	PUSH	DX</span><br><span class="line">	MOV	AX,[BP+16] </span><br><span class="line">	MOV	DX,[BP+18]</span><br><span class="line">	DIV	Word Ptr[BP+6]</span><br><span class="line">	MOV	[BP-2],DX ;保存余数</span><br><span class="line">	MOV	AX,[BP+12]</span><br><span class="line">	MOV	DX,[BP+14]</span><br><span class="line">	DIV	Word Ptr[BP+6]</span><br><span class="line">	MOV	[BP-4],DX ;保存余数</span><br><span class="line">	MOV	AX,[BP+8]</span><br><span class="line">	MOV	DX,[BP+10]</span><br><span class="line">	DIV	Word Ptr[BP+6]</span><br><span class="line">	MOV	[BP-6],DX ;保存余数</span><br><span class="line">	SUB	DX,DX</span><br><span class="line">	MOV	AX,[BP-2]</span><br><span class="line">	ADD	AX,[BP-4]</span><br><span class="line">	ADC	DX,0</span><br><span class="line">	ADD	AX, [BP-6]</span><br><span class="line">	ADC	DX, 0</span><br><span class="line">	DIV	Word Ptr[BP+6]</span><br><span class="line">	MOV	AX, DX</span><br><span class="line">	POP	DX</span><br><span class="line">	ADD	SP,6 ;释放临时空间</span><br><span class="line">	MOV	SP, BP</span><br><span class="line">	POP	BP</span><br><span class="line">	RET</span><br><span class="line">foo	ENDP</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-7-子程序的嵌套与递归调用">6.7 子程序的嵌套与递归调用</h3>
<ul>
<li>
<p>一个子程序包含有子程序的调用，这便是子程序的嵌套调用。</p>
</li>
<li>
<p>一个程序直接或间接地调用自身就是子程序的递归调用，它递归子程序。</p>
</li>
<li>
<p>设计递归子程序</p>
<ul>
<li>每次调用的参数进栈</li>
<li>在栈上分配动态空间保存中间结果</li>
</ul>
</li>
<li>
<p>示例</p>
<p>编写求n!的递归子程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">f	PROC	NEAR</span><br><span class="line">	PUSH	BP	;保护基址指针</span><br><span class="line">	MOV	BP, SP	;设置新栈帧</span><br><span class="line">	SUB	SP, 2	;分配临时空间</span><br><span class="line">	MOV	AX, [BP+4] 	;取n</span><br><span class="line">	MOV	[BP-2], AX</span><br><span class="line">	CMP	AX, 1</span><br><span class="line">	JE	L10</span><br><span class="line">	DEC	AX</span><br><span class="line">	PUSH	AX</span><br><span class="line">	CALL	f	;调用递归子程序</span><br><span class="line">	ADD	SP, 2</span><br><span class="line">	PUSH	DX</span><br><span class="line">	MUL	Word Ptr [BP-2]	;n×(n-1)!</span><br><span class="line">	POP	DX</span><br><span class="line">L10:	MOV	SP, BP</span><br><span class="line">	POP	BP</span><br><span class="line">	RET</span><br><span class="line">f	ENDP</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905185118581.png" alt="image-20230905185118581" style="zoom:50%;" /> 
</li>
</ul>
<h3 id="6-8-多模块程序设计">6.8 多模块程序设计</h3>
<ul>
<li>
<p>一个汇编语言程序可以划分成主模块和多级、多个子模块。</p>
</li>
<li>
<p>每个模块的源程序都是以END伪指令来结束，</p>
<p>但是只有主模块中的END后可以接标号，以表示程序的入口地址，</p>
<p>其他模块中的END后不能有标号。</p>
</li>
</ul>
<h4 id="全局符号与外部符号">全局符号与外部符号</h4>
<ul>
<li>PUBLIC伪指令与EXTRN伪指令配套使用。</li>
</ul>
<ol>
<li>
<p>全局符号名说明伪指令<strong>PUBLIC</strong><br>
格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC符号名1[, 符号名2, …]</span><br></pre></td></tr></table></figure>
<p>功能：将符号名说明为全局符号，以便其他模块引用<br>
符号名：变量、标号或子程序名，及表示常数的符号</p>
</li>
<li>
<p>外部符号名说明伪指令<strong>EXTRN</strong><br>
格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTRN符号名1:类型[, 符号名2:类型, …]</span><br></pre></td></tr></table></figure>
<p>功能：说明符号名为外部符号。<br>
本模块引用其他模块中的符号，应说明为外部符号。<br>
类型是：Byte, Word, DWord, FWord, QWord, TByte, Near, Far, ABS，应与原模块定义的类型一致。</p>
</li>
</ol>
<ul>
<li>
<p>由于符号地址都是在某段中定义，</p>
<p>所以，必须将各模块中的段指定为PUBLIC属性，</p>
<p>这样，连接程序将不同模块中的同名段放在一起，从而为各全局符号分配正确的偏移地址。</p>
</li>
<li>
<p>示例</p>
<ul>
<li>
<p>模块M1.ASM实现的是输入字符串子程序Sub1；</p>
</li>
<li>
<p>模块M2.ASM实现的是输出字符串子程序Sub2；</p>
</li>
<li>
<p>主模块M0.ASM调用Sub1和Sub2，输入字符串后再将它显示出来。</p>
</li>
</ul>
<p><code>M0.ASM</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;	M0.ASM  主模块源程序</span><br><span class="line">PUBLIC	Buf, DOSFUN</span><br><span class="line">EXTRN	Sub1: Near, Sub2: Far</span><br><span class="line">DOSFUN = 21h</span><br><span class="line">_DATA	SEGMENT &#x27;DATA&#x27; USE16 PUBLIC</span><br><span class="line">CRLF	DB	13, 10, &#x27;$&#x27;</span><br><span class="line">Buf	DB	20, 20 DUP (32), 13, 10, &#x27;$&#x27;</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT &#x27;CODE&#x27; USE16 PUBLIC</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	…</span><br><span class="line">	CALL	Sub1</span><br><span class="line">	MOV	AX, Offset CRLF</span><br><span class="line">	PUSH	AX</span><br><span class="line">	CALL	Sub2</span><br><span class="line">	POP	AX</span><br><span class="line">	MOV	AX, Offset Buf+2</span><br><span class="line">	PUSH	AX</span><br><span class="line">	CALL	Sub2</span><br><span class="line">	POP	AX</span><br><span class="line">	MOV	AX, 4C00h</span><br><span class="line">	INT	DOSFUN</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
<p><code>M1.ASM</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;	M1.ASM  输入字符子程序源程序</span><br><span class="line">EXTRN	  DOSFUN: Abs </span><br><span class="line">EXTRN	  Buf: Byte</span><br><span class="line">PUBLIC	  Sub1</span><br><span class="line">_TEXT	SEGMENT &#x27;CODE&#x27; USE16 PUBLIC</span><br><span class="line">	ASSUME CS: _TEXT</span><br><span class="line">;子程序Sub1约定输入缓冲区为Buf</span><br><span class="line">Sub1	PROC	NEAR</span><br><span class="line">	LEA	DX, Buf</span><br><span class="line">	MOV	AH, 0Ah</span><br><span class="line">	INT	DOSFUN</span><br><span class="line">	SUB	BX, BX</span><br><span class="line">	MOV	BL, Buf [1]</span><br><span class="line">	MOV	Buf[BX+2],20h</span><br><span class="line">	RET</span><br><span class="line">Sub1	ENDP</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END	;模块至此结束</span><br></pre></td></tr></table></figure>
<p><code>M2.ASM</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;	M2.ASM  显示字符子程序源程序。</span><br><span class="line">PUBLIC	Sub2</span><br><span class="line">EXTRN	DOSFUN: Abs</span><br><span class="line">_TEXT	SEGMENT &#x27;CODE&#x27; USE16 PUBLIC</span><br><span class="line">	ASSUME CS: _TEXT</span><br><span class="line">;子程序Sub2,约定栈传递参数</span><br><span class="line">Sub2	PROC	FAR</span><br><span class="line">	PUSH	BP</span><br><span class="line">	MOV	BP, SP</span><br><span class="line">	MOV	DX, [BP+6]</span><br><span class="line">	MOV	AH, 9</span><br><span class="line">	INT	DOSFUN</span><br><span class="line">	POP	BP</span><br><span class="line">	RET</span><br><span class="line">Sub2	ENDP</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END	;模块至此结束</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="连接方法">连接方法</h4>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905185801120.png" alt="image-20230905185801120" style="zoom:50%;" /> 
<h3 id="6-9-子程序库">6.9 子程序库</h3>
<ul>
<li>常用子程序写成独立的源文件，单独汇编形成OBJ文件后，放到一个专门的文件中，形成子程序库。
<ul>
<li>文件类型一般为.LIB</li>
<li>在连接时，调入子程序库中的子程序模块，生成最终的可执行文件</li>
<li>LIB.EXE，就专门用于建立和修改子程序库</li>
</ul>
</li>
</ul>
<h3 id="6-10-其他">6.10 其他</h3>
<ul>
<li>
<p>与高级语言程序的连接</p>
<p>各种语言的源程序分别编写，</p>
<p>在各自的开发环境中编译成目标模块.OBJ，</p>
<p>再将各目标模块连接在一起，生成可执行文件。</p>
</li>
<li>
<p>遵守约定规则</p>
<ul>
<li>
<p>汇编模块必须使用高级语言的标识符命名约定。</p>
</li>
<li>
<p>在汇编语言源程序中，如果使用定义在高级语言的符号，必须用EXTRN来说明它，如果让高级语言使用在本模块中定义的符号，则必须用PUBLIC来说明它；同理，在高级语言源程序中，也须用相应的说明语句来说明全局符号与外部符号。</p>
</li>
<li>
<p>调用子程序时的参数传递规则主要有：PASCAL规则(参数自左向右压栈)，C规则(参数自右向左压栈)，以及返回值的传递规则。</p>
</li>
<li>
<p>在子程序返回时的栈恢复：由调用程序恢复，还是由子程序恢复。</p>
</li>
<li>
<p>其他诸如寄存器保护原则、数据类型的对应等。</p>
</li>
</ul>
</li>
<li>
<p>C编译程序的约定</p>
<ul>
<li>
<p>全局符号名(变量名或函数名)前加“_”(下画线)。</p>
</li>
<li>
<p>调用子程序时，使用C规则传递参数；在16位模式下，用AX传递8, 16位返回结果，用DX:AX传递32位返回结果，在32位模式下，用EAX传递8, 16和32返回结果，用EDX:EAX传递64位返回结果。</p>
</li>
<li>
<p>由调用程序来恢复栈指针。</p>
</li>
<li>
<p>一般情况下，不保护AX, BX, CX, DX(16位地址模式)，或EAX, EBX, ECX, EDX(32位地址模式)。</p>
<p>在VC中似乎要保护ebx; C++规则,要保护ecx</p>
</li>
</ul>
</li>
</ul>
<h2 id="第七课-中断、输入-输出">第七课 中断、输入/输出</h2>
<h3 id="7-1-中断">7.1 中断</h3>
<ul>
<li>
<p>中断调用</p>
<ul>
<li>标志寄存器进栈</li>
<li>中断调用指令后地址的段和偏移地址进栈</li>
<li>从中断向量表取中断服务程序入口地址，并转去执行</li>
</ul>
</li>
<li>
<p>中断向量</p>
<p>中断服务子程序的入口地址称为中断向量。</p>
<p>实模式，内存的最低1KB区域专门用来保存256个中断向量，称为中断向量表。</p>
</li>
<li>
<p>实地址模式下的中断向量表</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905190154631.png" alt="image-20230905190154631" style="zoom: 50%;" /> 
<ul>
<li>
<p>INT指令</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT imm8</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<p>产生一次类型号为imm8的中断：</p>
<ul>
<li>
<p>首先FLAGS进栈，再将IF和TF清0；</p>
</li>
<li>
<p>然后该指令之后的地址(返回地址)，按段、偏移的次序进栈；</p>
</li>
<li>
<p>最后转向类型号为imm8的中断向量，即双字单元<code>0000h:[4×imm8]</code>所确定的中断服务子程序入口地址处执行。</p>
</li>
</ul>
<blockquote>
<p>由于一条INT指令相当于产生一次中断，其处理过程与外部中断处理过程一样，所以，INT指令又称为软中断指令。</p>
</blockquote>
</li>
<li>
<p>INTO指令</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INTO</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<p>若OF＝1，产生一次类型号为4的中断，相当于INT 4；否则顺序执行。</p>
</li>
<li>
<p>IRET指令</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRET</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<p>中断处理结束，返回中断发生处继续执行。</p>
<p>即：首先从栈中以“偏移地址、段地址、16位标志”这样的次序弹出转向的目标地址和FLAGS，再转移到该目标地址去执行。</p>
</li>
</ul>
<h3 id="7-2-输入-输出">7.2 输入/输出</h3>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905190625072.png" alt="image-20230905190625072" style="zoom:50%;" /> 
<ul>
<li>
<p>用IN、 OUT指令与外部设备交换信息</p>
<p>端口</p>
</li>
<li>
<p>与I/O设备间数据传送方式：</p>
<ul>
<li>程序直接控制I/O方式</li>
<li>中断传送方式</li>
<li>直接内存存取(DMA)</li>
</ul>
</li>
</ul>
<h3 id="7-3-中断处理程序的主要步骤">7.3 中断处理程序的主要步骤</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) 保存寄存器的内容；</span><br><span class="line">(2) 若允许CPU响应外设中断，则开中断(STI)；</span><br><span class="line">(3) 处理中断；</span><br><span class="line">(4) 关中断(CLI)；</span><br><span class="line">(5) 若是I/O中断服务程序，则送中断结束命令(EOI)给中断命令寄存器；</span><br><span class="line">(6) 恢复寄存器的内容；</span><br><span class="line">(7) 返回被中断的程序(IRET)。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>中断服务程序的入口地址只有放到中断向量表中，才能在中断发生时被调用到。</p>
<p>所以，除了中断处理程序，还有相应设置中断向量及相应的硬件初始化工作。</p>
</li>
</ul>
<h2 id="补录：-span-id-jump-temp-实用示例-span">补录：<span id="jump_temp">实用示例</span></h2>
<h4 id="1-打印可见的十六进制数">1. 打印可见的十六进制数</h4>
<ul>
<li>
<p>题目</p>
<p>16位二进制数存在BX，以可见字符形式输出打印在屏幕上</p>
</li>
<li>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  DISPBX</span><br><span class="line">CODE    SEGMENT</span><br><span class="line">        ASSUME  CS:CODE</span><br><span class="line">DISPBX  PROC    FAR</span><br><span class="line">        MOV     CH,4</span><br><span class="line">        MOV     CL,4</span><br><span class="line">ROTATE: ROL     BX,CL</span><br><span class="line">        MOV     AL,BL</span><br><span class="line">        AND     AL,0FH</span><br><span class="line">        ADD     AL,30H</span><br><span class="line">        CMP     AL,3AH</span><br><span class="line">        JL      PRINTIT</span><br><span class="line">        ADD     AL,7</span><br><span class="line">PRINTIT:MOV     DL,AL</span><br><span class="line">        MOV     AH,2</span><br><span class="line">        INT     21H</span><br><span class="line">        DEC     CH</span><br><span class="line">        JNZ    	ROTATE</span><br><span class="line">        RET</span><br><span class="line">DISPBX  ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">       	END</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-输出对应字符串">2. 输出对应字符串</h4>
<ul>
<li>
<p>题目</p>
<p>编写多分支结构程序，实现：<br>
输入’1’, ‘2’, ‘3’，输出&quot;one&quot;, “two”, “three”；<br>
输入’0’，中止运行；<br>
输入其他，输出&quot;error!&quot;</p>
</li>
<li>
<p>代码</p>
<p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT &#x27;DATA&#x27;</span><br><span class="line">Msg	DB 13,10,&quot;Please input a number: &quot;,13,10,&quot;$&quot;</span><br><span class="line">s1	DB 	9, &quot;one&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s2	DB	9, &quot;two&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s3	DB	9, &quot;three&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">err	DB	9, &quot;error!&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT	&#x27;CODE&#x27;</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	MOV	AX, _DATA</span><br><span class="line">		MOV	DS, AX</span><br><span class="line">Again:	MOV	AH, 9</span><br><span class="line">		MOV	DX, Offset Msg</span><br><span class="line">		INT	21h</span><br><span class="line">		MOV	AH, 1</span><br><span class="line">		INT	21h</span><br><span class="line">		CMP	AL, &#x27;0&#x27;</span><br><span class="line">		JE	Case0</span><br><span class="line">		CMP	AL, &#x27;1&#x27;</span><br><span class="line">		JE	Case1</span><br><span class="line">		CMP	AL, &#x27;2&#x27;</span><br><span class="line">		JE	Case2</span><br><span class="line">		CMP	AL, &#x27;3&#x27;</span><br><span class="line">		JE	Case3</span><br><span class="line">Default:	MOV	DX, Offset err</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case0:		MOV	AX, 4C00h</span><br><span class="line">		INT	21h</span><br><span class="line">Case1:		MOV	DX, Offset s1</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case2:		MOV	DX, Offset s2</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case3:		MOV	DX, Offset s3</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">EndSwitch:	MOV	AH, 9</span><br><span class="line">		INT	21h</span><br><span class="line">		JMP	Again</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT &#x27;DATA&#x27;</span><br><span class="line">Msg	DB 13, 10, &quot;Please input a number: &quot;, 13, 10, &quot;$&quot;</span><br><span class="line">s1	DB		9, &quot;four&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s2	DB		9, &quot;five&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s3	DB		9, &quot;six&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">err	DB		9, &quot;error!&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT	&#x27;CODE&#x27;</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	MOV		AX, _DATA</span><br><span class="line">	MOV		DS, AX</span><br><span class="line">Again:	MOV		AH, 9</span><br><span class="line">	MOV		DX, Offset Msg</span><br><span class="line">	INT		21h</span><br><span class="line">	MOV		AH, 1</span><br><span class="line">	INT		21h</span><br><span class="line">		SUB	AL, &#x27;4&#x27;</span><br><span class="line">		JL	Error		;输入字符小于&#x27;4&#x27;的情况</span><br><span class="line">		CMP	AL, 3</span><br><span class="line">		JLE	Loc1</span><br><span class="line">Error:		MOV	AL, 4</span><br><span class="line">Loc1:		MOV	AH, 0</span><br><span class="line">		ADD	AX, AX</span><br><span class="line">		MOV	BX, AX</span><br><span class="line">		JMP	Word Ptr CS: CaseTab [BX]</span><br><span class="line">CaseTab		DW	Case1, Case2, Case3, Case4, Default</span><br><span class="line">Default:	MOV	DX, Offset err</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case1:		MOV	DX, Offset s1</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case2:		MOV	DX, Offset s2</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case3:		MOV	DX, Offset s3</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case4:		MOV	AX, 4C00h</span><br><span class="line">		INT	21h</span><br><span class="line">EndSwitch:	MOV	AH, 9</span><br><span class="line">		INT	21h</span><br><span class="line">		JMP	Again</span><br><span class="line">_TEXT		ENDS</span><br><span class="line">		END Start</span><br></pre></td></tr></table></figure>
<p>方法三：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT &#x27;DATA&#x27;</span><br><span class="line">Msg	DB 13,10,&quot;Please input a character: &quot;,13,10,&quot;$&quot;</span><br><span class="line">s1	DB	9, &quot;File&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s2	DB	9, &quot;Edit&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">s3	DB	9, &quot;View&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">err	DB	9, &quot;Error!&quot;, 13, 10, &#x27;$&#x27;</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT	&#x27;CODE&#x27;</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	MOV	AX, _DATA</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">Again:	MOV	AH, 9</span><br><span class="line">	MOV	DX, Offset Msg</span><br><span class="line">	INT	21h</span><br><span class="line">	MOV	AH, 1</span><br><span class="line">	INT	21h</span><br><span class="line">		MOV	CX, CS: TabItems</span><br><span class="line">		MOV	BX, Offset CaseTab</span><br><span class="line">Next_I:		CMP	Byte Ptr CS: [BX], AL</span><br><span class="line">		JE	ToCase</span><br><span class="line">		ADD	BX, 4</span><br><span class="line">		LOOP	Next_I</span><br><span class="line">ToCase:		JMP	Word Ptr CS: [BX+2]</span><br><span class="line">TabItems DW	8</span><br><span class="line">CaseTab	  DW	&#x27;F&#x27;,Case1,&#x27;E&#x27;,Case2,&#x27;V&#x27;,Case3,&#x27;X&#x27;,Case4</span><br><span class="line">	  DW	&#x27;f&#x27;,Case1,&#x27;e&#x27;,Case2,&#x27;v&#x27;,Case3,&#x27;x&#x27;,Case4,0,Default</span><br><span class="line">Default:	MOV	DX, Offset err</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case1:		MOV	DX, Offset s1</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case2:		MOV	DX, Offset s2</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case3:		MOV	DX, Offset s3</span><br><span class="line">		JMP	EndSwitch</span><br><span class="line">Case4:		MOV	AX, 4C00h</span><br><span class="line">		INT	21h</span><br><span class="line">EndSwitch:	MOV	AH, 9</span><br><span class="line">		INT	21h</span><br><span class="line">		JMP	Again</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-求所有n2数字和">3. 求所有n2数字和</h4>
<ul>
<li>
<p>题目</p>
<p>用while循环结构编写程序，<br>
计算s＝12+22+32+…+n2+…，直到n＞65000或s≥7FF0000h为止，<br>
运算结果存于32位变量Sum中</p>
<img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/image-20230905182834174.png" alt="image-20230905182834174" style="zoom: 50%;" /> 
</li>
<li>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT	&#x27;DATA&#x27;	</span><br><span class="line">Sum	DD	?</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT	&#x27;CODE&#x27;</span><br><span class="line">	ASSUME	CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	MOV	AX, _DATA</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">	MOV	CX, 1</span><br><span class="line">	MOV	Word Ptr Sum, 0</span><br><span class="line">	MOV	Word Ptr Sum+2, 0</span><br><span class="line">	JMP	Rep1?	; 先执行条件测试</span><br><span class="line">Rep1b:	MOV	AX, CX</span><br><span class="line">	MUL	CX	</span><br><span class="line">	ADD	Word Ptr Sum, AX</span><br><span class="line">	ADC	Word Ptr Sum+2, DX</span><br><span class="line">	INC	CX	</span><br><span class="line">Rep1?:	CMP	CX, 65000</span><br><span class="line">	JNBE	EndRep1</span><br><span class="line">	CMP	Word Ptr Sum+2, 7FFh</span><br><span class="line">	JB	Rep1b</span><br><span class="line">EndRep1:</span><br><span class="line">	MOV	AX, 4C00h</span><br><span class="line">	INT	21h	</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-计算字符数">4. 计算字符数</h4>
<ul>
<li>
<p>题目</p>
<p>编一汇编语言程序，从键盘输入一系列字符（小于80个，以回车符结束），</p>
<p>按<strong>字母</strong>、<strong>数字</strong>以及<strong>其他</strong>字符分类统计，并显示（可以按十六进制数显示）出这三类的计数结果。</p>
</li>
<li>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT</span><br><span class="line">N1	DB	0	; 数字</span><br><span class="line">N2	DB	0	; 字符</span><br><span class="line">N3	DB	0	; 其他</span><br><span class="line">BUF 	DB  	80	;预定义80字节的空间</span><br><span class="line">	DB	?	;待输入完成后，自动获得输入的字符个数</span><br><span class="line">	DB  	80  DUP(?) </span><br><span class="line">Msg1	DB	13,10,&quot;Please input a string:&quot;,&quot;$&quot;</span><br><span class="line">Msg2	DB	13,10,&quot;Number:&quot;,&quot;$&quot;</span><br><span class="line">Msg3	DB	13,10,&quot;Char:&quot;,&quot;$&quot;</span><br><span class="line">Msg4	DB	13,10,&quot;Other:&quot;,&quot;$&quot;</span><br><span class="line">_DATA	ENDS</span><br><span class="line">_TEXT	SEGMENT</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line">Start:	</span><br><span class="line">	MOV	AX, _DATA</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">	</span><br><span class="line">	; 输出提示信息</span><br><span class="line">	MOV	AH, 09H</span><br><span class="line">	MOV	DX, OFFSET Msg1</span><br><span class="line">	INT	21H</span><br><span class="line">	;读入字符串</span><br><span class="line">	MOV	AH, 0AH</span><br><span class="line">	MOV	DX, OFFSET BUF</span><br><span class="line">	INT	21H</span><br><span class="line"></span><br><span class="line">	; 核心部分，统计个数</span><br><span class="line">	MOV	CL, BUF[1]</span><br><span class="line">	MOV	CH, 00H</span><br><span class="line">	MOV	SI, 0</span><br><span class="line">	; 进行判断</span><br><span class="line">NEXT:</span><br><span class="line">	CMP	BUF[2][SI], &#x27;0&#x27;</span><br><span class="line">	JL	LOC1</span><br><span class="line">	CMP	BUF[2][SI], &#x27;9&#x27;</span><br><span class="line">	JG	LOC1</span><br><span class="line">	INC	N1</span><br><span class="line">	JMP	OVER</span><br><span class="line">LOC1:</span><br><span class="line">	CMP	BUF[2][SI], &#x27;A&#x27;</span><br><span class="line">	JL	LOC2</span><br><span class="line">	CMP	BUF[2][SI],&#x27;Z&#x27;</span><br><span class="line">	JG	LOC2</span><br><span class="line">	INC	N2</span><br><span class="line">	JMP	OVER</span><br><span class="line">LOC2:</span><br><span class="line">	CMP	BUF[2][SI], &#x27;a&#x27;</span><br><span class="line">	JL	LOC3</span><br><span class="line">	CMP	BUF[2][SI], &#x27;z&#x27;</span><br><span class="line">	JG	LOC3</span><br><span class="line">	INC	N2</span><br><span class="line">	JMP	OVER</span><br><span class="line">LOC3:</span><br><span class="line">	INC	N3</span><br><span class="line">OVER:</span><br><span class="line">	INC	SI</span><br><span class="line">	CMP	SI, CX</span><br><span class="line">	JLE	NEXT</span><br><span class="line"></span><br><span class="line">	; 显示结果提示信息</span><br><span class="line">	MOV	AH, 09H</span><br><span class="line">	MOV	DX, OFFSET Msg2</span><br><span class="line">	INT	21H</span><br><span class="line">	; 输出 数字 个数</span><br><span class="line">	MOV	AH, 02H</span><br><span class="line">	MOV	BL, N1</span><br><span class="line">	ADD	BL,30H</span><br><span class="line">	MOV	DL, BL</span><br><span class="line">	INT	21H</span><br><span class="line">	; 显示结果提示信息</span><br><span class="line">	MOV	AH, 09H</span><br><span class="line">	MOV	DX, OFFSET Msg3</span><br><span class="line">	INT	21H</span><br><span class="line">	; 输出 字母 个数</span><br><span class="line">	MOV	AH, 02H</span><br><span class="line">	MOV	BL, N2</span><br><span class="line">	ADD	BL,30H</span><br><span class="line">	MOV	DL, BL</span><br><span class="line">	INT	21H</span><br><span class="line">	; 显示结果提示信息</span><br><span class="line">	MOV	AH, 09H</span><br><span class="line">	MOV	DX, OFFSET Msg4</span><br><span class="line">	INT	21H</span><br><span class="line">	; 输出 其他 格式</span><br><span class="line">	MOV	AH, 02H</span><br><span class="line">	MOV	BL, N3</span><br><span class="line">	ADD	BL,30H</span><br><span class="line">	MOV	DL, BL</span><br><span class="line">	INT	21H</span><br><span class="line">	</span><br><span class="line">	MOV	AX,4C00H	; 退出</span><br><span class="line">	INT	21H </span><br><span class="line"></span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END Start</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-找出最大偶数">5. 找出最大偶数</h4>
<ul>
<li>
<p>题目</p>
<p>编一汇编语言程序，找出首地址为DATA的N个<strong>字</strong>数组中的<strong>最大偶数</strong>，并将该最大偶数按十六进制显示出来。</p>
<p>（前面给出的<code>DISPBX.ASM</code>作为本题目的子模块，连接使用即可。）</p>
</li>
<li>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_DATA	SEGMENT  PUBLIC</span><br><span class="line">DATA  	DW      	1234H,5678H,9D4CH,0D7H,0,-1,7D2AH,8A0EH,10F5H,645DH</span><br><span class="line">N   	EQU     	($-DATA)/2</span><br><span class="line">MAX	DW	?</span><br><span class="line">_DATA	ENDS</span><br><span class="line"></span><br><span class="line">EXTRN	DISPBX:FAR</span><br><span class="line"></span><br><span class="line">_TEXT	SEGMENT  PUBLIC</span><br><span class="line">	ASSUME CS: _TEXT, DS: _DATA</span><br><span class="line"></span><br><span class="line">; 主程序，求出最大偶数，存放在BX</span><br><span class="line">_MAIN	PROC	FAR</span><br><span class="line">	PUSH	DS</span><br><span class="line">	MOV	AX,0</span><br><span class="line">	PUSH	AX</span><br><span class="line">	MOV	AX, _DATA</span><br><span class="line">	MOV	DS, AX</span><br><span class="line">	; 主程序内容</span><br><span class="line">	; 初始化</span><br><span class="line">	MOV	CX, N-1</span><br><span class="line">	MOV	BX, OFFSET DATA -2 </span><br><span class="line">INIT:</span><br><span class="line">	INC	BX</span><br><span class="line">	INC	BX</span><br><span class="line">	TEST	WORD PTR [BX], 0001H	; 只取最低1位判断是否为偶数</span><br><span class="line">	JNZ	INIT			; 不是偶数，则直接进行下一个判断</span><br><span class="line">	MOV	AX, [BX]</span><br><span class="line">	MOV	BX, OFFSET DATA</span><br><span class="line">	; 比较大小</span><br><span class="line">AGAIN:</span><br><span class="line">	INC	BX			; 注意这里要BX+2，自增两次</span><br><span class="line">	INC	BX</span><br><span class="line">	TEST	WORD PTR [BX], 0001H	; 只取最低1位判断是否为偶数</span><br><span class="line">	JNZ	NEXT			; 不是偶数，则直接进行下一个判断</span><br><span class="line">	CMP	AX, [BX]			</span><br><span class="line">	JGE	NEXT</span><br><span class="line">	MOV	AX,[BX]</span><br><span class="line">NEXT:</span><br><span class="line">	LOOP	AGAIN</span><br><span class="line">	MOV	MAX, AX		; 结束循环，得到最大偶数，准备输出</span><br><span class="line">	; 调用子程序</span><br><span class="line">	MOV	BX, MAX</span><br><span class="line">	CALL	DISPBX</span><br><span class="line">	; 退出</span><br><span class="line">	RETF</span><br><span class="line">_MAIN	ENDP</span><br><span class="line">_TEXT	ENDS</span><br><span class="line">	END _MAIN</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://isSeymour.github.io/butterflyblog">isSeymour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://isseymour.github.io/butterflyblog/2023/09/05/Assembly/">https://isseymour.github.io/butterflyblog/2023/09/05/Assembly/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://isSeymour.github.io/butterflyblog" target="_blank">isSeymour</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/butterflyblog/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80Assembly/">汇编语言Assembly</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/assembly_01.avif" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/butterflyblog/2023/08/27/PHP-Notes/" title="《PHP》精简Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《PHP》精简Notes</div></div></a></div><div class="next-post pull-right"><a href="/butterflyblog/2023/09/19/sqlmapUsage/" title="《sqlmap中文用法指南》"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《sqlmap中文用法指南》</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">isSeymour</div><div class="author-info__description">志之所趋，无远弗届，穷山距海，不能限也。</div></div><div class="card-info-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/isSeymour/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://isSeymour.github.io/profile/" target="_blank" title="学术主页"><i class="fa-regular fa-address-card" style="color: #000000;"></i></a><a class="social-icon" href="https://github.com/isSeymour/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/79699613/" target="_blank" title="B站"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_63205991/" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #000000;"></i></a><a class="social-icon" href="mailto:isSeymour@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">评论区暂时不可用！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">《汇编语言》Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E9%87%8D%E7%82%B9%E8%B7%B3%E8%BD%AC"><span class="toc-text">前言：重点跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-MOV%E6%8C%87%E4%BB%A4%E3%80%81PUSH%E6%8C%87%E4%BB%A4%E3%80%81POP%E6%8C%87%E4%BB%A4%E3%80%81LEA%E6%8C%87%E4%BB%A4%E7%AD%89"><span class="toc-text">3.3 MOV指令、PUSH指令、POP指令、LEA指令等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-13-DOS%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-text">3.13 DOS系统功能调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E5%B8%B8%E6%95%B0%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E5%8F%B7"><span class="toc-text">4.2 常数、变量和标号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-9-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">4.9 算术运算指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-10-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">4.10 逻辑运算指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-text">5.1 转移指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4"><span class="toc-text">5.2 循环指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">一、模板</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AF%BE-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">第一课 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BF%A1%E6%81%AF%E5%8D%95%E4%BD%8D%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1 信息单位与数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.2 进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89X%E8%BF%9B%E5%88%B6-%E8%BD%AC-%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-text">（1）X进制 转 十进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8D%81%E8%BF%9B%E5%88%B6-%E8%BD%AC%E6%8D%A2-X%E8%BF%9B%E5%88%B6"><span class="toc-text">（2）十进制 转换 X进制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BC%96%E7%A0%81"><span class="toc-text">1.3 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%BA%A2%E5%87%BA"><span class="toc-text">1.4 溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA"><span class="toc-text">1.5 字符表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-text">1.6 基本逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-BCD%E7%A0%81"><span class="toc-text">1.7 BCD码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AF%BE-x86%E5%BE%AE%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">第二课 x86微机系统的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-x86%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84"><span class="toc-text">2.1 x86寄存器组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-text">2.2 通用寄存器（数据寄存器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">2.3 指针寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">2.4 变址寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">2.5 控制寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">2.6 段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">2.7 内存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E6%AE%B5"><span class="toc-text">2.8 内存与分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E6%A0%88%E5%8F%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">2.9 栈及操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AF%BE-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%8C%87%E4%BB%A4"><span class="toc-text">第三课 寻址方式及指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 指令系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">3.2 操作数寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-span-id-jump-move-MOV%E6%8C%87%E4%BB%A4-span"><span class="toc-text">3.3 MOV指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-XCHG%E6%8C%87%E4%BB%A4"><span class="toc-text">3.4 XCHG指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-PUSH%E6%8C%87%E4%BB%A4"><span class="toc-text">3.5 PUSH指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-POP%E6%8C%87%E4%BB%A4"><span class="toc-text">3.6 POP指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-XLAT%E6%8C%87%E4%BB%A4"><span class="toc-text">3.7 XLAT指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4LEA"><span class="toc-text">3.8 地址传送指令LEA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A42"><span class="toc-text">3.9 地址传送指令2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E6%A0%87%E5%BF%97%E4%BD%8D%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">3.10 标志位传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4"><span class="toc-text">3.11 扩展指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4"><span class="toc-text">3.12 输入输出指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-span-id-jump-dos-DOS%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8-span"><span class="toc-text">3.13 DOS系统功能调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-%E6%B1%87%E7%BC%96%E4%BD%BF%E7%94%A8"><span class="toc-text">3.14 汇编使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AF%BE-%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E3%80%81%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">第四课 源程序结构、运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">4.1 源程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-span-id-jump-var-%E5%B8%B8%E6%95%B0%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E5%8F%B7-span"><span class="toc-text">4.2 常数、变量和标号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B8%B8%E6%95%B0"><span class="toc-text">（1）常数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%98%E9%87%8F"><span class="toc-text">（2）变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%87%E5%8F%B7"><span class="toc-text">（3）标号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%8F%98%E9%87%8F%E5%90%8D%E5%92%8C%E6%A0%87%E5%8F%B7%E7%9A%84%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">（4）变量名和标号的其他定义方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.3 表达式和运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-MASM%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">4.4 MASM的基本伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E9%80%89%E6%8B%A9%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">指令集选择伪指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">完整的段定义伪指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%9C%B0%E5%9D%80%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%8E%E5%AF%B9%E5%87%86%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">4.5 地址计数器与对准伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%B9%89PROC%E5%92%8CENDP"><span class="toc-text">4.6 子程序定义PROC和ENDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%85%B6%E4%BB%96%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">4.7 其他伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-MASM%E7%9A%84%E5%AE%8F%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">4.8 MASM的宏汇编伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-span-id-jump-count-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4-span"><span class="toc-text">4.9 算术运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A0%E6%B3%95"><span class="toc-text">（1）加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%87%8F%E6%B3%95"><span class="toc-text">（2）减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%B1%82%E8%A1%A5"><span class="toc-text">（3）求补</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%AF%94%E8%BE%83"><span class="toc-text">（4）比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%B9%98%E6%B3%95"><span class="toc-text">（5）乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E9%99%A4%E6%B3%95"><span class="toc-text">（6）除法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-span-id-jump-logic-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4-span"><span class="toc-text">4.10 逻辑运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">（1）逻辑运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E4%B8%AA%E6%8C%87%E4%BB%A4"><span class="toc-text">五个指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%80%BB%E8%BE%91"><span class="toc-text">常用逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-text">（2）移位运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-text">逻辑移位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-text">算术移位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D1"><span class="toc-text">循环移位1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D2"><span class="toc-text">循环移位2</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AF%BE-%E8%BD%AC%E7%A7%BB%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E5%BE%AA%E7%8E%AF"><span class="toc-text">第五课 转移、选择、循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-span-id-jump-jmp-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4-span"><span class="toc-text">5.1 转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-text">（1）无条件转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-text">（2）条件转移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">单个标志位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-text">无符号数比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%AF%94%E8%BE%83"><span class="toc-text">有符号数比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-span-id-jump-loop-%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4-span"><span class="toc-text">5.2 循环指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-text">5.3 其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A0%87%E5%BF%97%E4%BD%8D%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">（1）标志位处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-text">（2）其他指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AF%BE-%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8"><span class="toc-text">第六课 子程序调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">6.1 子程序定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-CALL%E6%8C%87%E4%BB%A4"><span class="toc-text">6.2 CALL指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-RET%E6%8C%87%E4%BB%A4"><span class="toc-text">6.3 RET指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-text">6.4 寄存器的保护与恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">6.5 参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">6.6 静态变量与动态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B5%8C%E5%A5%97%E4%B8%8E%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-text">6.7 子程序的嵌套与递归调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.8 多模块程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7"><span class="toc-text">全局符号与外部符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-text">连接方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="toc-text">6.9 子程序库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E5%85%B6%E4%BB%96"><span class="toc-text">6.10 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%AF%BE-%E4%B8%AD%E6%96%AD%E3%80%81%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-text">第七课 中断、输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%AD%E6%96%AD"><span class="toc-text">7.1 中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-text">7.2 输入&#x2F;输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-text">7.3 中断处理程序的主要步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%BD%95%EF%BC%9A-span-id-jump-temp-%E5%AE%9E%E7%94%A8%E7%A4%BA%E4%BE%8B-span"><span class="toc-text">补录：实用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%93%E5%8D%B0%E5%8F%AF%E8%A7%81%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-text">1. 打印可见的十六进制数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA%E5%AF%B9%E5%BA%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2. 输出对应字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B1%82%E6%89%80%E6%9C%89n2%E6%95%B0%E5%AD%97%E5%92%8C"><span class="toc-text">3. 求所有n2数字和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E6%95%B0"><span class="toc-text">4. 计算字符数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E5%81%B6%E6%95%B0"><span class="toc-text">5. 找出最大偶数</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/05/28/CVDL-4-NETs/" title="CVDL - 经典网络解析"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/CVDL-bupt/C4-Page0.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="CVDL - 经典网络解析"/></a><div class="content"><a class="title" href="/butterflyblog/2024/05/28/CVDL-4-NETs/" title="CVDL - 经典网络解析">CVDL - 经典网络解析</a><time datetime="2024-05-27T16:00:00.000Z" title="发表于 2024-05-28 00:00:00">2024-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/05/26/CVDL-3-CN/" title="CVDL - 卷积神经网络"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/CVDL-bupt/C3-Page0.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="CVDL - 卷积神经网络"/></a><div class="content"><a class="title" href="/butterflyblog/2024/05/26/CVDL-3-CN/" title="CVDL - 卷积神经网络">CVDL - 卷积神经网络</a><time datetime="2024-05-25T16:00:00.000Z" title="发表于 2024-05-26 00:00:00">2024-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/05/25/CVDL-2-FC/" title="CVDL - 全连接神经网络"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/CVDL-bupt/C2-Page0.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="CVDL - 全连接神经网络"/></a><div class="content"><a class="title" href="/butterflyblog/2024/05/25/CVDL-2-FC/" title="CVDL - 全连接神经网络">CVDL - 全连接神经网络</a><time datetime="2024-05-24T16:00:00.000Z" title="发表于 2024-05-25 00:00:00">2024-05-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/assembly/assembly_01.avif')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By isSeymour</div><div class="footer_custom_text">欢迎乘坐我的生活地铁！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/butterflyblog/js/utils.js"></script><script src="/butterflyblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://isseymour.zeabur.app/',
      region: 'Hong Kong (East) – hkg1',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://isseymour.zeabur.app/',
      region: 'Hong Kong (East) – hkg1',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/butterflyblog/js/search/local-search.js"></script></div></div></body></html>