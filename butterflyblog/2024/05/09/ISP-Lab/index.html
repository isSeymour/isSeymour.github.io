<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《信息安全工程》实验内容 | isSeymour</title><meta name="author" content="isSeymour"><meta name="copyright" content="isSeymour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《信息安全工程》实验内容  来源：《信息安全工程》钟计东老师 课件 2024-05-09 ~ 06-07@Seymour   前置内容  前置内容有录制视频 虚拟机-前置内容  安装XP   原PPT全文都挺干货的，请直接看PPT：02-IS-VM.pdf | 下载 - 文本类   下面摘要一些可能的知识点（不是必做实验）   网段  VMWare 支持多个网段 每个网段相当于一个广播型的以太网络">
<meta property="og:type" content="article">
<meta property="og:title" content="《信息安全工程》实验内容">
<meta property="og:url" content="https://isseymour.github.io/butterflyblog/2024/05/09/ISP-Lab/index.html">
<meta property="og:site_name" content="isSeymour">
<meta property="og:description" content="《信息安全工程》实验内容  来源：《信息安全工程》钟计东老师 课件 2024-05-09 ~ 06-07@Seymour   前置内容  前置内容有录制视频 虚拟机-前置内容  安装XP   原PPT全文都挺干货的，请直接看PPT：02-IS-VM.pdf | 下载 - 文本类   下面摘要一些可能的知识点（不是必做实验）   网段  VMWare 支持多个网段 每个网段相当于一个广播型的以太网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/Page0.png">
<meta property="article:published_time" content="2024-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-06-06T16:00:00.000Z">
<meta property="article:author" content="isSeymour">
<meta property="article:tag" content="计网实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/Page0.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/IC1011.ico"><link rel="canonical" href="https://isseymour.github.io/butterflyblog/2024/05/09/ISP-Lab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/butterflyblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/butterflyblog/',
  algolia: undefined,
  localSearch: {"path":"/butterflyblog/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《信息安全工程》实验内容',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-07 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/butterflyblog/code/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/diary/"><i class="fa-fw fa-solid fa-hashtag"></i><span> 心路</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/major/"><i class="fa-fw fa-solid fa-map"></i><span> 专业课</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/mathAI/"><i class="fa-fw fa-solid fa-bar-chart"></i><span> 数学&amp;AI</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/Page0.png')"><nav id="nav"><span id="blog-info"><a href="/butterflyblog/" title="isSeymour"><span class="site-name">isSeymour</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/diary/"><i class="fa-fw fa-solid fa-hashtag"></i><span> 心路</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/major/"><i class="fa-fw fa-solid fa-map"></i><span> 专业课</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/mathAI/"><i class="fa-fw fa-solid fa-bar-chart"></i><span> 数学&amp;AI</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《信息安全工程》实验内容</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-08T16:00:00.000Z" title="发表于 2024-05-09 00:00:00">2024-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-06T16:00:00.000Z" title="更新于 2024-06-07 00:00:00">2024-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/butterflyblog/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《信息安全工程》实验内容"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>《信息安全工程》实验内容</h1>
<blockquote>
<p>来源：《信息安全工程》钟计东老师 课件</p>
<p>2024-05-09 ~ 06-07@Seymour</p>
</blockquote>
<hr>
<h2 id="前置内容">前置内容</h2>
<blockquote>
<p>前置内容有录制视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fw4m1v7WW/">虚拟机-前置内容</a></p>
</blockquote>
<h3 id="安装XP">安装XP</h3>
<ul>
<li>
<p>原PPT全文都挺干货的，请直接看<a href="https://isseymour.github.io/butterflyblog/tools/">PPT：02-IS-VM.pdf | 下载 - 文本类</a></p>
</li>
<li>
<p>下面摘要一些可能的知识点（不是必做实验）</p>
</li>
</ul>
<h3 id="网段">网段</h3>
<ul>
<li>VMWare 支持多个网段</li>
<li>每个网段相当于一个广播型的以太网络(Ethernet)</li>
</ul>
<h3 id="网段连接模式">网段连接模式</h3>
<ul>
<li>
<p>VM网段设置有几种模式</p>
<ol>
<li>桥接模式</li>
<li>NAT模式</li>
<li>仅主机模式 host-only</li>
<li>LAN模式</li>
</ol>
</li>
<li>
<p>区别主要在于和外部网络的连接方式，</p>
<p>桥接模式和NAT模式可以访问外部网络，而后两种不能。</p>
</li>
<li>
<p>LAN访问不提供DHCP服务，提供更多网段</p>
</li>
</ul>
<blockquote>
<ol>
<li><strong>网段设置：在 VMware 的封面上方工具栏 | 编辑 | 虚拟网络编辑器</strong></li>
<li><strong>虚拟机网络设置：右键虚拟机 | 设置 | 网络适配器 | 自定义 | 选择网段</strong></li>
</ol>
<p>注：更换网络连接方式时，可以打开本地连接设置查看连接状态，发现“无效IP地址“可以点击<strong>修复</strong>，会清除缓存。</p>
</blockquote>
<h4 id="桥接模式">桥接模式</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-4.png" alt="P2-4" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>将主机和虚拟机放在主机所在的物理网络，虚拟机需要独立的IP地址。</strong></p>
</li>
<li>
<p>桥接模式下</p>
<blockquote>
<p>各个虚拟机都选择<strong>VMnet0</strong></p>
</blockquote>
<ul>
<li>
<p><strong>各个虚拟机</strong>都可以互相 ping 通</p>
</li>
<li>
<p>也都能和<strong>物理机</strong>互相 ping 通</p>
</li>
<li>
<p>虚拟机都能正常<strong>接通外部网络</strong>（可以使用浏览器上网）</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-4-1.png" alt="P2-4-1" style="zoom: 33%;" /> 
<h4 id="NAT模式">NAT模式</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-5-1.png" alt="P2-5-1" style="zoom:60%;" />  
<ul>
<li>
<p><strong>虚拟主机通过内部地址映射成主机所具有的外部网络地址</strong>。</p>
</li>
<li>
<p>NAT模式下</p>
<blockquote>
<ol>
<li>
<p>网段设置</p>
<p>设置<strong>VMnet2</strong> (WMFusion中进行偏好设置）</p>
<p>网关 IP：192.168.142.2</p>
<p>子网 IP:192.168.142.0/255.255.255.0</p>
<p>去掉DHCP</p>
<p>去掉将主机适配器添加到此网络，表示主机不连接在142网段</p>
</li>
<li>
<p>各虚拟机设置</p>
<p>网络适配器：选择<strong>vmnet2</strong></p>
<p>修改网络连接的属性，设置相应的IP地址，网关地址和DNS地址</p>
<ul>
<li>
<p>一台虚拟机：</p>
<p><strong>IP:192.168.142.11, gateway:192.168.142.2, DNS:192.168.142.2</strong></p>
</li>
<li>
<p>另一台虚拟机：</p>
<p><strong>IP:192.168.142.111, gateway:192.168.142.2, DNS:192.168.142.2</strong></p>
</li>
</ul>
</li>
</ol>
<p>下面我的实验采用 <strong>VMnet8</strong></p>
</blockquote>
<ul>
<li>各个<strong>虚拟机可以互通 ping</strong></li>
<li>虚拟机<strong>可以ping 通 物理主机（网关）</strong></li>
<li><strong>物理主机不能 ping 虚拟机</strong></li>
<li>虚拟机可以<strong>连接到外部网络</strong>（可以浏览器上网）</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-5-2.png" alt="P2-5-2" style="zoom:33%;" /> 
<h4 id="仅主机模式-Host-only">仅主机模式 Host-only</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-6.png" alt="P2-6" style="zoom:60%;" /> 
<ul>
<li><strong>虚拟机无法接通外部网络</strong>。（与物理主机不接通）</li>
</ul>
<h4 id="LAN模式（局域网）">LAN模式（局域网）</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-7.png" alt="P2-7" style="zoom:60%;" /> 
<ul>
<li><strong>虚拟机无法接通外部网络</strong>。（与物理主机不接通）</li>
<li>而且<strong>没有DHCP服务</strong>（DHCP：动态主机地址分配服务）</li>
</ul>
<h2 id="我的配置备注">我的配置备注</h2>
<ul>
<li><strong>WinXP</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Win XP Ghost 正在使用：</span><br><span class="line">文件：XP_Ghost.iso</span><br><span class="line"></span><br><span class="line">WinXP（取消）：</span><br><span class="line">镜像文件：zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_x14-80404.iso</span><br><span class="line">产品密钥：G3B6Q-PDJCP-D638W-T9X6F-93VX3</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>服务器 server1</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IP: 192.168.142.200</span><br><span class="line">HTTP服务 http://192.168.142.200/index.htm</span><br><span class="line">FTP服务  ftp://192.168.142.200/</span><br><span class="line">镜像文件：cn_win_srv_2003_r2_standard_with_sp2_cd1_X13-13927.iso</span><br><span class="line">版本：server 2003 Standard </span><br><span class="line">姓名：Seymour</span><br><span class="line">单位：TJ</span><br><span class="line">产品密钥：KKM7F-PB4GC-7DMH2-KKYXB-RG34M</span><br><span class="line">计算机名称：Server1</span><br><span class="line">管理员Administrator密码：admin</span><br><span class="line">60天有效（2024-05-09--07-09）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>RouterOS</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RouterOS 正在使用：</span><br><span class="line">mikrotik-6.49.13.iso</span><br><span class="line">操作系统：其他</span><br><span class="line">版本：其他</span><br><span class="line">Loading System 等待时间很长，大概6-10min</span><br><span class="line">账号：admin</span><br><span class="line">密码：admin</span><br></pre></td></tr></table></figure>
<h2 id="开始实验">开始实验</h2>
<h3 id="1-网络构建">1 网络构建</h3>
<blockquote>
<p>（PPT-02）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">路由器：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接口MAC</span></span><br><span class="line">interface ethernet</span><br><span class="line">print</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接口IP</span></span><br><span class="line">ip address </span><br><span class="line">add</span><br><span class="line">print</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">路由</span></span><br><span class="line">ip route</span><br><span class="line">add</span><br><span class="line">print</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙</span></span><br><span class="line">ip firewall</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加NAT</span></span><br><span class="line">ip firewall nat</span><br><span class="line">add chain=srcnat out-interface=向外走的接口 action=masquerade</span><br><span class="line"></span><br><span class="line">print</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-8.png" alt="P2-8" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-9.png" alt="P2-9" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-10.png" alt="P2-10" style="zoom:60%;" /> 
<blockquote>
<p>注：TTL的值在每次经过一站都会减一。若为0，则丢弃。</p>
</blockquote>
<h3 id="2-配置HTTP-FTP服务">2 配置HTTP/FTP服务</h3>
<blockquote>
<p>（PPT-02）</p>
</blockquote>
<ul>
<li>Win Server</li>
</ul>
<h3 id="3-ARP-欺骗">3 ARP 欺骗</h3>
<blockquote>
<p>（PPT-07）</p>
<p>wireShark 过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr == 192.168.142.11 or arp or icmp</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-0-理论知识">3.0 理论知识</h4>
<ul>
<li>
<h4 id="ARP">ARP</h4>
<p><strong>地址解析协议</strong>，（Address Resolution Protocol，RFC826）,负责完成逻辑地址向物理地址的动态映射，将32位逻辑地址（IP地址）转化为48位物理地址（MAC地址）。</p>
</li>
<li>
<p><strong>ARP 流程</strong></p>
<p>查看arp缓存 – 本网络？发ARP请求 — 非本网络？发ICMP给下一跳路由器处理</p>
<ol>
<li>
<p>判断是否本网络？（网段、子网掩码的设置）</p>
<ul>
<li>本网络内：主机发ARP请求（广播）直接询问所求ip的MAC地址</li>
<li>非本网络：主机发ICMP请求给网关，由网关去做。（这里网关的MAC也需要ARP请求得到，一般肯定设置时就ARP请求过了，所以就不必再发ARP请求询问MAC地址了）</li>
</ul>
</li>
<li>
<p>若没有设置网关？</p>
<p>非本网络的ARP请求会因为没有网关而发不出去。</p>
</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P7-4.png" alt="P7-4" style="zoom: 50%;" />    <img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P7-5.png" alt="P7-5" style="zoom: 50%;" /></p>
<ul>
<li><strong>ARP高速缓存</strong></li>
</ul>
<ol>
<li>
<p><strong>静态表项：永不过期的表项</strong></p>
<p>人工，也更加安全</p>
</li>
<li>
<p><strong>动态表项：有生命期的表项</strong></p>
<p>通过ARP协议学习</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 显示地址映射表项，[ ]为可选项</span><br><span class="line">arp -a [inet_addr] </span><br><span class="line"></span><br><span class="line">// 删除由inet_addr所指定的表项</span><br><span class="line">n arp -d [inet_addr] </span><br><span class="line"></span><br><span class="line">// 增加由inet_addr和phys_addr 指定的静态表项</span><br><span class="line">n arp -s inet_addr phys_addr </span><br><span class="line"></span><br><span class="line">// 显示帮助</span><br><span class="line">n arp /? </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>A 使用 Xcap 构造 ARP广播寻找 B</strong></p>
<p>(A/B/C 均同网段下) 然后各自查看 <code>arp -a</code></p>
<ul>
<li>A：没有 B 的mac（因为不是系统发的，是Xcap 发的，不会被记录下来）</li>
<li>B：有 A 的 mac （因为收到 A 的ARP请求，会记录）</li>
<li>C：没有 A/B 的 mac （因为虽然广播，但是不是C的包，会被丢弃不处理）</li>
</ul>
</li>
<li>
<p><strong>直接添加 静态 arp</strong></p>
<p><code>arp -s IP MAC</code></p>
<p>更安全</p>
</li>
<li>
<h4 id="代理ARP">代理ARP</h4>
<p>如果 ARP 请求是从一个网络的主机A发往另一个网络上的主机B，如果<strong>连接A的路由器知道如何去往B</strong>，那么<strong>它就可以回答该请求</strong>，此过程称作代理ARP (Proxy ARP)。这样对发起 ARP 请求的发送端是透明的，使它误以为路由器就是B，而路由器的实际功能相当于B的代理，负责把IP数据包转发到B。</p>
<ul>
<li>
<p>代理ARP可用来产生划分子网的效应。</p>
</li>
<li>
<p>代理ARP可以代表一组主机的ARP。</p>
</li>
<li>
<p>优点：</p>
<ol>
<li>主机可以不用配置默认网关</li>
<li>子网的变化对主机是透明的</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>增加了某一网段上ARP流量</li>
<li>需要更大的ARP 表来处理IP地址到MAC地址的映射</li>
<li>安全问题,比如ARP欺骗</li>
</ol>
</li>
</ul>
</li>
<li>
<h4 id="免费ARP">免费ARP</h4>
<p>免费 ARP (gratuitous ARP)是指主机发送ARP查找自己的MAC地址，但实际只是一种广而告之。</p>
<p>通常，它发生在系统引导期间进行接口配置或更改IP地址的时候。</p>
<ul>
<li>特点：
<ol>
<li>报文中携带的源IP和目的IP地址都是本机地址</li>
<li>报文源MAC地址是本机MAC地址。目的MAC地址为全0</li>
</ol>
</li>
<li>作用：
<ol>
<li>查找相同IP地址</li>
<li>更新ARP缓存</li>
</ol>
</li>
<li>恶作剧：将对方的IP拿来构建的免费ARP包不停地发送，每两秒一次。对方不断提示IP地址冲突。</li>
</ul>
</li>
<li>
<h4 id="ARP欺骗">ARP欺骗</h4>
<blockquote>
<p>“ ARP 欺骗”系列病毒自 06 年出现以来，一直难以根除。一旦感染此病毒，就会在局域网内发起攻击，导致其他用户不能上网，危害严重。电脑中毒后会向同网段内所有计算机发ARP欺骗包，导致网络内其它电脑因网关物理地址被更改而无法正常上网，被欺骗电脑的典型症状是刚开机能上网，几分钟之后断网，过一会又能上网，或者重启一遍电脑就可以上网，一会又不好了，如此不断重复，影响正常使用。</p>
</blockquote>
<ul>
<li>ARP 欺骗关键：缺乏身份认证，可以伪造MAC地址
<ul>
<li>ARP请求中的MAC地址伪造</li>
<li>ARP应答中的MAC地址伪造</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-1-Lab-欺骗主机">3.1 Lab 欺骗主机</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P7-1.png" alt="P7-1" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>使 B 无法 PING C</strong></p>
<ol>
<li>
<p><strong>A构造ARP请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的MAC：FF:FF:FF:FF:FF:FF</span><br><span class="line">源MAC：MAC-A</span><br><span class="line"></span><br><span class="line">ARP:</span><br><span class="line">源MAC: MAC-A</span><br><span class="line">源IP: IP-C</span><br><span class="line">目的MAC: 00:00:00:00:00:00</span><br><span class="line">目的IP: IP-B</span><br></pre></td></tr></table></figure>
<p>实际上是A发的请求，但是在源IP处写了 IP-C ，这导致B收到时，把 IP-C 解析的 MAC 记作了 MAC-A。</p>
</li>
<li>
<p><strong>B 去 ping C</strong></p>
<p>B 去ping C时，会发现 arp 缓存里有，就会按照这个错误的缓存来请求了，自然就请求不到数据。</p>
<p>最终，Request timed out.请求超时。</p>
<p>（可以 arp -a查看一下 B缓存的 IP-MAC对应关系，会发现 IP-C对应到MAC-A了）</p>
</li>
<li>
<p><strong>恢复</strong></p>
<p>B 可以 arp -d 清除缓存，就抹去了错误信息。或者稍等一会，动态缓存会自动消失。</p>
<p>再 ping C 就会正常了。（因为会重新发 arp请求询问 C 的mac，这时 C 会应答）</p>
</li>
</ol>
</li>
<li>
<p><strong>使 B 无法访问外网</strong></p>
<ol>
<li>
<p><strong>A构造ARP请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的MAC：FF:FF:FF:FF:FF:FF</span><br><span class="line">源MAC：MAC-A</span><br><span class="line"></span><br><span class="line">ARP:</span><br><span class="line">源MAC: MAC-A</span><br><span class="line">源IP: IP-R1</span><br><span class="line">目的MAC: 00:00:00:00:00:00</span><br><span class="line">目的IP: IP-B</span><br></pre></td></tr></table></figure>
<p>在源IP处写了 IP-R1 ，这导致B收到时，把 网关路由器R1- IP 解析的 MAC 记作了 MAC-A。</p>
</li>
<li>
<p><strong>B 去 ping <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a></strong></p>
<p>B 去ping baidu.com时，会需要网关R1。</p>
<p>向R1发数据，这时会发现 arp 缓存里有R1的MAC地址，就会按照这个错误的地址来请求了，自然就请求不到数据。</p>
<p>最终，could not find host找不到主机（因为在域名解析时就找不到网关R1）。</p>
<p>（可以 arp -a查看一下 B缓存的 IP-MAC对应关系，会发现 IP-R1 对应到 MAC-A了）</p>
</li>
<li>
<p><strong>恢复</strong></p>
<p>B 可以 arp -d 清除缓存，就抹去了错误信息。或者稍等一会，动态缓存会自动消失。</p>
<p>再 ping <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a> ，就会发现可以收到 Reply.</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-2-Lab-欺骗网关">3.2 Lab 欺骗网关</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P7-2.png" alt="P7-2" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>使D 无法 PING 通 B</strong></p>
<ol>
<li>
<p><strong>A构造ARP请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的MAC：FF:FF:FF:FF:FF:FF</span><br><span class="line">源MAC：MAC-A</span><br><span class="line"></span><br><span class="line">ARP:</span><br><span class="line">源MAC: MAC-A</span><br><span class="line">源IP: IP-B</span><br><span class="line">目的MAC: 00:00:00:00:00:00</span><br><span class="line">目的IP: IP-D</span><br></pre></td></tr></table></figure>
<p>导致 网关路由器R1 收到时，把 IP-B 对应 MAC-A 记录下来。</p>
</li>
<li>
<p><strong>D 去 ping B</strong></p>
<p>B 去ping baidu.com时，会需要网关R1。</p>
<p>向R1发数据，R1正常收到了。</p>
<p>但是，这时R1会发现 arp 缓存里有 IP-B 的MAC地址，就会按照这个错误的MAC-A来请求了，自然就请求不到数据。</p>
<p>最终，Request timed out.请求超时。</p>
<p>（可以在路由器R1的 ip arp 下 print 查看是否 IP-B 对应着 MAC-A）</p>
</li>
<li>
<p><strong>恢复</strong></p>
<p>这时，是网关路由器 R1被欺骗，因此，需要 R1把 IP-B 对应的MAC 由 MAC-A改为 MAC-B。</p>
<p>其实不用动，路由器很快会发现是错误的，立马重新发 arp 请求寻找正确的 MAC-B。</p>
<p>这也就是为什么，你会发现前面 D ping B ，虽然前两次 请求超时，但是后面就会正确。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-3-Lab-应答欺骗">3.3 Lab 应答欺骗</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P7-3.png" alt="P7-3" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>伪造应答</strong></p>
<ol>
<li>
<p><strong>A清除数据并 ping B</strong></p>
<p>在 cmd 下 <code>arp -d</code>清除缓存，然后 <code>ping IP-B</code></p>
<p>发现能够正常收到 B 回应。</p>
</li>
<li>
<p><strong>C 伪造 ARP 应答</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的MAC：MAC-A</span><br><span class="line">源MAC：MAC-C</span><br><span class="line"></span><br><span class="line">ARP:</span><br><span class="line">源MAC: MAC-C</span><br><span class="line">源IP: IP-B</span><br><span class="line">目的MAC: MAC-A</span><br><span class="line">目的IP: IP-A</span><br></pre></td></tr></table></figure>
<p>应答时，单播（从 C 到 A ），为了欺骗，发ARP请求时，写上自己是 IP-B （源IP）。</p>
</li>
<li>
<p><strong>A 再 ping B</strong></p>
</li>
</ol>
<p>由于A刚刚收到 C 发来的假冒 B 的arp响应，会更新缓存记录<code>IP-B 对应 MAC-C</code></p>
<p>那么再次 ping 时，也是发现有 arp 缓存有 IP-B的 MAC，那么就会把 MAC-C 贴上，发请求。</p>
<p>自然是收不到的 Request timed out. 请求超时。</p>
</li>
</ul>
<blockquote>
<p>提问：这里两次ping都是必须的吗？</p>
<p>实际上不是的。</p>
<p>提问：哪次是必须的？</p>
<p>第一次。</p>
<p>很意外吧？实际上是因为，若是只有第二次ping，那么在第二次ping前收到的reply是一个莫名其妙的reply，因为这个reply告知的IP，我们（A）并没有记录过，自然也不需要更新，采取的策略是“不处理”，因此不会记录下这个欺骗的报文。</p>
<p>只有当前面我们（A）自主ping过B，才会把B记录在ARP缓存里，之后收到欺骗，才会发现“哦，现在IP-B的MAC变了，那我更新一下ARP缓存”，这样子就被欺骗了。</p>
<p>（问：那是不是A按理说不更新更好？不是的，最初这样子设计的是因为有时候的确就是会发生变化，这是正确的做法，只是被有心人利用了）</p>
</blockquote>
<h3 id="4-路由记录">4 路由记录</h3>
<blockquote>
<p>PPT-09</p>
</blockquote>
<h4 id="4-0-理论知识">4.0 理论知识</h4>
<ul>
<li>
<h4 id="IP选项">IP选项</h4>
<p>IP数据报选项字段是可选的，主要用于网络测试和调试</p>
<ul>
<li>记录数据报经过的路由</li>
<li>记录数据报经过的路由和时间</li>
<li>源端指定必须经过的路由</li>
<li>路径MTU发现</li>
</ul>
<p>在一个数据报中可以有多个选项，这些选项是连续出现的。<br>
每个选项的长度取决于选项的类型,并且格式都不相同。<br>
每个选项可以有三个部分组成：</p>
<ul>
<li>代码1个字节</li>
<li>长度1个字节（可选，由代码决定）</li>
<li>数据部分（可选，由代码决定）</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-6.png" alt="P9-6" style="zoom: 50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-7.png" alt="P9-7" style="zoom:50%;" /> 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[code字段选项(1字节)]</span><br><span class="line"></span><br><span class="line">End of options list (code = 0)  只能用于所有选项后，指示选项已经结束</span><br><span class="line">0 00 00000</span><br><span class="line"></span><br><span class="line">No Operation (code = 1)   用于选项之间，用于将下一个选项起始字节对齐到4字节的倍数</span><br><span class="line">0 00 00001</span><br><span class="line"></span><br><span class="line">Record route (code = 7)  记录数据包在传输过程中所经过的路由器</span><br><span class="line">0 00 00111</span><br><span class="line"></span><br><span class="line">Source and Record Route (code = 0x83)  松散源路由</span><br><span class="line">1 00 00011</span><br><span class="line"></span><br><span class="line">Strict Source and Record Route (code = 0x89) 严格源路由</span><br><span class="line">1 00 01001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Record route (code = 7)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-8.png" alt="P9-8" style="zoom:60%;" /> 
<ul>
<li>路由器在转发过程中如果发现此选项，那么将其IP地址（转发端口所在的地址）拷贝到IP列表的最后（由POINTER指示），并且将POINTER增加4。</li>
<li>如果POINTER &gt; length（已满），路由器只转发不记录路由；(可以发送ICMP Parameter，实际不发送，因为发送导致DOS攻击)</li>
<li>如果还有空间但不足，路由器认为报文出错而丢弃；这种情况下，路由器可以发送给源端发送 ICMP Parameter。</li>
</ul>
</li>
<li>
<p><strong>实验1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Record route:实验1</span><br><span class="line">目的：理解记录路由选项</span><br><span class="line">主机：IP-A=192.168.142.11, IP- B=192.168.134.11, C = 192.168.140.11</span><br><span class="line">设置：网络拓扑图(IS-VM.ppt) </span><br><span class="line">操作：A发送数据到B</span><br><span class="line"></span><br><span class="line">A：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">B: 打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">C：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">A: ping -r 8 192.168.134.11</span><br><span class="line">A：查看发出的ICMP Request的记录路由选项的指针和IP列表</span><br><span class="line">B: 查看记录的IP列表</span><br><span class="line">C：查看记录的IP列表</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<ol>
<li>
<p>A：发出去的流量包中的 record route 为8个 0.0.0.0</p>
</li>
<li>
<p>B：同 A</p>
</li>
<li>
<p>C：流量包中的 Record Route 有三条记录，如下：</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-9.png" alt="P9-9" style="zoom:60%;" /> 
</li>
<li>
<p>A：收到回复，Record Route 会有五条记录，如下：</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-10.png" alt="P9-10" style="zoom:60%;" /> 
</li>
</ol>
</li>
<li>
<p><strong>实验2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Record route:实验2</span><br><span class="line">目的：理解记录路由选项</span><br><span class="line">主机：IP-A=192.168.142.11, IP- B=192.168.134.11, C = 192.168.140.11</span><br><span class="line">设置：网络拓扑图(IS-VM.ppt) </span><br><span class="line">操作：A发送数据到B，</span><br><span class="line"></span><br><span class="line">A：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">B：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">C：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">Router3: 将其位于134网段的接口MTU设置为420</span><br><span class="line">A: 构建并发送一个Ping请求包去记录A到B之间的路径，数据部分为1000个字节</span><br><span class="line">A：查看记录的IP列表</span><br><span class="line">B：查看各个碎片的选项部分</span><br><span class="line">C：查看记录的IP列表</span><br><span class="line">A：将数据包pointer改成5并且只留两个IP地址列表，查看发送和接收情况</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p>略</p>
</li>
<li>
<p><strong>分片</strong></p>
<p>如果，我们要求<strong>R3 - 140网段是 MTU 为420</strong>。</p>
<p>先进入<code>ip address</code>查看print，找到 140网段的接口是 <code>ether2</code>。</p>
<p>再进入 <code>interface</code>设置<code>set ether2 mtu=420</code>。</p>
<p>最后查看是不是正确了，<code>interface ethernet</code>进行print查看，如下：</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-16.png" alt="P9-16" style="zoom: 80%;" /> 
<blockquote>
<p>若是 A 发的请求，中途即便是因为R3分片了，也会在R3收集好再发出来。</p>
<p>因此对A来说，分片是透明的，只看到一个请求、一个响应。</p>
</blockquote>
</li>
</ul>
<h4 id="4-1-Lab-构建-ping-包记录">4.1 Lab 构建 ping 包记录</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-1.png" alt="P9-1" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-2.png" alt="P9-2" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>构建 ping 包，设置 Record Route</strong></p>
<ol>
<li>
<p><strong>构建 Record Route 的 ICMP 包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAC层：</span><br><span class="line">目的MAC：A的出口路由器对应接口的MAC</span><br><span class="line">源MAC：MAC-A</span><br><span class="line"></span><br><span class="line">IP层：</span><br><span class="line">源IP：IP-A</span><br><span class="line">目的IP：IP-B</span><br><span class="line">类型：ICMP</span><br><span class="line">Options：添加(7, Record Route)，设置8个0.0.0.0在Address list中</span><br></pre></td></tr></table></figure>
<p>设置好了之后，发送。</p>
<p>（注：MAC层的目的MAC是 直接下一跳的MAC，不是最终目的MAC）</p>
</li>
<li>
<p><strong>在B查看 Request</strong></p>
<p>会看到 三条记录（R1-R3-B）。</p>
</li>
<li>
<p><strong>在 A 查看 Reply</strong></p>
<p>会看到 五条记录（R1-R3-B-R3-R1)。</p>
</li>
</ol>
<blockquote>
<p>如何控制经过R1还是R3？</p>
<p>答：设置好A的网关是R1还是R3即可。</p>
</blockquote>
</li>
<li>
<p><strong>解释 IP记录</strong></p>
<p>根据网络拓扑解释即可。</p>
<p>最初主机A找到网关路由器（记录IP），网关路由器再走去下一个路由器（记录IP），路由器发现在直连网段下，因此直接发送到主机上。</p>
<p>主机B接收到，进行 Relpy 回复（回复时，继续加上自己的IP），再往回送（同样，两次记录路由器IP），到达主机A。</p>
</li>
</ul>
<h3 id="5-严格源路由">5 严格源路由</h3>
<blockquote>
<p>PPT-09</p>
</blockquote>
<h4 id="5-0-理论知识">5.0 理论知识</h4>
<ul>
<li>
<p><strong>源路由选项</strong></p>
<ul>
<li>
<p>本选项由于安全原因，路由器可能不支持。</p>
</li>
<li>
<p>用于规定数据包经过的路径，有两种方式：</p>
<ol>
<li>
<p>严格源路由</p>
<p>包含一个IP地址序列，该序列指出了到达目的地的<strong>完整路径</strong>。</p>
<p>数据报必须沿着IP地址序列传输，<strong>路由器只是</strong>将数据包<strong>转发</strong>到指定的下一个IP地址，而<strong>不进行路由</strong>（下一个IP地址必须直接可达）。</p>
</li>
<li>
<p>松散源路由</p>
<p>包含一个IP地址序列，该序列指出了到达目的地的<strong>部分路径</strong>。</p>
<p>数据报必须沿着IP地址序列传输，但是<strong>允许</strong>表中相继两个地址之间<strong>相隔多个路由器</strong>或物理网络。</p>
</li>
</ol>
</li>
<li>
<p>由于还同时记录经过的路径（记录路由），</p>
<p>所以它通常称为source and record route( SRR)和 strict source and record route( SSRR)。</p>
</li>
<li>
<p>记录路由方式和记录路由选项相似。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-11.png" alt="P9-11" style="zoom: 50%;" /> 
</li>
<li>
<p><strong>发送方的处理过程</strong></p>
<ul>
<li>
<p>假设主机A到B的路径为 <code>A-X1-X2-X3-B</code></p>
</li>
<li>
<p>虽然A的目的地为B，但Destination IP一定要填下一站的地址，而非IP-B</p>
</li>
<li>
<p>将其他下一站地址依次填入选项数据内，最后一个IP地址为IP-B</p>
<blockquote>
<ul>
<li>
<p>严格源路由：下一站地址必须是直接可以到达。</p>
<p>例如，X2 必须是从 X1 直接能够到达，而不必再经过其他路由器。</p>
</li>
<li>
<p>松散源路由：下一站地址不必直接可以到达。</p>
<p>例如，X2 可以是从 X1 经过其他路由器间接到达。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-12.png" alt="P9-12" style="zoom:50%;" /> 
</li>
<li>
<p><strong>转发或接收时的处理过程</strong></p>
<ul>
<li>
<p>主机A到B的路径为<code>A-X1-X2-X3-B</code></p>
</li>
<li>
<p>当接收到数据时, 检查 pointer &lt; length 是否成立：</p>
<ol>
<li>
<p><code>pointer &gt;= length</code></p>
<p>IP地址序列已经用完，说明本站是最后一站（接受方），将数据交给上层协议</p>
</li>
<li>
<p><code>pointer &lt; length</code></p>
<p>需要转发数据，将IP层的 Destination IP 换成 pointer 所对应的IP （即数据的下一站），将pointer所对应的IP换成转发时使用的接口IP，<code>pointer = pointer + 4</code>。</p>
</li>
</ol>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-13.png" alt="P9-13" style="zoom:50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-14.png" alt="P9-14" style="zoom:50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-15.png" alt="P9-15" style="zoom:50%;" /> 
</li>
</ul>
<h4 id="5-1-Lab-严格源路由">5.1 Lab 严格源路由</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-3.png" alt="P9-3" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-4.png" alt="P9-4" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-5.png" alt="P9-5" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-8.png" alt="P2-8" style="zoom:60%;" /> 
<ul>
<li>
<p><strong>前提：</strong></p>
<ol>
<li>
<p>一般是默认不接收源路由记录的，因此需要<strong>手动开启</strong> accept-source-route 。</p>
<p>登陆路由器，进入 <code>ip settings</code>可以print看一下，第三行是<code>accept-source-route</code>默认是 <code>no</code></p>
<p>设置开启：<code>set accept-source-route=yes</code></p>
<p>重启路由器：<code>system reboot</code></p>
</li>
<li>
<p>主机一般是不响应的，因此我们的最<strong>终目的IP 是路由器端口IP</strong> ，而不是主机IP。</p>
</li>
<li>
<p>为什么主机和路由器一般都不支持？</p>
<p>由下面实验可知源路由会造成<strong>流量放大效应</strong>，因此可以<strong>引起DOS攻击（消耗带宽和CPU）</strong>。</p>
</li>
</ol>
</li>
<li>
<p><strong>实验过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=192.168.142.11, B = 192.168.140.99（路由器端口，winxp主机可能不响应）</span><br><span class="line">A到B的路径为A-R1-R3-R4-R2-R1-R3-R4-R2-R1-B</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>A 构建 严格源路由的ICMP 请求包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MAC层:</span><br><span class="line">目的MAC: R1对应142网段的接口MAC</span><br><span class="line">源MAC: MAC-A</span><br><span class="line"></span><br><span class="line">IP层：</span><br><span class="line">源IP：IP-A</span><br><span class="line">目的IP：R1对应142网段的IP（142.100）</span><br><span class="line">类型：ICMP</span><br><span class="line">Options：设置 (9, Strict Source Route)，在 Address list 添加如下：</span><br><span class="line">192.168.140.99</span><br><span class="line">192.168.134.99</span><br><span class="line">192.168.136.100</span><br><span class="line">192.168.138.100</span><br><span class="line">192.168.140.99</span><br><span class="line">192.168.134.99</span><br><span class="line">192.168.136.100</span><br><span class="line">192.168.138.100</span><br><span class="line">192.168.140.99</span><br></pre></td></tr></table></figure>
<p>构建好了之后，发送即可。</p>
<p>下面开始查看各自主机的wireshark监控流量情况。</p>
</li>
<li>
<p><strong>A：一条请求、一条响应</strong></p>
<p>可以看到请求的 IP 层 options 下的 Strict Source Route。</p>
<p>（当前 dst-IP 是 R1，next 是 R3）</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-17.png" alt="P9-17" style="zoom:50%;" /> 
</li>
<li>
<p><strong>140网段下的主机：三条请求、三条响应</strong></p>
<p>由于会三次经过 140 网段，因此会发现有三条请求和响应。</p>
<p>可以打开看一下参数：</p>
<p>第一个：next 指向 第一个 134.99 （当前dst-IP为140.99）</p>
<p>第二个：next 指向 第二个 134.99 （当前dst-IP为140.99）</p>
<p>第三个：Pointer=40 大于 Length=39，next 没有指向 （当前dst-IP为140.99，最后一个了，已经填入 dst-IP ）</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-18.png" alt="P9-18" style="zoom:50%;" /> 
</li>
<li>
<p><strong>136网段下的主机：两条请求、两条响应</strong></p>
<p>同理，只不过 136 网段是经过两次，因此有两条请求和响应。</p>
<p>分析和前面一样。</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P9-19.png" alt="P9-19" style="zoom:50%;" /> 
</li>
</ol>
</li>
</ul>
<h3 id="6-ICMP-重定向">6 ICMP 重定向</h3>
<blockquote>
<p>PPT-10</p>
</blockquote>
<h4 id="6-0-理论知识">6.0 理论知识</h4>
<ul>
<li>
<p><strong>ICMP报文分类</strong></p>
<ol>
<li>差错报文
<ul>
<li>回送 请求和应答</li>
<li>时间戳 请求和应答</li>
<li>地址掩码 请求和应答</li>
<li>路由器 询问和通告</li>
</ul>
</li>
<li>查询
<ul>
<li>目标不可达</li>
<li>源点抑制</li>
<li>时间超时</li>
<li>参数问题</li>
<li>改变路由</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>ICMP报文</strong></p>
<p>ICMP报文特点</p>
<ul>
<li>
<p>报告差错：</p>
<p>ICMP差错报文最根本的功能是反馈数据通信过程中遇到的问题，并非使IP传输更加可靠。</p>
</li>
<li>
<p>非必需：</p>
<p>即使数据在传输过程遇到问题，也可能不发送差错报文。</p>
</li>
<li>
<p>为防止报文的反复发送，不会对ICMP差错报文发送ICMP报文，但ICMP查询报文可能再次产生ICMP报文。</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-3.png" alt="P10-3" style="zoom:50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-4.png" alt="P10-4" style="zoom:50%;" /> 
<blockquote>
<ul>
<li>代码：提供相关报文类型的进一步信息</li>
<li>校验和：提供整个ICMP报文的校验和</li>
<li>数据：
<ul>
<li>差错报文：包括出错IP数据包头部及该数据包前8个字节的数据，前8个字节是为了得到运输层的端口号（对于TCP和UDP）以及发送序号（对于TCP）</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><strong>ICMP查询报文</strong></p>
<ul>
<li>
<p>回送请求与应答</p>
<p>ICMP回送请求与应答报文(ICMP Echo Request and Reply)目的：测试目的设备是否可以到达。</p>
<blockquote>
<p>RFC1122要求每台设备必须响应ICMP回送请求，但可能考虑到安全因素，设备可能不会响应</p>
</blockquote>
</li>
<li>
<p>应答报文中的数据和请求报文中的数据一致。</p>
</li>
<li>
<p>标识符和序号用于将收到的应答和发出的请求相匹配。</p>
<p>标识符可以像TCP端口一样使用，而序列号每发出一次请求增加1。</p>
<p>应答时使用和请求报文中相同的标示符和序列号。</p>
<blockquote>
<p>实际中，</p>
<ol>
<li>
<p>Linux每个PING进程使用不同的标示符，而序列号每次增加1。</p>
</li>
<li>
<p>WINDOWS使用一样的标识符（版本之间可能有所区别），序列号在重启时重置。</p>
</li>
</ol>
<p>从PING数据可以从一定程度上推测发送方的操作系统。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>实验1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">回送请求与应答：实验</span><br><span class="line">目的：理解回应请求与应答报文</span><br><span class="line">设置：[winxp A=192.168.142.11] [win server2003 B：192.168.142.111] [RouterOS R1: 192.168.142.100]</span><br><span class="line"></span><br><span class="line">A：ping B</span><br><span class="line">A: wireshark查看PING发出的ICMP Echo request and 收到的reply报文</span><br><span class="line">特别是标识符是否一样(Identifier均为2)</span><br><span class="line">序列号增加(Sequence number依次增加)</span><br><span class="line">数据为abcd..... (Data内容)</span><br><span class="line">应答与请求标识符、序列号和数据一致</span><br><span class="line"></span><br><span class="line">A：PING B</span><br><span class="line">A: wireshark查看和前一次PING发出的请求中的标识符是否一致</span><br><span class="line"></span><br><span class="line">A: ping R1</span><br><span class="line">A: wireshark查看PING发出的ICMP Echo request and 收到的reply报文</span><br><span class="line">特别是标识符是否一样</span><br><span class="line">序列号增加</span><br><span class="line">数据为abcd..... n 应答与请求标识符、序列号和数据一致</span><br><span class="line"></span><br><span class="line">R1: ping A</span><br><span class="line">A: wireshark查看PING发出的ICMP Echo request and 收到的reply报文</span><br><span class="line">标识符是否一样(Identifier不一样)</span><br><span class="line">序列号增加(Sequence Number 增加)</span><br><span class="line">数据本身没有规律</span><br><span class="line">应答与请求标识符、序列号和数据一致</span><br><span class="line"></span><br><span class="line">R1: ping A</span><br><span class="line">A: wireshark查看和前一次PING发出的请求中的标识符是否一致</span><br><span class="line"></span><br><span class="line">R1: ping A</span><br><span class="line">R1: ping A</span><br><span class="line">A: wireshark比较两次PING中发出的ICMP Echo request and reply报文</span><br><span class="line">（标识符、序列号如何变化，不同PING之间数据也有一定规律）</span><br><span class="line"></span><br><span class="line">从PING数据可以从一定程度上推测发送方的操作系统</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>时间戳请求与应答</strong></p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-5.png" alt="P10-5" style="zoom:50%;" /> 
<ul>
<li>
<p>标识和序列号用来关联响应与请求</p>
<ul>
<li>ST: 源时间戳(Originate timestamp)为请求方在请求发送之时的时间（源主机填）</li>
<li>RR: 接收时间戳(Receive timestamp)为收到请求时的时间（目的主机填）</li>
<li>RT: 传送时间戳(Transit timestamp)为接收方发回时间戳响应时的时间（目的主机填）</li>
<li>SR: 源主机接收时间</li>
</ul>
<p>时间均为格林威治标准时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送时间 = RR - ST</span><br><span class="line">接收时间 = SR - RT</span><br><span class="line">往返时间 = 发送时间 + 接收时间 = RR - ST +SR - RT = (SR- ST) - (RT - RR)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>只有当源点和终点的机器中的时钟同步，发送时间和接收时间的计算才能准确。</p>
<p>但是，即使两个时钟没有同步，往返时间的计算还是准确的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将设发送方时钟偏移x，接收方偏移为y。</span><br><span class="line">往返时间 </span><br><span class="line">= 往所需时间 + 返所需时间</span><br><span class="line">= (RR + y) - (ST + x) + (SR + x) - (RT + y)</span><br><span class="line">= (SR - ST) - (RT - RR)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="6-0-1-差错报文1-目的不可达">6.0.1 差错报文1-目的不可达</h5>
<ul>
<li>
<p><strong>RFC规范用语</strong></p>
<ul>
<li>MAY：可以（实现RFC规范时可以自由选择）</li>
<li>SHOULD （SHOULD NOT）：应该（强烈建议）</li>
<li>MUST （MUST NOT）：必需（必须实现）</li>
</ul>
</li>
<li>
<p><strong>目的</strong></p>
<p>通知发送方目的地<strong>不可到达</strong></p>
</li>
<li>
<p><strong>终点不可达</strong></p>
<p>分为：</p>
<ol>
<li>网络不可达</li>
<li>主机不可达</li>
<li>协议不可达</li>
<li>端口不可达</li>
<li>需要分片</li>
</ol>
<p>由code决定，当然code包含更多其他的错误。</p>
</li>
<li>
<p><strong>Next-Hop MTU (RFC 1191)</strong></p>
<ul>
<li>
<p>和code = 4一起使用。</p>
</li>
<li>
<p>当路由器发现数据包的大小大于下一跳网络的MTU时，而且原始数据包不允许分片（DF置位）时, 路由器必须（MUST）发送一个ICMP差错报文，通知发送方需要允许分片，并且指出了NEXT- HOP的MTU。</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-6.png" alt="P10-6" style="zoom:50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-7.png" alt="P10-7" style="zoom:50%;" /> 
<ul>
<li>
<p><strong>网络不可到达（RFC 1812）</strong></p>
<p>如果路由器无法找到去往目的网络的路由（包括默认路由），那么路由器必须（MUST）发送一个网络不可到达的ICMP差错报文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">网络不可到达:实验</span><br><span class="line">目的：理解终点不可到达/网络不可到达</span><br><span class="line">设置：A发送数据到B，IP- A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">R1: disable其中去往B网络的路由</span><br><span class="line">A：打开wireshark, filter:icmp</span><br><span class="line">B: 打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">A：构建并发送一个去往B的ICMP Echo Request包（可以标注一下Sequence Number的DE/LE，用来后面识别）</span><br><span class="line">A：查看ICMP差错报文：code = Network Unreachable， 发送方IP</span><br><span class="line"></span><br><span class="line">会发现：</span><br><span class="line">type: 3	(unreachable)</span><br><span class="line">code: 0 (network unreachable)</span><br><span class="line">还会发现 ICMP 里面夹杂着 ICMP（因为会把出错数据包复制过来，可以看看里面的DE/LE是不是前面设置的）</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主机不可到达 RFC 1812</strong></p>
<p>如果路由器（通常最后一个路由器）无法将数据包转发到位于直连网络上的目的主机，那么路由器必须（MUST）发送一个主机不可到达的ICMP差错报文。</p>
<ul>
<li>原因可能有：目的主机不存在、目的主机不响应ARP请求。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主机不可到达:实验</span><br><span class="line">目的：理解终点不可到达/主机不可到达</span><br><span class="line">设置：A=192.168.142.11，B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A：打开wireshark, filter:icmp</span><br><span class="line">B: 打开wireshark, filter: icmp or arp</span><br><span class="line">A：构造一个PING请求发送给192.168.136.12</span><br><span class="line">A：查看ICMP差错报文：code = Host Unreachable， 发送方IP</span><br><span class="line">C: 查看ARP请求，无响应</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>协议不可到达</strong></p>
<p>主机在以下情况下发送协议不可到达ICMP：</p>
<ul>
<li>RFC792：主机没有相应的协议处理模块，主机可以（MAY）发送协议不可到达消息</li>
<li>RFC1122：主机应该（ SHOULD）发送协议不可到达消息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">协议不可到达:实验</span><br><span class="line">目的：终点不可到达/协议不可到达</span><br><span class="line">设置：A发送数据到B，IP-A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A: 打开wireshark, 选择合适的过滤器</span><br><span class="line">B: 打开wireshark, 选择合适的过滤器</span><br><span class="line">A: 构建并发送一个包，类型选custom自定义，其中IP.protocol = 0，包的设置如后图</span><br><span class="line">A: 查看ICMP差错报文：type = 3, code = Protocol Unreachable，发送方IP</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-8.png" alt="P10-8" style="zoom:50%;" /> 
<blockquote>
<p>问：有什么用？</p>
<p>可以用来探测对方主机是否存在。</p>
<p>因为对方可能不会响应PING请求，但是，使用一个未知协议，对方可能就会响应协议不可到达。对方只要是响应了，那就说明存在。（ Protocol 扫描）</p>
</blockquote>
</li>
<li>
<p><strong>端口不可到达</strong></p>
<ul>
<li>
<p>主机在以下情况下发送端口不可到达ICMP：</p>
<ol>
<li>
<p>RFC792</p>
<p>在主机相应<strong>端口没有开启</strong>的情况下，主机可以（MAY）发送端口不可到达消息</p>
</li>
<li>
<p>RFC1122</p>
<p>在主机<strong>无法将数据上传 (demultiplex) 到相应的端口</strong>时并且没有其他机制来通知发送方时，主机应该（ SHOULD）发送端口不可到达消息。</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">端口不可到达:实验</span><br><span class="line">目的：终点不可到达/端口不可到达</span><br><span class="line">设置：A发送数据到B，IP- A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A：打开wireshark, 选择合适的过滤器</span><br><span class="line">B: 打开wireshark, 选择合适的过滤器</span><br><span class="line">A：构建并发送一个包，其中IP.protocol = UDP, UDP.Destination Port = 11111，包的设置如后图</span><br><span class="line">A：查看ICMP差错报文：type = 3, code = Protocol Unreachable，发送方IP</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-9.png" alt="P10-9" style="zoom: 50%;" /> 
</li>
<li>
<p><strong>需要分片</strong></p>
<p>当路由器发现数据包的大小大于下一跳网络的MTU时，而且原始数据包不允许分片（DF）时,</p>
<p>路由器必须（MUST）发送一个ICMP不可到达的ICMP报文通知发送方，并且指出了NEXT-HOP的MTU</p>
<ul>
<li>这个报文可以用于发现从源到接收端的最小MTU。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">需要分片:实验</span><br><span class="line">目的：终点不可到达/需要分片</span><br><span class="line">设置：A发送数据到B，IP- A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A：打开wireshark, 选择合适的过滤器</span><br><span class="line">B: 打开wireshark, 选择合适的过滤器</span><br><span class="line">R1: 将路由器R1的138端口的MTU改为320</span><br><span class="line">A：构建并发送一个ICMP Echo Request包，大小超过320, DF = 1</span><br><span class="line">A：查看ICMP差错报文：发送方IP，type = 3, code，以及Next Hop</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="6-0-2-差错报文2-超时">6.0.2 差错报文2-超时</h5>
<ul>
<li>
<p>超时(Time Exceeded)报文（可能）在以下两种情况下发送：</p>
<ol>
<li>传输过程中TTL变为0</li>
<li>重组过程中超时</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-10.png" alt="P10-10" style="zoom: 50%;" /> 
</li>
<li>
<p><strong>超时：实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">目的：理解ICMP差错报文：超时</span><br><span class="line">设置：A发送数据到B，IP- A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A：打开wireshark, filter: icmp</span><br><span class="line">B：打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">A：构建并发送一个包发送给B，其中TTL=2</span><br><span class="line">A：查看ICMP差错报文：type = 11, code = 0，发送方IP</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>B收不到</li>
<li>A收到一个超时报文</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>重组超时:实验</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">目的：理解ICMP差错报文：超时</span><br><span class="line">设置：A发送数据到B，IP- A=192.168.142.11， IP-B=192.168.136.11</span><br><span class="line"></span><br><span class="line">A：打开wireshark, filter:ip.addr == IP-A</span><br><span class="line">B: 打开wireshark, filter: ip.addr == IP-A</span><br><span class="line">R1: 关闭NAT</span><br><span class="line">A：构建并发送一个包发送给B（数据大于500），其中MF = 1, TTL=64</span><br><span class="line">A：查看ICMP差错报文（需等待一段时间）：type = 11, code = 1，发送方IP；</span><br><span class="line"></span><br><span class="line">A：wireshark修改时间显示格式，比较ICMP请求和收到的ICMP差错报文时间间隔</span><br><span class="line">A：XCAP修改构造的报文原地址，设置Action: Increase, Num: 1, Loop: 50，LOOP发送 ， LIMIT：50</span><br><span class="line">B：wireshark可以看到多个差错报文</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>B收到碎片，B会启动超时计时器，大概60s 超时后B发送超时报文</li>
<li>A收到一个超时报文</li>
</ul>
<p><code>MF=1</code>意为：后面还有碎片</p>
</blockquote>
</li>
</ul>
<h5 id="6-0-3-重定向报文">6.0.3 重定向报文</h5>
<ul>
<li>
<p>ICMP Redirect重定向报文主要为了通知主机通过另一条（更优）的路径（新的网关由报文的Gateway IP Address指定）发送数据。</p>
</li>
<li>
<p>应由网关发送，主机不应发送。</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-11.png" alt="P10-11" style="zoom: 50%;" /> 
</li>
<li>
<p><strong>报文格式</strong></p>
<p>Code字段列出了重定向的原因：</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-12.png" alt="P10-12" style="zoom:50%;" /> 
</li>
<li>
<p><strong>前提</strong></p>
<p>RFC792规定了ICMP Redirect报文发送的条件：</p>
<ul>
<li>主机A、网关G1和G2三者位于<strong>同一网段</strong>，主机有数据发往网络N中的主机B</li>
<li>主机A的路由表中去往N的下一跳是G1</li>
<li>G1通往N的下一跳为G2（实际上<strong>G1认为A应该选择G2</strong>，因为此路径<strong>更短</strong>）</li>
<li>主机A发送的报文中<strong>没有源路由</strong>选项</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-13.png" alt="P10-13" style="zoom: 50%;" /> 
</li>
<li>
<p><strong>主机如何处理</strong></p>
<ol>
<li>
<p>RFC816</p>
<p>对主机的要求：</p>
<ul>
<li>
<p>主机在收到 ICMP重定向消息后必须<strong>更新路由</strong>信息；</p>
<p>所有主机都必须随时接受和处理ICMP重定向消息。</p>
</li>
<li>
<p>路由信息的更新主要是路由缓存的更新（更新下一跳），</p>
<p>如果缓存路由表中没有目的地这一记录，增加一记录。</p>
</li>
<li>
<p><strong>后续</strong>数据包通过<strong>新的网关</strong>发送。</p>
</li>
<li>
<p>主机对ICMP网络重定向的处理和对主机重定向的处理方式相同。</p>
</li>
</ul>
</li>
<li>
<p>RFC1122</p>
<p>规定主机在收到 ICMP重定向消息后遇到以下情况<strong>应当(should)不处理</strong>：</p>
<ul>
<li>
<p>A：新的网关和主机相关接口（收到ICMP的接口）<strong>不在同一网络</strong>上</p>
<blockquote>
<p>原因：不在同一网络上表示不能直接到达</p>
</blockquote>
</li>
<li>
<p>B：ICMP重定向报文<strong>发送者</strong>的地址不是（路由表中）去往相应目的地的一下跳地址</p>
</li>
</ul>
</li>
<li>
<p>RFC1812</p>
<p>规定了路由器在满足以下情况下可以发送redirect报文，否则一定不能(must not)发送报文：</p>
<ul>
<li>
<p>A：路由器(例子中的G1)的<strong>转发接口和接收接口一致</strong></p>
<blockquote>
<p>相当于报文沿原路返回</p>
</blockquote>
</li>
<li>
<p>B：数据包中的源IP地址(例子中的IP-A)和路由器将要转发的下一跳地址（例子中的IP-G2）处于<strong>同一网络</strong>（意味着主机(例子中的A)和下一跳（例子中的G2）在同一网络）</p>
<blockquote>
<p>意味着主机可以直接到达</p>
</blockquote>
</li>
<li>
<p>C：数据包中<strong>不含源路由</strong>选项</p>
</li>
</ul>
</li>
<li>
<p>RFC1812</p>
<p>如果路由器使用<strong>路由协议</strong>来获取路由信息，路由器<strong>不能</strong>(must not)使用<strong>重定向</strong>报文获悉的路由来转发数据</p>
</li>
</ol>
</li>
<li>
<p><strong>重定向：伪造报文要求</strong></p>
<ul>
<li>
<p>假设</p>
<ul>
<li>
<p>主机A（待被欺骗）位于网络N1</p>
</li>
<li>
<p>G1和G2路由器位于网络N1</p>
</li>
<li>
<p>主机B位于网络N2</p>
</li>
<li>
<p>A中路由表中去往N2的下一跳为G1</p>
</li>
</ul>
</li>
<li>
<p>C 如何冒充 G1 向 A 发送重定向报文，谎称去往目的 B 的网关应该为 G2？</p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-14.png" alt="P10-14" style="zoom:50%;" /> 
</li>
<li>
<p><strong>伪造报文要求</strong></p>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-15.png" alt="P10-15" style="zoom: 50%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-16.png" alt="P10-16" style="zoom:50%;" /> 
</li>
</ul>
</li>
<li>
<p><strong>重定向：实验1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">目的：理解重定向包在什么情况下发送</span><br><span class="line">设置：A(192.168.140.11)向B(192.168.134.11)发送ICMP请求，A的默认网关为R1</span><br><span class="line"></span><br><span class="line">A：ROUTE PRINT（确定去往B的路径）</span><br><span class="line">A：打开Wireshark，filter:ICMP</span><br><span class="line">R1：查看通往B的路由是否通过R3</span><br><span class="line">A：PING B</span><br><span class="line"></span><br><span class="line">A：查看Wireshark的ICMP REDIRECT包: type = redirect code = redirect for host, 和Gateway Address</span><br><span class="line">A：wireshark可以看到在REDIRECT前的ICMP Echo request被捕获到两次（因为A→R1→R3），两次的TTL的区别；查看第一次ICMP请求的dst mac为R1路由器相应接口地址。）</span><br><span class="line">A：wireshark可以看到在REDIRECT后的ICMP Echo request：dst mac 为R3相应接口地址</span><br><span class="line">A：route print （查看是否多了一条去往B的路由）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前后两次route print</p>
<p>可以发现 A 主机有一条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst             mask             gateway</span><br><span class="line">192.168.134.11  255.255.255.255  192.168.140.99 </span><br></pre></td></tr></table></figure>
<p>本来应该是A网关为 192.168.140.100，应该发给100，但是由于ping一次之后，会发现可以重定向到 99 更好。</p>
<p>因此，多了一条路由记录。</p>
<ul>
<li>
<p>可以在wireshark看到有一个 <strong>ICMP 的 Redirect 包</strong>。（可以看到新的gateway，以及原始报文附录，方便知道哪个报文被重定向了）</p>
</li>
<li>
<p>同时可以看到两个请求</p>
<p>为什么？因为在这个网段是A-&gt;R1-&gt;R3，而A和R1都是同一个网段，他们的出发都会被这个网段下的主机收到，因此A两次看到同一个包（第一次是A自己发的，第二次是R1发的）</p>
</li>
<li>
<p>此后，若再次请求</p>
<p>就会按照route直接从A走向R3，而不需要走R1了。</p>
</li>
<li>
<p>route会老化，也可以自己删除 <code>route delete</code>。</p>
</li>
<li>
<p>注：还可以使用 <code>ping -r 8 192.168.134.11</code> 来获取 ping 的路线查看</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>重定向：实验2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目的：理解重定向包在什么情况下发送</span><br><span class="line">设置：A=192.168.140.11  B=192.168.134.11</span><br><span class="line"></span><br><span class="line">A：ROUTE PRINT（如果有去往B的路径，删除它）</span><br><span class="line">A：打开Wireshark，filter:ICMP</span><br><span class="line">R1：查看通往B的路由是否通过R3</span><br><span class="line">A：构造一个从A到B的ICMP Echo Request，其中dst mac = R1相应接口地址；发送三次（ICMP序列号每次增加1）；</span><br><span class="line">A：Wireshark查看是否收到了ICMP REDIRECT包</span><br><span class="line">A：route print （查看是否多了一条去往B的路由）</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>
<p>发了三次，会产生三次重定向。打开Redirect 的 ICMP 包找到 gateway 是新的重定向网关，同时有附录原始报文。</p>
</li>
<li>
<p>在 route print 也可以看到多一条记录。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>重定向：实验3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目的：理解重定向包在什么情况下发送（重定向网关必须和源主机处于同一网路）</span><br><span class="line">设置：A=192.168.140.11  B=192.168.134.11  C=192.168.138.11</span><br><span class="line"></span><br><span class="line">A，C：ROUTE PRINT（如果有去往B的路径，删除它）</span><br><span class="line">A, B, C：打开Wireshark，filter:ICMP</span><br><span class="line">R1：查看通往B的路由是否通过R3</span><br><span class="line">A：将前一个实验构造的包中的src ip改为 192.168.138.11；发送三次构造的包 ；</span><br><span class="line">A，C：Wireshark查看是否收到了ICMP REDIRECT包（没有发生重定向）</span><br><span class="line">A，C：route print （查看是否多了一条去往B的路由）</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>重定向：实验4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目的：理解重定向包在什么情况下发送（重定向网关必须和源主机处于同一网路）</span><br><span class="line">设置：A=192.168.140.11 B=192.168.134.11 C=192.168.140.15</span><br><span class="line"></span><br><span class="line">A，C：ROUTE PRINT（如果有去往B的路径，删除它）</span><br><span class="line">A, B, C：打开Wireshark，filter:ICMP</span><br><span class="line">R1：查看通往B的路由是否通过R3</span><br><span class="line">A：将前一个实验构造的包中的src ip改为192.168.140.15；发送三次构造的包；</span><br><span class="line">C：Wireshark查看是否收到了ICMP REDIRECT包</span><br><span class="line">C：route print （查看是否多了一条去往B的路由）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会产生重定向，多一条路由</p>
</blockquote>
</li>
<li>
<p><strong>重定向：实验5</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">目的：理解主机在什么情况下被重定向(主机去往相应目的地的下一跳必须是重定包发送者)</span><br><span class="line">设置：A=192.168.140.11 B=192.168.134.11 C=192.168.140.15</span><br><span class="line"></span><br><span class="line">A，C：ROUTE PRINT</span><br><span class="line">A, B, C：打开Wireshark，filter:ICMP</span><br><span class="line">C: 将默认的网关设置为192.168.140.33</span><br><span class="line">R1：查看通往B的路由是否通过R3</span><br><span class="line">A：将前一个实验构造的包中的src ip依旧设置为192.168.140.15；发送三次构造的包；</span><br><span class="line">C：Wireshark查看是否收到了ICMP REDIRECT包</span><br><span class="line">C：route print （查看是否多了一条去往B的路由），重定向没有发生作用（由于C的去往B的下一跳不是R1）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会收到重定向包，但是主机并不响应。</p>
</blockquote>
</li>
<li>
<p><strong>重定向：实验6</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目的：攻击同一网络内主机</span><br><span class="line">设置：A（192.168.140.11）攻击同一网络内主机C（192.168.140.15），假设R1为C去往Z（192.168.136.11）的原始网关(伪造的网关为 R3=192.168.140.99)</span><br><span class="line"></span><br><span class="line">C：route print（确定去往Z的原始路径）</span><br><span class="line">C: ping -r 8 Z</span><br><span class="line">A：构建一个ICMP Redirect包（可以用Wireshark 捕获的包为基础修改)</span><br><span class="line">C：route print（增加了一条去往Z的路径）</span><br><span class="line">C: ping -r 8 Z （比较和前一次PING的结果）</span><br></pre></td></tr></table></figure>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-17.png" alt="P10-17" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-18.png" alt="P10-18" style="zoom:60%;" /> 
</blockquote>
</li>
<li>
<p><strong>重定向(RouterOS)：实验7</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目的：攻击一台RouterOS</span><br><span class="line">设置：routeos也接收重定向，不过需要将accept-redirects打开</span><br><span class="line"></span><br><span class="line">R1:ip/settings/accept-redirects = yes</span><br><span class="line">R1：system/reboot</span><br><span class="line">发送一个欺骗包，使得去往192.168.134.11的下一跳改为192.168.140.33</span><br><span class="line">/ping 192.168.134.11 无法PING通，WIRESHARK可以</span><br><span class="line">看到R1的ARP 请求，请求192.168.140.33的MAC地址</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的：140.100的MAC</span><br><span class="line"></span><br><span class="line">IP层</span><br><span class="line">源：192.168.140.99</span><br><span class="line">目：192.168.140.100</span><br><span class="line"></span><br><span class="line">ICMP层</span><br><span class="line">附IPv4</span><br><span class="line">源：192.168.140.100</span><br><span class="line">目：192.168.134.11</span><br></pre></td></tr></table></figure>
<p>注意，成功欺骗，也可能在 route p 看不到（路由器的缓存看不到）。</p>
<p>但是，可以通过 ping 不通，知道成功欺骗。</p>
<p><code>路由器 ping 192.168.134.11</code> 会出现 <code>timeout</code> ，</p>
<p>同时在同网段的wireshark 可以看到有ARP请求 <code>Who has 192.168.140.33? Tell 192.168.140.100</code> 。</p>
</blockquote>
</li>
</ul>
<h4 id="6-1-Lab-重定向">6.1 Lab 重定向</h4>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-1.png" alt="P10-1" style="zoom:60%;" /> 
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P10-2.png" alt="P10-2" style="zoom:60%;" /> 
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/P2-8.png" alt="P2-8" style="zoom:60%;" /> 
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAC层</span><br><span class="line">目的：142.100的MAC</span><br><span class="line">源：142.11的MAC</span><br><span class="line"></span><br><span class="line">IP层</span><br><span class="line">源：192.168.136.100（R2）</span><br><span class="line">目的：192.168.136.11（受害者）</span><br><span class="line"></span><br><span class="line">Type: 5 Redirect</span><br><span class="line">Code: 1 </span><br><span class="line">Gateway Internet Address: 192.168.136.99（R4）</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://isSeymour.github.io/butterflyblog">isSeymour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://isseymour.github.io/butterflyblog/2024/05/09/ISP-Lab/">https://isseymour.github.io/butterflyblog/2024/05/09/ISP-Lab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://isSeymour.github.io/butterflyblog" target="_blank">isSeymour</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/butterflyblog/tags/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/">计网实验</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/Page0.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/butterflyblog/2024/05/01/Crypto-Graphic/" title="《图解密码技术》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/Crypto-Graphic/P0.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《图解密码技术》Notes</div></div></a></div><div class="next-post pull-right"><a href="/butterflyblog/2024/05/12/WP-TJ2024/" title="同济@复旦第一届网络安全竞赛WP"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/WP-TJ2024/Page0.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">同济@复旦第一届网络安全竞赛WP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/butterflyblog/2023/08/12/Cisco-ComputerNetworks-Easy/" title="《Cisco计网实验》速查助记"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-12</div><div class="title">《Cisco计网实验》速查助记</div></div></a></div><div><a href="/butterflyblog/2023/08/11/Cisco-ComputerNetworks/" title="《Cisco计网实验》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-11</div><div class="title">《Cisco计网实验》Notes</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">isSeymour</div><div class="author-info__description">志之所趋，无远弗届，穷山距海，不能限也。</div></div><div class="card-info-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/isSeymour/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://isSeymour.github.io/profile/" target="_blank" title="学术主页"><i class="fa-regular fa-address-card" style="color: #000000;"></i></a><a class="social-icon" href="https://github.com/isSeymour/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/79699613/" target="_blank" title="B站"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_63205991/" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #000000;"></i></a><a class="social-icon" href="mailto:isSeymour@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">《信息安全工程》实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%86%85%E5%AE%B9"><span class="toc-text">前置内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85XP"><span class="toc-text">安装XP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%AE%B5"><span class="toc-text">网段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%AE%B5%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">网段连接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E6%A8%A1%E5%BC%8F"><span class="toc-text">NAT模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E4%B8%BB%E6%9C%BA%E6%A8%A1%E5%BC%8F-Host-only"><span class="toc-text">仅主机模式 Host-only</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LAN%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%89"><span class="toc-text">LAN模式（局域网）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E9%85%8D%E7%BD%AE%E5%A4%87%E6%B3%A8"><span class="toc-text">我的配置备注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%AE%9E%E9%AA%8C"><span class="toc-text">开始实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E6%9E%84%E5%BB%BA"><span class="toc-text">1 网络构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AEHTTP-FTP%E6%9C%8D%E5%8A%A1"><span class="toc-text">2 配置HTTP&#x2F;FTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ARP-%E6%AC%BA%E9%AA%97"><span class="toc-text">3 ARP 欺骗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-text">3.0 理论知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP"><span class="toc-text">ARP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86ARP"><span class="toc-text">代理ARP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8D%E8%B4%B9ARP"><span class="toc-text">免费ARP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E6%AC%BA%E9%AA%97"><span class="toc-text">ARP欺骗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Lab-%E6%AC%BA%E9%AA%97%E4%B8%BB%E6%9C%BA"><span class="toc-text">3.1 Lab 欺骗主机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Lab-%E6%AC%BA%E9%AA%97%E7%BD%91%E5%85%B3"><span class="toc-text">3.2 Lab 欺骗网关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Lab-%E5%BA%94%E7%AD%94%E6%AC%BA%E9%AA%97"><span class="toc-text">3.3 Lab 应答欺骗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1%E8%AE%B0%E5%BD%95"><span class="toc-text">4 路由记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-0-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-text">4.0 理论知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E9%80%89%E9%A1%B9"><span class="toc-text">IP选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Lab-%E6%9E%84%E5%BB%BA-ping-%E5%8C%85%E8%AE%B0%E5%BD%95"><span class="toc-text">4.1 Lab 构建 ping 包记录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%A5%E6%A0%BC%E6%BA%90%E8%B7%AF%E7%94%B1"><span class="toc-text">5 严格源路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-0-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-text">5.0 理论知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Lab-%E4%B8%A5%E6%A0%BC%E6%BA%90%E8%B7%AF%E7%94%B1"><span class="toc-text">5.1 Lab 严格源路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ICMP-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">6 ICMP 重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-text">6.0 理论知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-0-1-%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%871-%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%BE%BE"><span class="toc-text">6.0.1 差错报文1-目的不可达</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-0-2-%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%872-%E8%B6%85%E6%97%B6"><span class="toc-text">6.0.2 差错报文2-超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-0-3-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87"><span class="toc-text">6.0.3 重定向报文</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-Lab-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">6.1 Lab 重定向</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/10/14/CS224W_Colab_2/" title="CS224W - Colab 2"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/CS224W/GCN/shared-parameters.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="CS224W - Colab 2"/></a><div class="content"><a class="title" href="/butterflyblog/2024/10/14/CS224W_Colab_2/" title="CS224W - Colab 2">CS224W - Colab 2</a><time datetime="2024-10-14T14:00:00.000Z" title="发表于 2024-10-14 22:00:00">2024-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/10/14/GCN/" title="GCN 图卷积神经网络"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/CS224W/GCN/DeepGraphEncoders.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="GCN 图卷积神经网络"/></a><div class="content"><a class="title" href="/butterflyblog/2024/10/14/GCN/" title="GCN 图卷积神经网络">GCN 图卷积神经网络</a><time datetime="2024-10-14T09:00:00.000Z" title="发表于 2024-10-14 17:00:00">2024-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2024/10/12/Graph-PageRank/" title="PageRank:《哈利·波特》人物节点重要度"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/CS224W/PageRank/Algorithm.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="PageRank:《哈利·波特》人物节点重要度"/></a><div class="content"><a class="title" href="/butterflyblog/2024/10/12/Graph-PageRank/" title="PageRank:《哈利·波特》人物节点重要度">PageRank:《哈利·波特》人物节点重要度</a><time datetime="2024-10-12T14:00:00.000Z" title="发表于 2024-10-12 22:00:00">2024-10-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/ISP-Lab/Page0.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By isSeymour</div><div class="footer_custom_text">欢迎乘坐我的生活地铁！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/butterflyblog/js/utils.js"></script><script src="/butterflyblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liAZxomGv7Hapw8g',
      clientSecret: 'f7cafde192c4ada8bef4b76952c422d90575cf8b',
      repo: 'gitalk',
      owner: 'isSeymour',
      admin: ['isSeymour'],
      id: '990b3774d09da2c6dba19f08c1257875',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/butterflyblog/js/search/local-search.js"></script></div></div></body></html>