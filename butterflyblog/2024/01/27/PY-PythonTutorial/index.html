<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Python Tutorial》Notes | isSeymour</title><meta name="author" content="isSeymour"><meta name="copyright" content="isSeymour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《Python Tutorial》Notes  Source From: Python Tutorial 2024-01-27@isSeymour  1. 课前甜点 Python 程序简洁、易读，通常比实现同种功能的 C、C++、Java 代码短很多，原因如下：  高级数据类型允许在单一语句中表述复杂操作； 使用缩进，而不是括号实现代码块分组； 无需预声明变量或参数。  Python “可以扩展”">
<meta property="og:type" content="article">
<meta property="og:title" content="《Python Tutorial》Notes">
<meta property="og:url" content="https://isseymour.github.io/butterflyblog/2024/01/27/PY-PythonTutorial/index.html">
<meta property="og:site_name" content="isSeymour">
<meta property="og:description" content="《Python Tutorial》Notes  Source From: Python Tutorial 2024-01-27@isSeymour  1. 课前甜点 Python 程序简洁、易读，通常比实现同种功能的 C、C++、Java 代码短很多，原因如下：  高级数据类型允许在单一语句中表述复杂操作； 使用缩进，而不是括号实现代码块分组； 无需预声明变量或参数。  Python “可以扩展”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/pythontutorial/pythonturorial.png">
<meta property="article:published_time" content="2024-01-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-28T16:00:00.000Z">
<meta property="article:author" content="isSeymour">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/pythontutorial/pythonturorial.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/IC1011.ico"><link rel="canonical" href="https://isseymour.github.io/butterflyblog/2024/01/27/PY-PythonTutorial/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/butterflyblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/butterflyblog/',
  algolia: undefined,
  localSearch: {"path":"/butterflyblog/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Python Tutorial》Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-29 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/butterflyblog/code/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/labuladong/"><i class="fa-fw fa-solid fa-coffee"></i><span> labuladong</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/luogu/"><i class="fa-fw fa-solid fa-magnet"></i><span> 洛谷</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/RecSys/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> RecSys</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/pythontutorial/pythonturorial.png')"><nav id="nav"><span id="blog-info"><a href="/butterflyblog/" title="isSeymour"><span class="site-name">isSeymour</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> 总览</span></a></li><li><a class="site-page child" href="/butterflyblog/tags/"><i class="fa-fw fa-sharp fa-solid fa-hashtag"></i><span> 标签</span></a></li><li><a class="site-page child" href="/butterflyblog/categories/"><i class="fa-fw fa-sharp fa-solid fa-folder"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-list"></i><span> 功能</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/ctf/"><i class="fa-fw fa-solid fa-shield-halved"></i><span> CTF</span></a></li><li><a class="site-page child" href="/butterflyblog/music/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/butterflyblog/tools/"><i class="fa-fw fa-solid fa-screwdriver-wrench"></i><span> 下载</span></a></li><li><a class="site-page child" href="/butterflyblog/link/"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-university"></i><span> 算法</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/algorithm/hot100/"><i class="fa-fw fa-solid fa-fire"></i><span> HOT100</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/labuladong/"><i class="fa-fw fa-solid fa-coffee"></i><span> labuladong</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/luogu/"><i class="fa-fw fa-solid fa-magnet"></i><span> 洛谷</span></a></li><li><a class="site-page child" href="/butterflyblog/algorithm/template/"><i class="fa-fw fa-solid fa-code"></i><span> Template</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-solid fa-plane"></i><span> 旅途</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/journey/english/"><i class="fa-fw fa-solid fa-globe"></i><span> 英语</span></a></li><li><a class="site-page child" href="/butterflyblog/journey/RecSys/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> RecSys</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-user"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/butterflyblog/about/"><i class="fa-fw fa-regular fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/butterflyblog/message/"><i class="fa-fw fa-solid fa-message"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/butterflyblog/develop/"><i class="fa-fw fa-brands fa-windows"></i><span> 开发日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Python Tutorial》Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-26T16:00:00.000Z" title="发表于 2024-01-27 00:00:00">2024-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-28T16:00:00.000Z" title="更新于 2024-01-29 00:00:00">2024-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/butterflyblog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">53.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>207分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Python Tutorial》Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>《Python Tutorial》Notes</h1>
<blockquote>
<p>Source From: <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/">Python Tutorial</a></p>
<p>2024-01-27@isSeymour</p>
</blockquote>
<h1>1. 课前甜点</h1>
<p>Python 程序简洁、易读，通常比实现同种功能的 C、C++、Java 代码短很多，原因如下：</p>
<ul>
<li>高级数据类型允许在单一语句中表述复杂操作；</li>
<li>使用缩进，而不是括号实现代码块分组；</li>
<li>无需预声明变量或参数。</li>
</ul>
<p>Python “可以扩展”：会开发 C 语言程序，就能快速上手为解释器增加新的内置函数或模块，不论是让核心程序以最高速度运行，还是把 Python 程序链接到只提供预编译程序的库（比如，硬件图形库）。只要下点功夫，就能把 Python 解释器和用 C 开发的应用链接在一起，用它来扩展和控制该应用。</p>
<h1>2. Python 解释器</h1>
<h2 id="2-1-调用解释器">2.1. 调用解释器</h2>
<h4 id="启动">启动</h4>
<p>Python 解释器在可用的机器上通常被安装为 <code>/usr/local/bin/python3.11</code>；</p>
<p>将 <code>/usr/local/bin</code> 加入你的 Unix shell 的搜索路径就可以通过输入以下命令来启动它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3.11</span><br><span class="line">python</span><br><span class="line">py</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Unix 系统中，为了不与同时安装的 Python 2.x 冲突，Python 3.x 解释器默认安装的执行文件名不是 <code>python</code>。</p>
<p><code>py</code>需要安装了<code>py.exe</code>。</p>
<p>这样，就可以在 shell 中运行 Python 了 。因为可以选择安装目录，解释器也有可能安装在别的位置；如果还不明白，就去问问身边的 Python 大神或系统管理员。（例如，常见备选路径还有 <code>/usr/local/python</code>。）</p>
</blockquote>
<h4 id="退出">退出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z）</span><br><span class="line">quit()</span><br></pre></td></tr></table></figure>
<h4 id="使用">使用</h4>
<p>解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 <em>脚本</em>。</p>
<p>另一种启动解释器的方式是 <code>python -c command [arg] ...</code>，这将执行 <em>command</em> 中的语句，相当于 shell 的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-c"><code>-c</code></a> 选项。 由于 Python 语句经常包含空格或其他会被 shell 特殊对待的字符，通常建议用引号将整个 <em>command</em> 括起来。</p>
<p>Python 模块也可以当作脚本使用。输入：<code>python -m module [arg] ...</code>，会执行 <em>module</em> 的源文件，这跟在命令行把路径写全了一样。</p>
<p>在交互模式下运行脚本文件，只要在脚本名称参数前，加上选项 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-i"><code>-i</code></a> 就可以了。</p>
<p>命令行的所有选项详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#using-on-general">命令行与环境</a>。</p>
<h3 id="2-1-1-传入参数">2.1.1. 传入参数</h3>
<p>解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 <code>sys</code> 模块的 <code>argv</code> 变量里。执行 <code>import sys</code>，可以导入这个模块，并访问该列表。该列表最少有一个元素；未给定输入参数时，<code>sys.argv[0]</code> 是空字符串。给定脚本名是 <code>'-'</code> （标准输入）时，<code>sys.argv[0]</code> 是 <code>'-'</code>。使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-c"><code>-c</code></a> <em>command</em> 时，<code>sys.argv[0]</code> 是 <code>'-c'</code>。如果使用选项 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-m"><code>-m</code></a> <em>module</em>，<code>sys.argv[0]</code> 就是包含目录的模块全名。解释器不处理 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-c"><code>-c</code></a> <em>command</em> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-m"><code>-m</code></a> <em>module</em> 之后的选项，而是直接留在 <code>sys.argv</code> 中由命令或模块来处理。</p>
<h3 id="2-1-2-交互模式">2.1.2. 交互模式</h3>
<p>在终端（tty）输入并执行指令时，解释器在 <em>交互模式（interactive mode）</em> 中运行。在这种模式中，会显示 <em>主提示符</em>，提示输入下一条指令，主提示符通常用三个大于号（<code>&gt;&gt;&gt;</code>）表示；输入连续行时，显示 <em>次要提示符</em>，默认是三个点（<code>...</code>）。进入解释器时，首先显示欢迎信息、版本信息、版权声明，然后才是提示符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3<span class="number">.11</span></span><br><span class="line">Python <span class="number">3.11</span> (default, April <span class="number">4</span> <span class="number">2021</span>, 09:<span class="number">25</span>:04)</span><br><span class="line">[GCC <span class="number">10.2</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>输入多行架构的语句时，要用连续行。以 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#if"><code>if</code></a> 为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>the_world_is_flat = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> the_world_is_flat:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Be careful not to fall off!&quot;</span>)</span><br><span class="line">...</span><br><span class="line">Be careful <span class="keyword">not</span> to fall off!</span><br></pre></td></tr></table></figure>
<p>交互模式的内容详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/appendix.html#tut-interac">交互模式</a>。</p>
<h2 id="2-2-解释器的运行环境">2.2. 解释器的运行环境</h2>
<h3 id="2-2-1-源文件的字符编码">2.2.1. 源文件的字符编码</h3>
<p>默认情况下，Python 源码文件的编码是 UTF-8。这种编码支持世界上大多数语言的字符，可以用于字符串字面值、变量、函数名及注释 —— 尽管标准库只用常规的 ASCII 字符作为变量名或函数名，可移植代码都应遵守此约定。要正确显示这些字符，编辑器必须能识别 UTF-8 编码，而且必须使用支持文件中所有字符的字体。</p>
<p>如果不使用默认编码，则要声明文件的编码，文件的 <em>第一</em> 行要写成特殊注释。句法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: encoding -*-</span></span><br></pre></td></tr></table></figure>
<p>其中，<em>encoding</em> 可以是 Python 支持的任意一种 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/codecs.html#module-codecs"><code>codecs</code></a>。</p>
<p>比如，声明使用 Windows-1252 编码，源码文件要写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp1252 -*-</span></span><br></pre></td></tr></table></figure>
<p><em>第一行</em> 的规则也有一种例外情况，源码以 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/appendix.html#tut-scripts">UNIX “shebang” 行</a> 开头。此时，编码声明要写在文件的第二行。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: cp1252 -*-</span></span><br></pre></td></tr></table></figure>
<h1>3. Python 速览</h1>
<p>本手册中的许多例子，甚至交互式命令都包含注释。Python 注释以 <code>#</code> 开头，直到该物理行结束。注释可以在行开头，或空白符与代码之后，但不能在字符串里面。字符串中的 # 号就是 # 号。注释用于阐明代码，Python 不解释注释，键入例子时，可以不输入注释。</p>
<h2 id="3-1-Python-用作计算器">3.1. Python 用作计算器</h2>
<h3 id="3-1-1-数字">3.1.1. 数字</h3>
<p>解释器像一个简单的计算器：你可以输入一个表达式，它将给出结果值。 表达式语法很直观：运算符 <code>+</code>, <code>-</code>, <code>*</code> 和 <code>/</code> 可被用来执行算术运算；圆括号 (<code>()</code>) 可被用来进行分组。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> / <span class="number">5</span>  <span class="comment"># division always returns a floating point number</span></span><br><span class="line"><span class="number">1.6</span></span><br></pre></td></tr></table></figure>
<p>整数（如，<code>2</code>、<code>4</code>、<code>20</code> ）的类型是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#int"><code>int</code></a>，带小数（如，<code>5.0</code>、<code>1.6</code> ）的类型是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#float"><code>float</code></a>。本教程后半部分将介绍更多数字类型。</p>
<p>除法运算 (<code>/</code>) 总是返回浮点数。 如果要做 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-floor-division">floor division</a> 得到一个整数结果你可以使用 <code>//</code> 运算符；要计算余数你可以使用 <code>%</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># classic division returns a float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># floor division discards the fractional part</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># the % operator returns the remainder of the division</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="number">3</span> + <span class="number">2</span>  <span class="comment"># floored quotient * divisor + remainder</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>Python 用 <code>**</code> 运算符计算乘方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5 squared</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">7</span>  <span class="comment"># 2 to the power of 7</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>**</code> 比 <code>-</code> 的优先级更高, 所以 <code>-3**2</code> 会被解释成 <code>-(3**2)</code> ，因此，结果是 <code>-9</code>。要避免这个问题，并且得到 <code>9</code>, 可以用 <code>(-3)**2</code>。</p>
</blockquote>
<p>等号（<code>=</code>）用于给变量赋值。赋值后，下一个交互提示符的位置不显示任何结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>width = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height = <span class="number">5</span> * <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width * height</span><br><span class="line"><span class="number">900</span></span><br></pre></td></tr></table></figure>
<p>如果变量未定义（即，未赋值），使用该变量会提示错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n  <span class="comment"># try to access an undefined variable</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;n&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>Python 全面支持浮点数；混合类型运算数的运算会把整数转换为浮点数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> * <span class="number">3.75</span> - <span class="number">1</span></span><br><span class="line"><span class="number">14.0</span></span><br></pre></td></tr></table></figure>
<p>交互模式下，上次输出的表达式会赋给变量 <code>_</code>。</p>
<p>把 Python 当作计算器时，用该变量实现下一步计算更简单，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tax = <span class="number">12.5</span> / <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price = <span class="number">100.50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price * tax</span><br><span class="line"><span class="number">12.5625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price + _</span><br><span class="line"><span class="number">113.0625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(_, <span class="number">2</span>)</span><br><span class="line"><span class="number">113.06</span></span><br></pre></td></tr></table></figure>
<p>最好把该变量当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用它的魔法行为屏蔽内置变量。</p>
<p>除了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#int"><code>int</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#float"><code>float</code></a>，Python 还支持其他数字类型，例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/fractions.html#fractions.Fraction"><code>Fraction</code></a>。Python 还内置支持 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesnumeric">复数</a>，后缀 <code>j</code> 或 <code>J</code> 用于表示虚数（例如 <code>3+5j</code> ）。</p>
<h3 id="3-1-2-文本">3.1.2. 文本</h3>
<p>除了数字 Python 还可以操作文本（由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str"><code>str</code></a> 类型表示，称为“字符串”）。 这包括字符 “<code>!</code>”, 单词 “<code>rabbit</code>”, 名称 “<code>Paris</code>”, 句子 “<code>Got your back.</code>” 等等. “<code>Yay! :)</code>”。 它们可以用成对的单引号 (<code>'...'</code>) 或双引号 (<code>&quot;...&quot;</code>) 来标示，结果完全相同 。</p>
<blockquote>
<p>与其他语言不同，特殊字符如 <code>\n</code> 在单引号（<code>'...'</code> ）和双引号（<code>&quot;...&quot;</code> ）里的意义一样。这两种引号唯一的区别是，不需要在单引号里转义双引号 <code>&quot;</code> （但此时必须把单引号转义成 <code>\'</code> ），反之亦然。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;spam eggs&#x27;</span>  <span class="comment"># single quotes</span></span><br><span class="line"><span class="string">&#x27;spam eggs&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Paris rabbit got your back :)! Yay!&quot;</span>  <span class="comment"># double quotes</span></span><br><span class="line"><span class="string">&#x27;Paris rabbit got your back :)! Yay!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;1975&#x27;</span>  <span class="comment"># digits and numerals enclosed in quotes are also strings</span></span><br><span class="line"><span class="string">&#x27;1975&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要标示引号本身，我们需要对它进行“转义”，即在前面加一个 <code>\</code>。 或者，我们也可以使用不同类型的引号:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;doesn\&#x27;t&#x27;</span>  <span class="comment"># use \&#x27; to escape the single quote...</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;doesn&#x27;t&quot;</span>  <span class="comment"># ...or use double quotes instead</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;\&quot;Yes,\&quot; they said.&quot;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在 Python shell 中，字符串定义和输出字符串看起来可能不同。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#print"><code>print()</code></a> 函数会略去标示用的引号，并打印经过转义的特殊字符，产生更为易读的输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;First line.\nSecond line.&#x27;</span>  <span class="comment"># \n means newline</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  <span class="comment"># without print(), special characters are included in the string</span></span><br><span class="line"><span class="string">&#x27;First line.\nSecond line.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)  <span class="comment"># with print(), special characters are interpreted, so \n produces new line</span></span><br><span class="line">First line.</span><br><span class="line">Second line.</span><br></pre></td></tr></table></figure>
<p>如果不希望前置 <code>\</code> 的字符转义成特殊字符，可以使用 <em>原始字符串</em>，在引号前添加 <code>r</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;C:\some\name&#x27;</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\some\name&#x27;</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure>
<p>原始字符串还有一个微妙的限制：一个原始字符串不能以奇数个 <code>\</code> 字符结束；请参阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/faq/programming.html#faq-programming-raw-string-backslash">此 FAQ 条目</a> 了解更多信息及绕过的办法。</p>
<p>字符串字面值可以包含多行。 一种实现方式是使用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>'''...'''</code>。 字符串中将自动包括行结束符，但也可以在换行的地方添加一个 <code>\</code> 来避免此情况。 参见以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">     -h                        Display this usage message</span></span><br><span class="line"><span class="string">     -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出如下（请注意开始的换行符没有被包括在内）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br></pre></td></tr></table></figure>
<p>字符串可以用 <code>+</code> 合并（粘到一起），也可以用 <code>*</code> 重复：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times &#x27;un&#x27;, followed by &#x27;ium&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;unununium&#x27;</span></span><br></pre></td></tr></table></figure>
<p>相邻的两个或多个 <em>字符串字面值</em> （引号标注的字符）会自动合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Py&#x27;</span> <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>
<p>拼接分隔开的长字符串时，这个功能特别实用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;Put several strings within parentheses &#x27;</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;to have them joined together.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;Put several strings within parentheses to have them joined together.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这项功能只能用于两个字面值，不能用于变量或表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix = <span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix <span class="string">&#x27;thon&#x27;</span>  <span class="comment"># can&#x27;t concatenate a variable and a string literal</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    prefix <span class="string">&#x27;thon&#x27;</span></span><br><span class="line">           ^^^^^^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    (<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">               ^^^^^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>合并多个变量，或合并变量与字面值，要用 <code>+</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix + <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字符串支持 <em>索引</em> （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>索引还支持负数，用负数索引时，从右边开始计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">6</span>]</span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，-0 和 0 一样，因此，负数索引从 -1 开始。</p>
<p>除了索引之外，还支持切片。索引用于获取单个字符，切片允许您获取子字符串:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">&#x27;tho&#x27;</span></span><br></pre></td></tr></table></figure>
<p>切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]   <span class="comment"># character from the beginning to position 2 (excluded)</span></span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:]   <span class="comment"># characters from position 4 (included) to the end</span></span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>:]  <span class="comment"># characters from the second-last (included) to the end</span></span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，输出结果包含切片开始，但不包含切片结束。因此，<code>s[:i] + s[i:]</code> 总是等于 <code>s</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">4</span>] + word[<span class="number">4</span>:]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还可以这样理解切片，索引指向的是字符 <em>之间</em> ，第一个字符的左侧标为 0，最后一个字符的右侧标为 <em>n</em> ，<em>n</em> 是字符串长度。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> | P | y | t | h | o | n |</span><br><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">-<span class="number">6</span>  -<span class="number">5</span>  -<span class="number">4</span>  -<span class="number">3</span>  -<span class="number">2</span>  -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>第一行数字是字符串中索引 0…6 的位置，第二行数字是对应的负数索引位置。<em>i</em> 到 <em>j</em> 的切片由 <em>i</em> 和 <em>j</em> 之间所有对应的字符组成。</p>
<p>对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如， <code>word[1:3]</code> 的长度是 2。</p>
<p>索引越界会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>]  <span class="comment"># the word only has 6 characters</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>
<p>但是，切片会自动处理越界索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>:]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Python 字符串不能修改，是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-immutable">immutable</a> 的。因此，为字符串中某个索引位置赋值会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:] = <span class="string">&#x27;py&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>要生成不同的字符串，应新建一个字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;J&#x27;</span> + word[<span class="number">1</span>:]</span><br><span class="line"><span class="string">&#x27;Jython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + <span class="string">&#x27;py&#x27;</span></span><br><span class="line"><span class="string">&#x27;Pypy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>内置函数 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#len"><code>len()</code></a> 返回字符串的长度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;supercalifragilisticexpialidocious&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>参见</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#textseq">文本序列类型 — str</a></p>
<p>字符串是 <em>序列类型</em> ，支持序列类型的各种操作。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#string-methods">字符串的方法</a></p>
<p>字符串支持很多变形与查找方法。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/lexical_analysis.html#f-strings">f 字符串</a></p>
<p>内嵌表达式的字符串字面值。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/string.html#formatstrings">格式字符串语法</a></p>
<p>使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str.format"><code>str.format()</code></a> 格式化字符串。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#old-string-formatting">printf 风格的字符串格式化</a></p>
<p>这里详述了用 <code>%</code> 运算符格式化字符串的操作。</p>
</li>
</ul>
<h3 id="3-1-3-列表">3.1.3. 列表</h3>
<p>Python 支持多种 <em>复合</em> 数据类型，可将不同值组合在一起。最常用的 <em>列表</em> ，是用方括号标注，逗号分隔的一组值。</p>
<p><em>列表</em> 可以包含不同类型的元素，但一般情况下，各个元素的类型相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>和字符串（及其他内置 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-sequence">sequence</a> 类型）一样，列表也支持索引和切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">0</span>]  <span class="comment"># indexing returns the item</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[-<span class="number">1</span>]</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[-<span class="number">3</span>:]  <span class="comment"># slicing returns a new list</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>切片操作返回包含请求元素的新列表。以下切片操作会返回列表的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/copy.html#shallow-vs-deep-copy">浅拷贝</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>列表还支持合并操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-immutable">immutable</a> 字符串不同, 列表是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-mutable">mutable</a> 类型，其内容可以改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">65</span>, <span class="number">125</span>]  <span class="comment"># something&#x27;s wrong here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> ** <span class="number">3</span>  <span class="comment"># the cube of 4 is 64, not 65!</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes[<span class="number">3</span>] = <span class="number">64</span>  <span class="comment"># replace the wrong value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>]</span><br></pre></td></tr></table></figure>
<p>你也可以在通过使用 <code>list.append()</code> <em>方法</em>，在列表末尾添加新条目（我们将在后面介绍更多相关的方法）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">216</span>)  <span class="comment"># add the cube of 6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">7</span> ** <span class="number">3</span>)  <span class="comment"># and the cube of 7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>]</span><br></pre></td></tr></table></figure>
<p>为切片赋值可以改变列表大小，甚至清空整个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># replace some values</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># now remove them</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># clear the list by replacing all the elements with an empty list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>内置函数 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#len"><code>len()</code></a> 也支持列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(letters)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>还可以嵌套列表（创建包含其他列表的列表），例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-走向编程的第一步">3.2. 走向编程的第一步</h2>
<p>当然，我们还能用 Python 完成比二加二更复杂的任务。 例如，我们可以像下面这样写出 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fibonacci_sequence">斐波那契数列</a> 初始部分的子序列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Fibonacci series:</span></span><br><span class="line"><span class="meta">... </span><span class="comment"># the sum of two elements defines the next</span></span><br><span class="line"><span class="meta">... </span>a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> a &lt; <span class="number">10</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span>    a, b = b, a+b</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>本例引入了几个新功能。</p>
<ul>
<li>
<p>第一行中的 <em>多重赋值</em> ：变量 <code>a</code> 和 <code>b</code> 同时获得新值 0 和 1 。最后一行又用了一次多重赋值，体现了，等号右边的所有表达式的值，都是在这一语句对任何变量赋新值之前求出来的——求值顺序为从左到右。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#while"><code>while</code></a> 循环只要条件（这里是 <code>a &lt; 10</code>）为真就会一直执行。Python 和 C 一样，任何非零整数都为真，零为假。这个条件也可以是字符串或列表类型的值，事实上，任何序列都可以：长度非零就为真，空序列则为假。示例中的判断只是最简单的比较。比较操作符的写法和 C 语言一样： <code>&lt;</code> （小于）、 <code>&gt;</code> （大于）、 <code>==</code> （等于）、 <code>&lt;=</code> （小于等于)、 <code>&gt;=</code> （大于等于）及 <code>!=</code> （不等于）。</p>
</li>
<li>
<p><em>循环体</em> 是 <em>缩进的</em> ：缩进是 Python 组织语句的方式。在交互式命令行里，得为每个缩进的行输入空格（或制表符）。使用文本编辑器可以实现更复杂的输入方式；所有像样的文本编辑器都支持自动缩进。交互式输入复合语句时，要在最后输入空白行表示完成（因为解析器不知道哪一行代码是代码块的最后一行）。注意，同一块语句的每一行的缩进相同。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#print"><code>print()</code></a> 函数输出给定参数的值。除了可以以单一的表达式作为参数（比如，前面的计算器的例子），它还能处理多个参数，包括浮点数与字符串。它输出的字符串不带引号，且各参数项之间会插入一个空格，这样可以实现更好的格式化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">256</span>*<span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The value of i is&#x27;</span>, i)</span><br><span class="line">The value of i <span class="keyword">is</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>关键字参数 <em>end</em> 可以取消输出后面的换行, 或用另一个字符串结尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> a &lt; <span class="number">1000</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    a, b = b, a+b</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>4. 更多控制流工具</h1>
<p>除了刚介绍的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#while"><code>while</code></a> 语句，Python 还用了一些别的。我们将在本章中遇到它们。</p>
<h2 id="4-1-if-语句">4.1. <code>if</code> 语句</h2>
<p>最让人耳熟能详的语句应当是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#if"><code>if</code></a> 语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please enter an integer: &quot;</span>))</span><br><span class="line">Please enter an integer: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Negative changed to zero&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Zero&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Single&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;More&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">More</span><br></pre></td></tr></table></figure>
<p>可有零个或多个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#elif"><code>elif</code></a> 部分，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#else"><code>else</code></a> 部分也是可选的。关键字 ‘<code>elif</code>’ 是 ‘else if’ 的缩写，用于避免过多的缩进。<code>if</code> … <code>elif</code> … <code>elif</code> … 序列可以当作其它语言中 <code>switch</code> 或 <code>case</code> 语句的替代品。</p>
<p>如果是把一个值与多个常量进行比较，或者检查特定类型或属性，<code>match</code> 语句更有用。详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/controlflow.html#tut-match">match 语句</a>。</p>
<h2 id="4-2-for-语句">4.2. <code>for</code> 语句</h2>
<p>Python 的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 语句与 C 或 Pascal 中的不同。Python 的 <code>for</code> 语句不迭代算术递增数值（如 Pascal），或是给予用户定义迭代步骤和结束条件的能力（如 C），而是在列表或字符串等任意序列的元素上迭代，按它们在序列中出现的顺序。 例如（这不是有意要暗指什么）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Measure some strings:</span></span><br><span class="line"><span class="meta">... </span>words = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="string">&#x27;defenestrate&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(w, <span class="built_in">len</span>(w))</span><br><span class="line">...</span><br><span class="line">cat <span class="number">3</span></span><br><span class="line">window <span class="number">6</span></span><br><span class="line">defenestrate <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>很难正确地在迭代多项集的同时修改多项集的内容。更简单的方法是迭代多项集的副本或者创建新的多项集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a sample collection</span></span><br><span class="line">users = &#123;<span class="string">&#x27;Hans&#x27;</span>: <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;Éléonore&#x27;</span>: <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;景太郎&#x27;</span>: <span class="string">&#x27;active&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Iterate over a copy</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;inactive&#x27;</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Create a new collection</span></span><br><span class="line">active_users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;active&#x27;</span>:</span><br><span class="line">        active_users[user] = status</span><br></pre></td></tr></table></figure>
<h2 id="4-3-range-函数">4.3. <code>range()</code> 函数</h2>
<p>内置函数 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range"><code>range()</code></a> 用于生成等差数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>生成的序列绝不会包括给定的终止值；<code>range(10)</code> 生成 10 个值——长度为 10 的序列的所有合法索引。range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>))</span><br><span class="line">[-<span class="number">10</span>, -<span class="number">40</span>, -<span class="number">70</span>]</span><br></pre></td></tr></table></figure>
<p>要按索引迭代序列，可以组合使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range"><code>range()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#len"><code>len()</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;had&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;little&#x27;</span>, <span class="string">&#x27;lamb&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure>
<p>不过大多数情况下 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#enumerate"><code>enumerate()</code></a> 函数很方便，详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-loopidioms">循环的技巧</a>。</p>
<p>如果直接打印一个 range 会发生意想不到的事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range"><code>range()</code></a> 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空间。</p>
<p>这种对象称为可迭代对象 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-iterable">iterable</a>，适合作为需要获取一系列值的函数或程序构件的参数。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 语句就是这样的程序构件；以可迭代对象作为参数的函数例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#sum"><code>sum()</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 0 + 1 + 2 + 3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>之后我们会看到更多返回可迭代对象，或以可迭代对象作为参数的函数。在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-structures">数据结构</a> 这一章中，我们将讨论 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#list"><code>list()</code></a> 的更多细节。</p>
<h2 id="4-4-循环中的-break、continue-语句及-else-子句">4.4. 循环中的 <code>break</code>、<code>continue</code> 语句及 <code>else</code> 子句</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#break"><code>break</code></a> 语句将跳出最近的一层 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#while"><code>while</code></a> 循环。</p>
<p><code>for</code> 或 <code>while</code> 循环可以包括 <code>else</code> 子句。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 循环中，<code>else</code> 子句会在循环成功结束最后一次迭代之后执行。</p>
<p>在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#while"><code>while</code></a> 循环中，它会在循环条件变为假值后执行。</p>
<p>无论哪种循环，如果因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#break"><code>break</code></a> 而结束，那么 <code>else</code> 子句就 <strong>不会</strong> 执行。</p>
<p>下面的搜索质数的 <code>for</code> 循环就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(n, <span class="string">&#x27;equals&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(n, <span class="string">&#x27;is a prime number&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>（没错，这段代码就是这么写。仔细看：<code>else</code> 子句属于 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 循环，<strong>不属于</strong> <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#if"><code>if</code></a> 语句。）</p>
<p><code>else</code> 子句用于循环时比起 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#if"><code>if</code></a> 语句的 <code>else</code> 子句，更像 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#try"><code>try</code></a> 语句的。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#try"><code>try</code></a> 语句的 <code>else</code> 子句在未发生异常时执行，循环的 <code>else</code> 子句则在未发生 <code>break</code> 时执行。 <code>try</code> 语句和异常详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/errors.html#tut-handling">异常的处理</a>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#continue"><code>continue</code></a> 语句，同样借鉴自 C 语言，以执行循环的下一次迭代来继续：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;Found an even number&quot;</span>, num)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Found an odd number&quot;</span>, num)</span><br><span class="line">...</span><br><span class="line">Found an even number <span class="number">2</span></span><br><span class="line">Found an odd number <span class="number">3</span></span><br><span class="line">Found an even number <span class="number">4</span></span><br><span class="line">Found an odd number <span class="number">5</span></span><br><span class="line">Found an even number <span class="number">6</span></span><br><span class="line">Found an odd number <span class="number">7</span></span><br><span class="line">Found an even number <span class="number">8</span></span><br><span class="line">Found an odd number <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="4-5-pass-语句">4.5. <code>pass</code> 语句</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#pass"><code>pass</code></a> 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这常用于创建一个最小的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">MyEmptyClass</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#pass"><code>pass</code></a> 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。<code>pass</code> 会被默默地忽略：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">initlog</span>(<span class="params">*args</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>   <span class="comment"># Remember to implement this!</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="4-6-match-语句">4.6. <code>match</code> 语句</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#match"><code>match</code></a> 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或 Haskell 中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量。</p>
<p>最简单的形式是将一个主语值与一个或多个字面值进行比较：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    <span class="keyword">match</span> status:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Something&#x27;s wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意最后一个代码块：“变量名” <code>_</code> 被作为 <em>通配符</em> 并必定会匹配成功。</p>
<p>如果没有 case 匹配成功，则不会执行任何分支。</p>
<p>你可以使用 <code>|</code> （“ or ”）在一个模式中组合几个字面值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">401</span> | <span class="number">403</span> | <span class="number">404</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Not allowed&quot;</span></span><br></pre></td></tr></table></figure>
<p>形如解包赋值的模式可被用于绑定变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># point is an (x, y) tuple</span></span><br><span class="line"><span class="keyword">match</span> point:</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Y=<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;X=<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> (x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;X=<span class="subst">&#123;x&#125;</span>, Y=<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Not a point&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>请仔细学习此代码！第一个模式有两个字面值，可视为前述字面值模式的扩展。</p>
<p>接下来的两个模式结合了一个字面值和一个变量，变量 <em>绑定</em> 了来自主语（<code>point</code>）的一个值。</p>
<p>第四个模式捕获了两个值，使其在概念上与解包赋值 <code>(x, y) = point</code> 类似。</p>
<p>如果用类组织数据，可以用“类名后接一个参数列表”这种很像构造器的形式，把属性捕获到变量里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">where_is</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">match</span> point:</span><br><span class="line">        <span class="keyword">case</span> Point(x=<span class="number">0</span>, y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point(x=<span class="number">0</span>, y=y):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Y=<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point(x=x, y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;X=<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Somewhere else&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Not a point&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以在某些为其属性提供了排序的内置类（例如 dataclass）中使用位置参数。</p>
<p>你也可以通过在你的类中设置 <code>__match_args__</code> 特殊属性来为模式中的属性定义一个专门的位置。 如果它被设为 (“x”, “y”)，则以下模式均为等价的（并且都是将 <code>y</code> 属性绑定到 <code>var</code> 变量）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="number">1</span>, var)</span><br><span class="line">Point(<span class="number">1</span>, y=var)</span><br><span class="line">Point(x=<span class="number">1</span>, y=var)</span><br><span class="line">Point(y=var, x=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>建议这样来阅读一个模式——通过将其视为赋值语句等号左边的一种扩展形式，来理解各个变量被设为何值。match 语句只会为单一的名称（如上面的 <code>var</code>）赋值，而不会赋值给带点号的名称（如 <code>foo.bar</code>）、属性名（如上面的 <code>x=</code> 和 <code>y=</code>）和类名（是通过其后的 “(…)” 来识别的，如上面的 <code>Point</code>）。</p>
<p>模式可以任意嵌套。</p>
<p>举例来说，如果我们有一个由 Point 组成的列表，且 Point 添加了 <code>__match_args__</code> 时，我们可以这样来匹配它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    __match_args__ = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> points:</span><br><span class="line">    <span class="keyword">case</span> []:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No points&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, <span class="number">0</span>)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The origin&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(x, y)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Single point <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, y1), Point(<span class="number">0</span>, y2)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Two on the Y axis at <span class="subst">&#123;y1&#125;</span>, <span class="subst">&#123;y2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something else&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以向一个模式添加 <code>if</code> 子句，称为“约束项”。 如果约束项为假值，则 <code>match</code> 将继续尝试下一个 case 语句块。 请注意值的捕获发生在约束项被求值之前。:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> point:</span><br><span class="line">    <span class="keyword">case</span> Point(x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Y=X at <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> Point(x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Not on the diagonal&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>该语句的一些其它关键特性：</p>
<ul>
<li>
<p>与解包赋值类似，元组和列表模式具有完全相同的含义并且实际上都能匹配任意序列，区别是它们不能匹配迭代器或字符串。</p>
</li>
<li>
<p>序列模式支持扩展解包：<code>[x, y, *rest]</code> 和 <code>(x, y, *rest)</code> 和相应的解包赋值做的事是一样的。接在 <code>*</code> 后的名称也可以为 <code>_</code>，所以 <code>(x, y, *_)</code> 匹配含至少两项的序列，而不必绑定剩余的项。</p>
</li>
<li>
<p>映射模式：<code>&#123;&quot;bandwidth&quot;: b, &quot;latency&quot;: l&#125;</code> 从字典中捕获 <code>&quot;bandwidth&quot;</code> 和 <code>&quot;latency&quot;</code> 的值。额外的键会被忽略，这一点与序列模式不同。<code>**rest</code> 这样的解包也支持。（但 <code>**_</code> 将会是冗余的，故不允许使用。）</p>
</li>
<li>
<p>子模式可使用 <code>as</code> 关键字来捕获:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (Point(x1, y1), Point(x2, y2) <span class="keyword">as</span> p2): ...</span><br></pre></td></tr></table></figure>
<p>将把输入中的第二个元素捕获为 <code>p2</code> （只要输入是包含两个点的序列）</p>
</li>
<li>
<p>大多数字面值是按相等性比较的，但是单例对象 <code>True</code>、<code>False</code> 和 <code>None</code> 则是按 id 比较的。</p>
</li>
<li>
<p>模式可以使用具名常量。它们必须作为带点号的名称出现，以防止它们被解释为用于捕获的变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    RED = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    GREEN = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">    BLUE = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line"></span><br><span class="line">color = Color(<span class="built_in">input</span>(<span class="string">&quot;Enter your choice of &#x27;red&#x27;, &#x27;blue&#x27; or &#x27;green&#x27;: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> color:</span><br><span class="line">    <span class="keyword">case</span> Color.RED:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I see red!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> Color.GREEN:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Grass is green&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> Color.BLUE:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m feeling the blues :(&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更详细的说明和更多示例，可参阅以教程格式撰写的 <a target="_blank" rel="noopener" href="https://peps.python.org/pep-0636/"><strong>PEP 636</strong></a>。</p>
<h2 id="4-7-定义函数">4.7. 定义函数</h2>
<p>下列代码创建一个可以输出限定数值内的斐波那契数列函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure>
<p><em>定义</em> 函数使用关键字 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#def"><code>def</code></a>，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。</p>
<p>函数内的第一条语句是字符串时 ，该字符串就是文档字符串，也称为 <em>docstring</em>，详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/controlflow.html#tut-docstrings">文档字符串</a>。利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档；Python 开发者最好养成在代码中加入文档字符串的好习惯。</p>
<p>函数在 <em>执行</em> 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#global"><code>global</code></a> 语句定义的全局变量，或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句定义的外层函数变量）。</p>
<p>在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 <em>按值调用</em> 来传递的（其中的 <em>值</em> 始终是对象的 <em>引用</em> 而不是对象的值）。 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。</p>
<blockquote>
<p>实际上，<em>对象引用调用</em> 这种说法更好，因为，传递的是可变对象时，调用者能发现被调者做出的任何更改（插入列表的元素）。</p>
</blockquote>
<p>函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib</span><br><span class="line">&lt;function fib at 10042ed0&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">100</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<p><code>fib</code> 不返回值，因此，其他语言不把它当作函数，而是当作过程。事实上，没有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#return"><code>return</code></a> 语句的函数也返回值，只不过这个值比较是 <code>None</code> （是一个内置名称）。一般来说，解释器不会输出单独的返回值 <code>None</code> ，如需查看该值，可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#print"><code>print()</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(fib(<span class="number">0</span>))</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>编写不直接输出斐波那契数列运算结果，而是返回运算结果列表的函数也非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>):  <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Return a list containing the Fibonacci series up to n.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    result = []</span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        result.append(a)    <span class="comment"># see below</span></span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100 = fib2(<span class="number">100</span>)    <span class="comment"># call it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100                <span class="comment"># write the result</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure>
<p>本例也新引入了一些 Python 功能：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#return"><code>return</code></a> 语句返回函数的值。<code>return</code> 语句不带表达式参数时，返回 <code>None</code>。函数执行完毕退出也返回 <code>None</code>。</li>
<li>语句 <code>result.append(a)</code> 调用了列表对象 <code>result</code> 的 <em>方法</em>。 方法是‘从属于’对象的函数，其名称为 <code>obj.methodname</code>，其中 <code>obj</code> 是某个对象（可以是一个表达式），<code>methodname</code> 是由对象的类型定义的方法名称。 不同的类型定义了不同的方法。 不同的类型的方法可以使用相同的名称而不会产生歧义。 （使用 <em>类</em> 可以定义自己的对象类型和方法，参见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/classes.html#tut-classes">类</a>。） 在示例中显示的方法 <code>append()</code> 是由列表对象定义的；它会在列表的末尾添加一个新元素。 在本例中它等同于 <code>result = result + [a]</code>，但效率更高。</li>
</ul>
<h2 id="4-8-函数定义详解">4.8. 函数定义详解</h2>
<p>函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。</p>
<h3 id="4-8-1-默认值参数">4.8.1. 默认值参数</h3>
<p>为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ask_ok</span>(<span class="params">prompt, retries=<span class="number">4</span>, reminder=<span class="string">&#x27;Please try again!&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = <span class="built_in">input</span>(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;ye&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;nop&#x27;</span>, <span class="string">&#x27;nope&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid user response&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(reminder)</span><br></pre></td></tr></table></figure>
<p>该函数可以用以下方式调用：</p>
<ul>
<li>只给出必选实参：<code>ask_ok('Do you really want to quit?')</code></li>
<li>给出一个可选实参：<code>ask_ok('OK to overwrite the file?', 2)</code></li>
<li>给出所有实参：<code>ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')</code></li>
</ul>
<p>本例还使用了关键字 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/expressions.html#in"><code>in</code></a> ，用于确认序列中是否包含某个值。</p>
<p>默认值在 <em>定义</em> 作用域里的函数定义中求值，所以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg=i</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>上例输出的是 <code>5</code>。</p>
<p><strong>重要警告：</strong> 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>不想在后续调用之间共享默认值时，应以如下方式编写函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<h3 id="4-8-2-关键字参数">4.8.2. 关键字参数</h3>
<p><code>kwarg=value</code> 形式的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-keyword-argument">关键字参数</a> 也可以用于调用函数。函数示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Norwegian Blue&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- This parrot wouldn&#x27;t&quot;</span>, action, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;if you put&quot;</span>, voltage, <span class="string">&quot;volts through it.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- Lovely plumage, the&quot;</span>, <span class="built_in">type</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- It&#x27;s&quot;</span>, state, <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>该函数接受一个必选参数（<code>voltage</code>）和三个可选参数（<code>state</code>, <code>action</code> 和 <code>type</code>）。该函数可用下列方式调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">&#x27;VOOOOOM&#x27;</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">&#x27;VOOOOOM&#x27;</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a million&#x27;</span>, <span class="string">&#x27;bereft of life&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a thousand&#x27;</span>, state=<span class="string">&#x27;pushing up the daisies&#x27;</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure>
<p>以下调用函数的方式都无效：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parrot()                     <span class="comment"># required argument missing</span></span><br><span class="line">parrot(voltage=<span class="number">5.0</span>, <span class="string">&#x27;dead&#x27;</span>)  <span class="comment"># non-keyword argument after a keyword argument</span></span><br><span class="line">parrot(<span class="number">110</span>, voltage=<span class="number">220</span>)     <span class="comment"># duplicate value for the same argument</span></span><br><span class="line">parrot(actor=<span class="string">&#x27;John Cleese&#x27;</span>)  <span class="comment"># unknown keyword argument</span></span><br></pre></td></tr></table></figure>
<p>函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受的参数（比如，<code>actor</code> 不是函数 <code>parrot</code> 的有效参数），关键字参数的顺序并不重要。这也包括必选参数，（比如，<code>parrot(voltage=1000)</code> 也有效）。不能对同一个参数多次赋值，下面就是一个因此限制而失败的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function(<span class="number">0</span>, a=<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: function() got multiple values <span class="keyword">for</span> argument <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后一个形参为 <code>**name</code> 形式时，接收一个字典（详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesmapping">映射类型 — dict</a>），该字典包含与函数中已定义形参对应之外的所有关键字参数。<code>**name</code> 形参可以与 <code>*name</code> 形参（下一小节介绍）组合使用（<code>*name</code> 必须在 <code>**name</code> 前面）， <code>*name</code> 形参接收一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-tuples">元组</a>，该元组包含形参列表之外的位置参数。例如，可以定义下面这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cheeseshop</span>(<span class="params">kind, *arguments, **keywords</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- Do you have any&quot;</span>, kind, <span class="string">&quot;?&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- I&#x27;m sorry, we&#x27;re all out of&quot;</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        <span class="built_in">print</span>(kw, <span class="string">&quot;:&quot;</span>, keywords[kw])</span><br></pre></td></tr></table></figure>
<p>该函数可以用如下方式调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cheeseshop(<span class="string">&quot;Limburger&quot;</span>, <span class="string">&quot;It&#x27;s very runny, sir.&quot;</span>,</span><br><span class="line">           <span class="string">&quot;It&#x27;s really very, VERY runny, sir.&quot;</span>,</span><br><span class="line">           shopkeeper=<span class="string">&quot;Michael Palin&quot;</span>,</span><br><span class="line">           client=<span class="string">&quot;John Cleese&quot;</span>,</span><br><span class="line">           sketch=<span class="string">&quot;Cheese Shop Sketch&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Do you have <span class="built_in">any</span> Limburger ?</span><br><span class="line">-- I<span class="string">&#x27;m sorry, we&#x27;</span>re <span class="built_in">all</span> out of Limburger</span><br><span class="line">It<span class="string">&#x27;s very runny, sir.</span></span><br><span class="line"><span class="string">It&#x27;</span>s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">client : John Cleese</span><br><span class="line">sketch : Cheese Shop Sketch</span><br></pre></td></tr></table></figure>
<p>注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。</p>
<h3 id="4-8-3-特殊参数">4.8.3. 特殊参数</h3>
<p>默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键字，还是仅按关键字传递。</p>
<p>函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2</span>):</span><br><span class="line">      -----------    ----------     ----------</span><br><span class="line">        |             |                  |</span><br><span class="line">        |        Positional <span class="keyword">or</span> keyword   |</span><br><span class="line">        |                                - Keyword only</span><br><span class="line">         -- Positional only</span><br></pre></td></tr></table></figure>
<p><code>/</code> 和 <code>*</code> 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关键字形参也叫作命名形参。</p>
<h4 id="4-8-3-1-位置或关键字参数">4.8.3.1. 位置或关键字参数</h4>
<p>函数定义中未使用 <code>/</code> 和 <code>*</code> 时，参数可以按位置或关键字传递给函数。</p>
<h4 id="4-8-3-2-仅位置参数">4.8.3.2. 仅位置参数</h4>
<p>此处再介绍一些细节，特定形参可以标记为 <em>仅限位置</em>。<em>仅限位置</em> 时，形参的顺序很重要，且这些形参不能用关键字传递。仅限位置形参应放在 <code>/</code> （正斜杠）前。<code>/</code> 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参。</p>
<p><code>/</code> 后可以是 <em>位置或关键字</em> 或 <em>仅限关键字</em> 形参。</p>
<h4 id="4-8-3-3-仅限关键字参数">4.8.3.3. 仅限关键字参数</h4>
<p>把形参标记为 <em>仅限关键字</em>，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 <em>仅限关键字</em> 形参前添加 <code>*</code>。</p>
<h4 id="4-8-3-4-函数示例">4.8.3.4. 函数示例</h4>
<p>请看下面的函数定义示例，注意 <code>/</code> 和 <code>*</code> 标记：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">standard_arg</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pos_only_arg</span>(<span class="params">arg, /</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">kwd_only_arg</span>(<span class="params">*, arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">combined_example</span>(<span class="params">pos_only, /, standard, *, kwd_only</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(pos_only, standard, kwd_only)</span><br></pre></td></tr></table></figure>
<p>第一个函数定义 <code>standard_arg</code> 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按关键字传递参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(arg=<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>第二个函数 <code>pos_only_arg</code> 的函数定义中有 <code>/</code>，仅限使用位置形参：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(arg=<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: pos_only_arg() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;arg&#x27;</span></span><br></pre></td></tr></table></figure>
<p>第三个函数 <code>kwd_only_args</code> 的函数定义通过 <code>*</code> 表明仅限关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: kwd_only_arg() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(arg=<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>最后一个函数在同一个函数定义中，使用了全部三种调用惯例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(pos_only=<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;pos_only&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面的函数定义中，<code>kwds</code> 把 <code>name</code> 当作键，因此，可能与位置参数 <code>name</code> 产生潜在冲突：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, **kwds</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br></pre></td></tr></table></figure>
<p>调用该函数不可能返回 <code>True</code>，因为关键字 <code>'name'</code> 总与第一个形参绑定。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values <span class="keyword">for</span> argument <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>加上 <code>/</code> （仅限位置参数）后，就可以了。此时，函数定义把 <code>name</code> 当作位置参数，<code>'name'</code> 也可以作为关键字参数的键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, /, **kwds</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>换句话说，仅限位置形参的名称可以在 <code>**kwds</code> 中使用，而不产生歧义。</p>
<h4 id="4-8-3-5-小结">4.8.3.5. 小结</h4>
<p>以下用例决定哪些形参可以用于函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2</span>):</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参顺序时，或同时接收位置形参和关键字时，这种方式很有用。</li>
<li>当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置时，才使用关键字。</li>
<li>对于 API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的 API 变动。</li>
</ul>
<h3 id="4-8-4-任意实参列表">4.8.4. 任意实参列表</h3>
<p>调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中（详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-tuples">元组和序列</a> ）。在可变数量的实参之前，可能有若干个普通参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_multiple_items</span>(<span class="params">file, separator, *args</span>):</span><br><span class="line">    file.write(separator.join(args))</span><br></pre></td></tr></table></figure>
<p><em>variadic</em> 参数用于采集传递给函数的所有剩余参数，因此，它们通常在形参列表的末尾。<code>*args</code> 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">*args, sep=<span class="string">&quot;/&quot;</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> sep.join(args)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth/mars/venus&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concat(<span class="string">&quot;earth&quot;</span>, <span class="string">&quot;mars&quot;</span>, <span class="string">&quot;venus&quot;</span>, sep=<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;earth.mars.venus&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-5-解包实参列表">4.8.5. 解包实参列表</h3>
<p>函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range"><code>range()</code></a> 函数要求独立的 <em>start</em> 和 <em>stop</em> 实参。如果这些参数不是独立的，则要在调用函数时，用 <code>*</code> 操作符把实参从列表或元组解包出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(*args))            <span class="comment"># call with arguments unpacked from a list</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>同样，字典可以用 <code>**</code> 操作符传递关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;-- This parrot wouldn&#x27;t&quot;</span>, action, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;if you put&quot;</span>, voltage, <span class="string">&quot;volts through it.&quot;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;E&#x27;s&quot;</span>, state, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;voltage&quot;</span>: <span class="string">&quot;four million&quot;</span>, <span class="string">&quot;state&quot;</span>: <span class="string">&quot;bleedin&#x27; demised&quot;</span>, <span class="string">&quot;action&quot;</span>: <span class="string">&quot;VOOM&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parrot(**d)</span><br><span class="line">-- This parrot wouldn<span class="string">&#x27;t VOOM if you put four million volts through it. E&#x27;</span>s bleedin<span class="string">&#x27; demised !</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-6-Lambda-表达式">4.8.6. Lambda 表达式</h3>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/expressions.html#lambda"><code>lambda</code></a> 关键字用于创建小巧的匿名函数。<code>lambda a, b: a+b</code> 函数返回两个参数的和。Lambda 函数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_incrementor</span>(<span class="params">n</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure>
<p>上例用 lambda 表达式返回函数。还可以把匿名函数用作传递的实参：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="4-8-7-文档字符串">4.8.7. 文档字符串</h3>
<p>以下是文档字符串内容和格式的约定。</p>
<p>第一行应为对象用途的简短摘要。为保持简洁，不要在这里显式说明对象名或类型，因为可通过其他方式获取这些信息（除非该名称碰巧是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。</p>
<p>文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。后面的行可包含若干段落，描述对象的调用约定、副作用等。</p>
<p>Python 解析器不会删除 Python 中多行字符串字面值的缩进，因此，文档处理工具应在必要时删除缩进。这项操作遵循以下约定：文档字符串第一行 <em>之后</em> 的第一个非空行决定了整个文档字符串的缩进量（第一行通常与字符串开头的引号相邻，其缩进在字符串中并不明显，因此，不能用第一行的缩进），然后，删除字符串中所有行开头处与此缩进“等价”的空白符。不能有比此缩进更少的行，但如果出现了缩进更少的行，应删除这些行的所有前导空白符。转化制表符后（通常为 8 个空格），应测试空白符的等效性。</p>
<p>下面是多行文档字符串的一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Do nothing, but document it.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    No, really, it doesn&#x27;t do anything.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(my_function.__doc__)</span><br><span class="line">Do nothing, but document it.</span><br><span class="line"></span><br><span class="line">    No, really, it doesn<span class="string">&#x27;t do anything.</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-8-函数注解">4.8.8. 函数注解</h3>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#function">函数注解</a> 是可选的用户自定义函数类型的元数据完整信息（详见 <a target="_blank" rel="noopener" href="https://peps.python.org/pep-3107/"><strong>PEP 3107</strong></a> 和 <a target="_blank" rel="noopener" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> ）。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-function-annotation">标注</a> 以字典的形式存放在函数的 <code>__annotations__</code> 属性中而对函数的其他部分没有影响。 形参标注的定义方式是在形参名后加冒号，后面跟一个会被求值为标注的值的表达式。 返回值标注的定义方式是加组合符号 <code>-&gt;</code>，后面跟一个表达式，这样的校注位于形参列表和表示 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#def"><code>def</code></a> 语句结束的冒号。 下面的示例有一个必须的参数、一个可选的关键字参数以及返回值都带有相应的标注:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">ham: <span class="built_in">str</span>, eggs: <span class="built_in">str</span> = <span class="string">&#x27;eggs&#x27;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Annotations:&quot;</span>, f.__annotations__)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Arguments:&quot;</span>, ham, eggs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> ham + <span class="string">&#x27; and &#x27;</span> + eggs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">Annotations: &#123;<span class="string">&#x27;ham&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;return&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;eggs&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br><span class="line">Arguments: spam eggs</span><br><span class="line"><span class="string">&#x27;spam and eggs&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-9-小插曲：编码风格">4.9. 小插曲：编码风格</h2>
<p>现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 <em>代码风格</em> 了。 大多数语言都能以不同的风格被编写（或更准确地说，被格式化）；有些比其他的更具有可读性。 能让其他人轻松阅读你的代码总是一个好主意，采用一种好的编码风格对此有很大帮助。</p>
<p>Python 项目大多都遵循 <a target="_blank" rel="noopener" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> 的风格指南；它推行的编码风格易于阅读、赏心悦目。Python 开发者均应抽时间悉心研读；以下是该提案中的核心要点：</p>
<ul>
<li>
<p>缩进，用 4 个空格，不要用制表符。</p>
<p>4 个空格是小缩进（更深嵌套）和大缩进（更易阅读）之间的折中方案。制表符会引起混乱，最好别用。</p>
</li>
<li>
<p>换行，一行不超过 79 个字符。</p>
<p>这样换行的小屏阅读体验更好，还便于在大屏显示器上并排阅读多个代码文件。</p>
</li>
<li>
<p>用空行分隔函数和类，及函数内较大的代码块。</p>
</li>
<li>
<p>最好把注释放到单独一行。</p>
</li>
<li>
<p>使用文档字符串。</p>
</li>
<li>
<p>运算符前后、逗号后要用空格，但不要直接在括号内使用： <code>a = f(1, 2) + g(3, 4)</code>。</p>
</li>
<li>
<p>类和函数的命名要一致；按惯例，命名类用 <code>UpperCamelCase</code>，命名函数与方法用 <code>lowercase_with_underscores</code>。命名方法中第一个参数总是用 <code>self</code> (类和方法详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/classes.html#tut-firstclasses">初探类</a>)。</p>
</li>
<li>
<p>编写用于国际多语环境的代码时，不要用生僻的编码。Python 默认的 UTF-8 或纯 ASCII 可以胜任各种情况。</p>
</li>
<li>
<p>同理，就算多语阅读、维护代码的可能再小，也不要在标识符中使用非 ASCII 字符。</p>
</li>
</ul>
<h1>5. 数据结构</h1>
<p>本章深入讲解之前学过的一些内容，同时，还增加了新的知识点。</p>
<h2 id="5-1-列表详解">5.1. 列表详解</h2>
<p>列表数据类型支持很多方法，列表对象的所有方法所示如下：</p>
<ul>
<li>
<p>list.<strong>append</strong>(<em>x</em>)</p>
<p>在列表末尾添加一个元素，相当于 <code>a[len(a):] = [x]</code> 。</p>
</li>
<li>
<p>list.<strong>extend</strong>(<em>iterable</em>)</p>
<p>用可迭代对象的元素扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</p>
</li>
<li>
<p>list.<strong>insert</strong>(<em>i</em>, <em>x</em>)</p>
<p>在指定位置插入元素。第一个参数是插入元素的索引，因此，<code>a.insert(0, x)</code> 在列表开头插入元素， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</p>
</li>
<li>
<p>list.<strong>remove</strong>(<em>x</em>)</p>
<p>从列表中删除第一个值为 <em>x</em> 的元素。未找到指定元素时，触发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。</p>
</li>
<li>
<p>list.<strong>pop</strong>([<em>i</em>])</p>
<p>删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，<code>a.pop()</code> 删除并返回列表的最后一个元素。（方法签名中 <em>i</em> 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）。</p>
</li>
<li>
<p>list.<strong>clear</strong>()</p>
<p>删除列表里的所有元素，相当于 <code>del a[:]</code> 。</p>
</li>
<li>
<p>list.<strong>index</strong>(<em>x</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回列表中第一个值为 <em>x</em> 的元素的零基索引。未找到指定元素时，触发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。可选参数 <em>start</em> 和 <em>end</em> 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 <em>start</em> 参数。</p>
</li>
<li>
<p>list.<strong>count</strong>(<em>x</em>)</p>
<p>返回列表中元素 <em>x</em> 出现的次数。</p>
</li>
<li>
<p>list.<strong>sort</strong>(***, <em>key=None</em>, <em>reverse=False</em>)</p>
<p>就地排序列表中的元素（要了解自定义排序参数，详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#sorted"><code>sorted()</code></a>）。</p>
</li>
<li>
<p>list.<strong>reverse</strong>()</p>
<p>翻转列表中的元素。</p>
</li>
<li>
<p>list.<strong>copy</strong>()</p>
<p>返回列表的浅拷贝。相当于 <code>a[:]</code> 。</p>
</li>
</ul>
<p>多数列表方法示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;kiwi&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.count(<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.count(<span class="string">&#x27;tangerine&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.index(<span class="string">&#x27;banana&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.index(<span class="string">&#x27;banana&#x27;</span>, <span class="number">4</span>)  <span class="comment"># Find next banana starting at position 4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;kiwi&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.append(<span class="string">&#x27;grape&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;kiwi&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;kiwi&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.pop()</span><br><span class="line"><span class="string">&#x27;pear&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你可能已经注意到 <code>insert</code>, <code>remove</code> 或 <code>sort</code> 等仅修改列表的方法都不会打印返回值 – 它们返回默认值 <code>None</code>。这是适用于 Python 中所有可变数据结构的设计原则。</p>
<blockquote>
<p>别的语言可能会将可变对象返回，允许方法连续执行，例如 <code>d-&gt;insert(&quot;a&quot;)-&gt;remove(&quot;b&quot;)-&gt;sort();</code>。</p>
</blockquote>
<p>还有，不是所有数据都可以排序或比较。例如，<code>[None, 'hello', 10]</code> 就不可排序，因为整数不能与字符串对比，而 <em>None</em> 不能与其他类型对比。有些类型根本就没有定义顺序关系，例如，<code>3+4j &lt; 5+7j</code> 这种对比操作就是无效的。</p>
<h3 id="5-1-1-用列表实现堆栈">5.1.1. 用列表实现堆栈</h3>
<p>通过列表方法可以非常容易地将列表作为栈来使用，最后添加的元素将最先被提取（“后进先出”）。 要向栈顶添加一个条目，请使用 <code>append()</code>。 要从栈顶提取一个条目，请使用 <code>pop()</code>，无需显式指定索引。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stack</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-用列表实现队列">5.1.2. 用列表实现队列</h3>
<p>列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。</p>
<p>实现队列最好用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/collections.html#collections.deque"><code>collections.deque</code></a>，可以快速从两端添加或删除元素。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Terry&quot;</span>)           <span class="comment"># Terry arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">&quot;Graham&quot;</span>)          <span class="comment"># Graham arrives</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The first to arrive now leaves</span></span><br><span class="line"><span class="string">&#x27;Eric&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()                 <span class="comment"># The second to arrive now leaves</span></span><br><span class="line"><span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>queue                           <span class="comment"># Remaining queue in order of arrival</span></span><br><span class="line">deque([<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Terry&#x27;</span>, <span class="string">&#x27;Graham&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-列表推导式">5.1.3. 列表推导式</h3>
<p>列表推导式创建列表的方式更简洁。常见的用法为，对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。</p>
<p>例如，创建平方值的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>注意，这段代码创建（或覆盖）变量 <code>x</code>，该变量在循环结束后仍然存在。下述方法可以无副作用地计算平方列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>或等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>上面这种写法更简洁、易读。</p>
<p>列表推导式的方括号内包含以下内容：一个表达式，后面为一个 <code>for</code> 子句，然后，是零个或多个 <code>for</code> 或 <code>if</code> 子句。结果是由表达式依据 <code>for</code> 和 <code>if</code> 子句求值计算而得出一个新列表。 举例来说，以下列表推导式将两个列表中不相等的元素组合起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>注意，上面两段代码中，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#if"><code>if</code></a> 的顺序相同。</p>
<p>表达式是元组（例如上例的 <code>(x, y)</code>）时，必须加上括号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [-<span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># create a new list with the values doubled</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[-<span class="number">8</span>, -<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># filter the list to exclude negative numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> vec <span class="keyword">if</span> x &gt;= <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># apply a function to all the elements</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> vec]</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># call a method on each element</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>freshfruit = [<span class="string">&#x27;  banana&#x27;</span>, <span class="string">&#x27;  loganberry &#x27;</span>, <span class="string">&#x27;passion fruit  &#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[weapon.strip() <span class="keyword">for</span> weapon <span class="keyword">in</span> freshfruit]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># create a list of 2-tuples like (number, square)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, x**<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># the tuple must be parenthesized, otherwise an error is raised</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    [x, x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line">     ^^^^^^^</span><br><span class="line">SyntaxError: did you forget parentheses around the comprehension target?</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># flatten a list using a listcomp with two &#x27;for&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>列表推导式可以使用复杂的表达式和嵌套函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">str</span>(<span class="built_in">round</span>(pi, i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">[<span class="string">&#x27;3.1&#x27;</span>, <span class="string">&#x27;3.14&#x27;</span>, <span class="string">&#x27;3.142&#x27;</span>, <span class="string">&#x27;3.1416&#x27;</span>, <span class="string">&#x27;3.14159&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="5-1-4-嵌套的列表推导式">5.1.4. 嵌套的列表推导式</h3>
<p>列表推导式中的初始表达式可以是任何表达式，甚至可以是另一个列表推导式。</p>
<p>下面这个 3x4 矩阵，由 3 个长度为 4 的列表组成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>
<p>下面的列表推导式可以转置行列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>如我们在之前小节中看到的，内部的列表推导式是在它之后的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/compound_stmts.html#for"><code>for</code></a> 的上下文中被求值的，所以这个例子等价于:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>反过来说，也等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># the following 3 lines implement the nested listcomp</span></span><br><span class="line"><span class="meta">... </span>    transposed_row = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line"><span class="meta">... </span>        transposed_row.append(row[i])</span><br><span class="line"><span class="meta">... </span>    transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<p>实际应用中，最好用内置函数替代复杂的流程语句。此时，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#zip"><code>zip()</code></a> 函数更好用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>
<p>关于本行中星号的详细说明，参见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/controlflow.html#tut-unpacking-arguments">解包实参列表</a>。</p>
<h2 id="5-2-del-语句">5.2. <code>del</code> 语句</h2>
<p>有一种方式可以按索引而不是值从列表中移除条目: <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#del"><code>del</code></a> 语句。 这与返回一个值的 <code>pop()</code> 方法不同。 <code>del</code> 语句也可用于从列表中移除切片或清空整个列表（我们之前通过将切片赋值为一个空列表实现过此操作）。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">66.25</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#del"><code>del</code></a> 也可以用来删除整个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<p>此后，再引用 <code>a</code> 就会报错（直到为它赋与另一个值）。后文会介绍 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#del"><code>del</code></a> 的其他用法。</p>
<h2 id="5-3-元组和序列">5.3. 元组和序列</h2>
<p>列表和字符串有很多共性，例如，索引和切片操作。这两种数据类型是 <em>序列</em> （参见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesseq">序列类型 — list, tuple, range</a>）。随着 Python 语言的发展，其他的序列类型也被加入其中。本节介绍另一种标准序列类型：<em>元组</em>。</p>
<p>元组由多个用逗号隔开的值组成，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples may be nested:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples are immutable:</span></span><br><span class="line"><span class="meta">... </span>t[<span class="number">0</span>] = <span class="number">88888</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># but they can contain mutable objects:</span></span><br><span class="line"><span class="meta">... </span>v = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。</p>
<p>虽然，元组与列表很像，但使用场景不同，用途也不同。元组是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-immutable">immutable</a> （不可变的），一般可包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/collections.html#collections.namedtuple"><code>namedtuples</code></a>，可以属性访问）。列表是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-mutable">mutable</a> （可变的），列表元素一般为同质类型，可迭代访问。</p>
<p>构造 0 个或 1 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。用一对空圆括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>singleton = <span class="string">&#x27;hello&#x27;</span>,    <span class="comment"># &lt;-- note trailing comma</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(empty)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(singleton)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>singleton</span><br><span class="line">(<span class="string">&#x27;hello&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<p>语句 <code>t = 12345, 54321, 'hello!'</code> 是 <em>元组打包</em> 的例子：值 <code>12345</code>, <code>54321</code> 和 <code>'hello!'</code> 一起被打包进元组。逆操作也可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y, z = t</span><br></pre></td></tr></table></figure>
<p>称之为 <em>序列解包</em> 也是妥妥的，适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数量应相等。注意，多重赋值其实只是元组打包和序列解包的组合。</p>
<h2 id="5-4-集合">5.4. 集合</h2>
<p>Python 还支持 <em>集合</em> 这种数据类型。集合是由不重复元素组成的无序容器。基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。</p>
<p>创建集合用花括号或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#set"><code>set()</code></a> 函数。注意，创建空集合只能用 <code>set()</code>，不能用 <code>&#123;&#125;</code>，<code>&#123;&#125;</code> 创建的是空字典，下一小节介绍数据结构：字典。</p>
<p>以下是一些简单的示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># show that duplicates have been removed</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># fast membership testing</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in a or b or both</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-listcomps">列表推导式</a> 类似，集合也支持推导式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-字典">5.5. 字典</h2>
<p>另一个非常有用的 Python 内置数据类型是 <em>字典</em> (参见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesmapping">映射类型 — dict</a>)。 字典在其他语言中可能会被称为“关联存储”或“关联数组”。 不同于以固定范围的数字进行索引的序列，字典是以 <em>键</em> 进行索引的，键可以是任何不可变类型；字符串和数字总是可以作为键。 如果一个元组只包含字符串、数字或元组则也可以作为键；如果一个元组直接或间接地包含了任何可变对象，则不能作为键。 列表不能作为键，因为列表可以使用索引赋值、切片赋值或者 <code>append()</code> 和 <code>extend()</code> 等方法进行原地修改列表。</p>
<p>可以把字典理解为 <em>键值对</em> 的集合，但字典的键必须是唯一的。花括号 <code>&#123;&#125;</code> 用于创建空字典。另一种初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。</p>
<p>字典的主要用途是通过关键字存储、提取值。用 <code>del</code> 可以删除键值对。用已存在的关键字存储值，与该关键字关联的旧值会被取代。通过不存在的键提取值，则会报错。</p>
<p>对字典执行 <code>list(d)</code> 操作，返回该字典中所有键的列表，按插入次序排列（如需排序，请使用 <code>sorted(d)</code>）。检查字典里是否存在某个键，使用关键字 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/expressions.html#in"><code>in</code></a>。</p>
<p>以下是一些字典的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">&#x27;sape&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;irv&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;irv&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(tel)</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(tel)</span><br><span class="line">[<span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#dict"><code>dict()</code></a> 构造函数可以直接用键值对序列创建字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;sape&#x27;</span>, <span class="number">4139</span>), (<span class="string">&#x27;guido&#x27;</span>, <span class="number">4127</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br></pre></td></tr></table></figure>
<p>字典推导式可以用任意键值表达式创建字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure>
<p>关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-循环的技巧">5.6. 循环的技巧</h2>
<p>当对字典执行循环时，可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#dict.items"><code>items()</code></a> 方法同时提取键及其对应的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>
<p>在序列中循环时，用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#enumerate"><code>enumerate()</code></a> 函数可以同时取出位置索引和对应的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure>
<p>同时循环两个或多个序列时，用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#zip"><code>zip()</code></a> 函数可以将其内的元素一一匹配：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>
<p>为了逆向对序列进行循环，可以求出欲循环的正向序列，然后调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#reversed"><code>reversed()</code></a> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>按指定顺序循环序列，可以用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#sorted"><code>sorted()</code></a> 函数，在不改动原序列的基础上，返回一个重新的序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(basket):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>
<p>使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#set"><code>set()</code></a> 去除序列中的重复元素。使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#sorted"><code>sorted()</code></a> 加 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#set"><code>set()</code></a> 则按排序后的顺序，循环遍历序列中的唯一元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(basket)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>
<p>一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_data = [<span class="number">56.2</span>, <span class="built_in">float</span>(<span class="string">&#x27;NaN&#x27;</span>), <span class="number">51.7</span>, <span class="number">55.3</span>, <span class="number">52.5</span>, <span class="built_in">float</span>(<span class="string">&#x27;NaN&#x27;</span>), <span class="number">47.8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filtered_data = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> value <span class="keyword">in</span> raw_data:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="keyword">not</span> math.isnan(value):</span><br><span class="line"><span class="meta">... </span>        filtered_data.append(value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filtered_data</span><br><span class="line">[<span class="number">56.2</span>, <span class="number">51.7</span>, <span class="number">55.3</span>, <span class="number">52.5</span>, <span class="number">47.8</span>]</span><br></pre></td></tr></table></figure>
<h2 id="5-7-深入条件控制">5.7. 深入条件控制</h2>
<p><code>while</code> 和 <code>if</code> 条件句不只可以进行比较，还可以使用任意运算符。</p>
<p>比较运算符 <code>in</code> 和 <code>not in</code> 用于执行确定一个值是否存在（或不存在）于某个容器中的成员检测。 运算符 <code>is</code> 和 <code>is not</code> 用于比较两个对象是否是同一个对象。 所有比较运算符的优先级都一样，且低于任何数值运算符。</p>
<p>比较操作支持链式操作。例如，<code>a &lt; b == c</code> 校验 <code>a</code> 是否小于 <code>b</code>，且 <code>b</code> 是否等于 <code>c</code>。</p>
<p>比较操作可以用布尔运算符 <code>and</code> 和 <code>or</code> 组合，并且，比较操作（或其他布尔运算）的结果都可以用 <code>not</code> 取反。这些操作符的优先级低于比较操作符；<code>not</code> 的优先级最高， <code>or</code> 的优先级最低，因此，<code>A and not B or C</code> 等价于 <code>(A and (not B)) or C</code>。与其他运算符操作一样，此处也可以用圆括号表示想要的组合。</p>
<p>布尔运算符 <code>and</code> 和 <code>or</code> 是所谓的 <em>短路</em> 运算符：其参数从左至右求值，一旦可以确定结果，求值就会停止。例如，如果 <code>A</code> 和 <code>C</code> 为真，<code>B</code> 为假，那么 <code>A and B and C</code> 不会对 <code>C</code> 求值。用作普通值而不是布尔值时，短路运算符的返回值通常是最后一个求了值的参数。</p>
<p>还可以把比较运算或其它布尔表达式的结果赋值给变量，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string1, string2, string3 = <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;Trondheim&#x27;</span>, <span class="string">&#x27;Hammer Dance&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_null = string1 <span class="keyword">or</span> string2 <span class="keyword">or</span> string3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_null</span><br><span class="line"><span class="string">&#x27;Trondheim&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，Python 与 C 不同，在表达式内部赋值必须显式使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression">海象运算符</a> <code>:=</code>。 这避免了 C 程序中常见的问题：要在表达式中写 <code>==</code> 时，却写成了 <code>=</code>。</p>
<h2 id="5-8-序列和其他类型的比较">5.8. 序列和其他类型的比较</h2>
<p>序列对象可以与相同序列类型的其他对象比较。这种比较使用 <em>字典式</em> 顺序：首先，比较前两个对应元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中一个序列结束。如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。如果两个序列中所有的对应元素都相等，则两个序列相等。如果一个序列是另一个的初始子序列，则较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排序单个字符。下面列出了一些比较相同类型序列的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)              &lt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]              &lt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span> &lt; <span class="string">&#x27;C&#x27;</span> &lt; <span class="string">&#x27;Pascal&#x27;</span> &lt; <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)           &lt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)                 &lt; (<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)             == (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>))   &lt; (<span class="number">1</span>, <span class="number">2</span>, (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>注意，当比较不同类型的对象时，只要待比较的对象提供了合适的比较方法，就可以使用 <code>&lt;</code> 和 <code>&gt;</code> 进行比较。例如，混合的数字类型通过数字值进行比较，所以，0 等于 0.0，等等。如果没有提供合适的比较方法，解释器不会随便给出一个比较结果，而是引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/exceptions.html#TypeError"><code>TypeError</code></a> 异常。</p>
<h1>6. 模块</h1>
<p>退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 <em>脚本</em> 。随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用同一个函数时，不用把函数定义复制到各个程序。</p>
<p>为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 <em>模块</em> ；模块中的定义可以 <em>导入</em> 到其他模块或 <em>主</em> 模块（在顶层和计算器模式下，执行脚本中可访问的变量集）。</p>
<p>模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 <code>.py</code> 。在模块内部，通过全局变量 <code>__name__</code> 可以获取模块名（即字符串）。例如，用文本编辑器在当前目录下创建 <code>fibo.py</code> 文件，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fibonacci numbers module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>):   <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; n:</span><br><span class="line">        result.append(a)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>现在，进入 Python 解释器，用以下命令导入该模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>
<p>此操作不会直接把 <code>fibo</code> 中定义的函数名称添加到当前 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-namespace">namespace</a> 中（请参阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/classes.html#tut-scopes">Python 作用域和命名空间</a> 了解详情）；它只是将模块名称 <code>fibo</code> 添加到那里。 使用该模块名称你可以访问其中的函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">&#x27;fibo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果经常使用某个函数，可以把它赋值给局部变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<h2 id="6-1-模块详解">6.1. 模块详解</h2>
<p>模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 <em>第一次</em> 遇到模块名时执行。(文件作为脚本运行时，也会执行这些语句。)</p>
<blockquote>
<p>实际上函数定义也是被执行的语句；模块级函数定义的执行会将函数名称添加到模块的全局命名空间。</p>
</blockquote>
<p>每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。 因此，模块作者可以在模块内使用全局变量而不必担心与用户的全局变量发生意外冲突。 另一方面，如果你知道要怎么做就可以通过与引用模块函数一样的标记法 <code>modname.itemname</code> 来访问一个模块的全局变量。</p>
<p>模块可以导入其他模块。 根据惯例可以将所有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#import"><code>import</code></a> 语句都放在模块（或者也可以说是脚本）的开头但这并非强制要求。 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模块的全局命名空间。</p>
<p>还有一种 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#import"><code>import</code></a> 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间中。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，<code>fibo</code> 将是未定义的名称）。</p>
<p>还有一种变体可以导入模块内定义的所有名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种方式会导入所有不以下划线（<code>_</code>）开头的名称。大多数情况下，不要用这个功能，这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称。</p>
<p>注意，一般情况下，不建议从模块或包内导入 <code>*</code>，因为，这项操作经常让代码变得难以理解。不过，为了在交互式编译器中少打几个字，这么用也没问题。</p>
<p>模块名后使用 <code>as</code> 时，直接把 <code>as</code> 后的名称与导入模块绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo <span class="keyword">as</span> fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib.fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>与 <code>import fibo</code> 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 <code>fib</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#from"><code>from</code></a> 中也可以使用这种方式，效果类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib <span class="keyword">as</span> fibonacci</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibonacci(<span class="number">500</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>为了保证运行效率，每次解释器会话只导入一次模块。如果更改了模块内容，必须重启解释器；仅交互测试一个模块时，也可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/importlib.html#importlib.reload"><code>importlib.reload()</code></a>，例如 <code>import importlib; importlib.reload(modulename)</code>。</p>
<h3 id="6-1-1-以脚本方式执行模块">6.1.1. 以脚本方式执行模块</h3>
<p>可以用以下方式运行 Python 模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fibo.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
<p>这项操作将执行模块里的代码，和导入模块一样，但会把 <code>__name__</code> 赋值为 <code>&quot;__main__&quot;</code>。 也就是把下列代码添加到模块末尾：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    fib(<span class="built_in">int</span>(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>这个文件既能被用作脚本，又能被用作一个可供导入的模块，因为解析命令行参数的那两行代码只有在模块作为“main”文件执行时才会运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python fibo.py <span class="number">50</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>当这个模块被导入到其它模块时，那两行代码不运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这常用于为模块提供一个便捷的用户接口，或用于测试（把模块作为执行测试套件的脚本运行）。</p>
<h3 id="6-1-2-模块搜索路径">6.1.2. 模块搜索路径</h3>
<p>当导入一个名为 <code>spam</code> 的模块时，解释器首先会搜索具有该名称的内置模块。 这些模块的名称在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys.html#sys.builtin_module_names"><code>sys.builtin_module_names</code></a> 中列出。 如果未找到，它将在变量 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys.html#sys.path"><code>sys.path</code></a> 所给出的目录列表中搜索名为 <code>spam.py</code> 的文件。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys.html#sys.path"><code>sys.path</code></a> 是从这些位置初始化的:</p>
<ul>
<li>被命令行直接运行的脚本所在的目录（或未指定文件时的当前目录）。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> （目录列表，与 shell 变量 <code>PATH</code> 的语法一样）。</li>
<li>依赖于安装的默认值（按照惯例包括一个 <code>site-packages</code> 目录，由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/site.html#module-site"><code>site</code></a> 模块处理）。</li>
</ul>
<p>更多细节请参阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys_path_init.html#sys-path-init">sys.path 模块搜索路径的初始化</a>。</p>
<p>在支持符号链接的文件系统中，“被命令行直接运行的脚本所在的目录”是符号链接最终指向的目录。换句话说，符号链接所在的目录并 <strong>没有</strong> 被添加至模块搜索路径。</p>
<p>初始化后，Python 程序可以更改 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys.html#sys.path"><code>sys.path</code></a>。脚本所在的目录先于标准库所在的路径被搜索。这意味着，脚本所在的目录如果有和标准库同名的文件，那么加载的是该目录里的，而不是标准库的。这一般是一个错误，除非这样的替换是你有意为之。详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/tutorial/modules.html#tut-standardmodules">标准模块</a>。</p>
<h3 id="6-1-3-“已编译的”-Python-文件">6.1.3. “已编译的” Python 文件</h3>
<p>为了快速加载模块，Python 把模块的编译版本缓存在 <code>__pycache__</code> 目录中，文件名为 <code>module.*version*.pyc</code>，version 对编译文件格式进行编码，一般是 Python 的版本号。例如，CPython 的 3.3 发行版中，<a target="_blank" rel="noopener" href="http://spam.py">spam.py</a> 的编译版本缓存为 <code>__pycache__/spam.cpython-33.pyc</code>。这种命名惯例让不同 Python 版本编译的模块可以共存。</p>
<p>Python 对比编译版与源码的修改日期，查看编译版是否已过期，是否要重新编译。此进程完全是自动的。此外，编译模块与平台无关，因此，可在不同架构的系统之间共享相同的库。</p>
<p>Python 在两种情况下不检查缓存。一，从命令行直接载入的模块，每次都会重新编译，且不储存编译结果；二，没有源模块，就不会检查缓存。为了让一个库能以隐藏源代码的形式分发（通过将所有源代码变为编译后的版本），编译后的模块必须放在源目录而非缓存目录中，并且源目录绝不能包含同名的未编译的源模块。</p>
<p>给专业人士的一些小建议：</p>
<ul>
<li>在 Python 命令中使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-O"><code>-O</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#cmdoption-OO"><code>-OO</code></a> 开关，可以减小编译模块的大小。<code>-O</code> 去除断言语句，<code>-OO</code> 去除断言语句和 <strong>doc</strong> 字符串。有些程序可能依赖于这些内容，因此，没有十足的把握，不要使用这两个选项。“优化过的”模块带有 <code>opt-</code> 标签，并且文件通常会一小些。将来的发行版或许会改进优化的效果。</li>
<li>从 <code>.pyc</code> 文件读取的程序不比从 <code>.py</code> 读取的执行速度快，<code>.pyc</code> 文件只是加载速度更快。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/compileall.html#module-compileall"><code>compileall</code></a> 模块可以为一个目录下的所有模块创建 .pyc 文件。</li>
<li>本过程的细节及决策流程图，详见 <a target="_blank" rel="noopener" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>。</li>
</ul>
<h2 id="6-2-标准模块">6.2. 标准模块</h2>
<p>Python 自带一个标准模块的库，它在 Python 库参考（此处以下称为&quot;库参考&quot; ）里另外描述。 一些模块是内嵌到编译器里面的， 它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖于底层的操作系统。 例如，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/winreg.html#module-winreg"><code>winreg</code></a> 模块只在 Windows 系统上提供。一个特别值得注意的模块 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/sys.html#module-sys"><code>sys</code></a>，它被内嵌到每一个 Python 编译器中。<code>sys.ps1</code> 和 <code>sys.ps2</code> 变量定义了一些字符，它们可以用作主提示符和辅助提示符:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">&#x27;&gt;&gt;&gt; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">&#x27;... &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">&#x27;C&gt; &#x27;</span></span><br><span class="line">C&gt; <span class="built_in">print</span>(<span class="string">&#x27;Yuck!&#x27;</span>)</span><br><span class="line">Yuck!</span><br><span class="line">C&gt;</span><br></pre></td></tr></table></figure>
<p>只有解释器用于交互模式时，才定义这两个变量。</p>
<p>变量 <code>sys.path</code> 是字符串列表，用于确定解释器的模块搜索路径。该变量以环境变量 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a> 提取的默认路径进行初始化，如未设置 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/using/cmdline.html#envvar-PYTHONPATH"><code>PYTHONPATH</code></a>，则使用内置的默认路径。可以用标准列表操作修改该变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">&#x27;/ufs/guido/lib/python&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-3-dir-函数">6.3. <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#dir"><code>dir()</code></a> 函数</h2>
<p>内置函数 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#dir"><code>dir()</code></a> 用于查找模块定义的名称。返回结果是经过排序的字符串列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(fibo)</span><br><span class="line">[<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fib2&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(sys)  </span><br><span class="line">[<span class="string">&#x27;__breakpointhook__&#x27;</span>, <span class="string">&#x27;__displayhook__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__excepthook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__interactivehook__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__stderr__&#x27;</span>, <span class="string">&#x27;__stdin__&#x27;</span>, <span class="string">&#x27;__stdout__&#x27;</span>, <span class="string">&#x27;__unraisablehook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_clear_type_cache&#x27;</span>, <span class="string">&#x27;_current_frames&#x27;</span>, <span class="string">&#x27;_debugmallocstats&#x27;</span>, <span class="string">&#x27;_framework&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;_getframe&#x27;</span>, <span class="string">&#x27;_git&#x27;</span>, <span class="string">&#x27;_home&#x27;</span>, <span class="string">&#x27;_xoptions&#x27;</span>, <span class="string">&#x27;abiflags&#x27;</span>, <span class="string">&#x27;addaudithook&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;api_version&#x27;</span>, <span class="string">&#x27;argv&#x27;</span>, <span class="string">&#x27;audit&#x27;</span>, <span class="string">&#x27;base_exec_prefix&#x27;</span>, <span class="string">&#x27;base_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;breakpointhook&#x27;</span>, <span class="string">&#x27;builtin_module_names&#x27;</span>, <span class="string">&#x27;byteorder&#x27;</span>, <span class="string">&#x27;call_tracing&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;callstats&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;displayhook&#x27;</span>, <span class="string">&#x27;dont_write_bytecode&#x27;</span>, <span class="string">&#x27;exc_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;excepthook&#x27;</span>, <span class="string">&#x27;exec_prefix&#x27;</span>, <span class="string">&#x27;executable&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>, <span class="string">&#x27;float_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;float_repr_style&#x27;</span>, <span class="string">&#x27;get_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;get_coroutine_origin_tracking_depth&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getallocatedblocks&#x27;</span>, <span class="string">&#x27;getdefaultencoding&#x27;</span>, <span class="string">&#x27;getdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getfilesystemencodeerrors&#x27;</span>, <span class="string">&#x27;getfilesystemencoding&#x27;</span>, <span class="string">&#x27;getprofile&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;getrecursionlimit&#x27;</span>, <span class="string">&#x27;getrefcount&#x27;</span>, <span class="string">&#x27;getsizeof&#x27;</span>, <span class="string">&#x27;getswitchinterval&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gettrace&#x27;</span>, <span class="string">&#x27;hash_info&#x27;</span>, <span class="string">&#x27;hexversion&#x27;</span>, <span class="string">&#x27;implementation&#x27;</span>, <span class="string">&#x27;int_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;intern&#x27;</span>, <span class="string">&#x27;is_finalizing&#x27;</span>, <span class="string">&#x27;last_traceback&#x27;</span>, <span class="string">&#x27;last_type&#x27;</span>, <span class="string">&#x27;last_value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;maxsize&#x27;</span>, <span class="string">&#x27;maxunicode&#x27;</span>, <span class="string">&#x27;meta_path&#x27;</span>, <span class="string">&#x27;modules&#x27;</span>, <span class="string">&#x27;path&#x27;</span>, <span class="string">&#x27;path_hooks&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;path_importer_cache&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;prefix&#x27;</span>, <span class="string">&#x27;ps1&#x27;</span>, <span class="string">&#x27;ps2&#x27;</span>, <span class="string">&#x27;pycache_prefix&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;set_asyncgen_hooks&#x27;</span>, <span class="string">&#x27;set_coroutine_origin_tracking_depth&#x27;</span>, <span class="string">&#x27;setdlopenflags&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;setprofile&#x27;</span>, <span class="string">&#x27;setrecursionlimit&#x27;</span>, <span class="string">&#x27;setswitchinterval&#x27;</span>, <span class="string">&#x27;settrace&#x27;</span>, <span class="string">&#x27;stderr&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;stdin&#x27;</span>, <span class="string">&#x27;stdout&#x27;</span>, <span class="string">&#x27;thread_info&#x27;</span>, <span class="string">&#x27;unraisablehook&#x27;</span>, <span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;version_info&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;warnoptions&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>没有参数时，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#dir"><code>dir()</code></a> 列出当前已定义的名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;fib&#x27;</span>, <span class="string">&#x27;fibo&#x27;</span>, <span class="string">&#x27;sys&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>注意它列出所有类型的名称：变量，模块，函数，……。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/functions.html#dir"><code>dir()</code></a> 不会列出内置函数和变量的名称。这些内容的定义在标准模块 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/builtins.html#module-builtins"><code>builtins</code></a> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> builtins</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(builtins)  </span><br><span class="line">[<span class="string">&#x27;ArithmeticError&#x27;</span>, <span class="string">&#x27;AssertionError&#x27;</span>, <span class="string">&#x27;AttributeError&#x27;</span>, <span class="string">&#x27;BaseException&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;BlockingIOError&#x27;</span>, <span class="string">&#x27;BrokenPipeError&#x27;</span>, <span class="string">&#x27;BufferError&#x27;</span>, <span class="string">&#x27;BytesWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ChildProcessError&#x27;</span>, <span class="string">&#x27;ConnectionAbortedError&#x27;</span>, <span class="string">&#x27;ConnectionError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ConnectionRefusedError&#x27;</span>, <span class="string">&#x27;ConnectionResetError&#x27;</span>, <span class="string">&#x27;DeprecationWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;EOFError&#x27;</span>, <span class="string">&#x27;Ellipsis&#x27;</span>, <span class="string">&#x27;EnvironmentError&#x27;</span>, <span class="string">&#x27;Exception&#x27;</span>, <span class="string">&#x27;False&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;FileExistsError&#x27;</span>, <span class="string">&#x27;FileNotFoundError&#x27;</span>, <span class="string">&#x27;FloatingPointError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;FutureWarning&#x27;</span>, <span class="string">&#x27;GeneratorExit&#x27;</span>, <span class="string">&#x27;IOError&#x27;</span>, <span class="string">&#x27;ImportError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ImportWarning&#x27;</span>, <span class="string">&#x27;IndentationError&#x27;</span>, <span class="string">&#x27;IndexError&#x27;</span>, <span class="string">&#x27;InterruptedError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;IsADirectoryError&#x27;</span>, <span class="string">&#x27;KeyError&#x27;</span>, <span class="string">&#x27;KeyboardInterrupt&#x27;</span>, <span class="string">&#x27;LookupError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;MemoryError&#x27;</span>, <span class="string">&#x27;NameError&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;NotADirectoryError&#x27;</span>, <span class="string">&#x27;NotImplemented&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;NotImplementedError&#x27;</span>, <span class="string">&#x27;OSError&#x27;</span>, <span class="string">&#x27;OverflowError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>, <span class="string">&#x27;PermissionError&#x27;</span>, <span class="string">&#x27;ProcessLookupError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ReferenceError&#x27;</span>, <span class="string">&#x27;ResourceWarning&#x27;</span>, <span class="string">&#x27;RuntimeError&#x27;</span>, <span class="string">&#x27;RuntimeWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;StopIteration&#x27;</span>, <span class="string">&#x27;SyntaxError&#x27;</span>, <span class="string">&#x27;SyntaxWarning&#x27;</span>, <span class="string">&#x27;SystemError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SystemExit&#x27;</span>, <span class="string">&#x27;TabError&#x27;</span>, <span class="string">&#x27;TimeoutError&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;TypeError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;UnboundLocalError&#x27;</span>, <span class="string">&#x27;UnicodeDecodeError&#x27;</span>, <span class="string">&#x27;UnicodeEncodeError&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;UnicodeError&#x27;</span>, <span class="string">&#x27;UnicodeTranslateError&#x27;</span>, <span class="string">&#x27;UnicodeWarning&#x27;</span>, <span class="string">&#x27;UserWarning&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ValueError&#x27;</span>, <span class="string">&#x27;Warning&#x27;</span>, <span class="string">&#x27;ZeroDivisionError&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;__build_class__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__debug__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;abs&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;any&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>, <span class="string">&#x27;bool&#x27;</span>, <span class="string">&#x27;bytearray&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>, <span class="string">&#x27;callable&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;classmethod&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;complex&#x27;</span>, <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;delattr&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>, <span class="string">&#x27;divmod&#x27;</span>, <span class="string">&#x27;enumerate&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;filter&#x27;</span>, <span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;frozenset&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;hasattr&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hash&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;isinstance&#x27;</span>, <span class="string">&#x27;issubclass&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;len&#x27;</span>, <span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;locals&#x27;</span>, <span class="string">&#x27;map&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;memoryview&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;oct&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;ord&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;property&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;range&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;reversed&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;setattr&#x27;</span>, <span class="string">&#x27;slice&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sorted&#x27;</span>, <span class="string">&#x27;staticmethod&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;super&#x27;</span>, <span class="string">&#x27;tuple&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;vars&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;zip&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="6-4-包">6.4. 包</h2>
<p>包是通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式。 例如，模块名 <code>A.B</code> 表示名为 <code>A</code> 的包中名为 <code>B</code> 的子模块。 就像使用模块可以让不同模块的作者不必担心彼此的全局变量名一样，使用带点号模块名也可以让 NumPy 或 Pillow 等多模块包的作者也不必担心彼此的模块名冲突。</p>
<p>假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展名来识别，例如：<code>.wav</code>，<code>.aiff</code>，<code>.au</code>），因此，为了不同文件格式之间的转换，需要创建和维护一个不断增长的模块集合。为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、创造人工立体声效果），还要编写无穷无尽的模块流。下面这个分级文件树展示了这个包的架构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats/                  Subpackage <span class="keyword">for</span> file <span class="built_in">format</span> conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  Subpackage <span class="keyword">for</span> sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  Subpackage <span class="keyword">for</span> filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>导入包时，Python 搜索 <code>sys.path</code> 里的目录，查找包的子目录。</p>
<p>需要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包来处理（除非使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/glossary.html#term-namespace-package">namespace package</a>，这是一个相对高级的特性）。 这可以防止重名的目录如 <code>string</code> 在无意中屏蔽后继出现在模块搜索路径中的有效模块。 在最简单的情况下，<code>__init__.py</code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，这将在稍后详细描述。</p>
<p>还可以从包中导入单个模块，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>
<p>这将加载子模块 <code>sound.effects.echo</code>。 它必须通过其全名来引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sound.effects.echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>另一种导入子模块的方法是 ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<p>这也会加载子模块 <code>echo</code>，并使其不必加包前缀，因此可按如下方式使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo.echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>Import 语句的另一种变体是直接导入所需的函数或变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>
<p>同样，这将加载子模块 <code>echo</code>，但这使其函数 <code>echofilter()</code> 直接可用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echofilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>注意，使用 <code>from package import item</code> 时，item 可以是包的子模块（或子包），也可以是包中定义的函数、类或变量等其他名称。<code>import</code> 语句首先测试包中是否定义了 item；如果未在包中定义，则假定 item 是模块，并尝试加载。如果找不到 item，则触发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/library/exceptions.html#ImportError"><code>ImportError</code></a> 异常。</p>
<p>相反，使用 <code>import item.subitem.subsubitem</code> 句法时，除最后一项外，每个 item 都必须是包；最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。</p>
<h3 id="6-4-1-从包中导入">6.4.1. 从包中导入 *</h3>
<p>使用 <code>from sound.effects import *</code> 时会发生什么？你可能希望它会查找并导入包的所有子模块，但事实并非如此。因为这将花费很长的时间，并且可能会产生你不想要的副作用，如果这种副作用被你设计为只有在导入某个特定的子模块时才应该发生。</p>
<p>唯一的解决办法是提供包的显式索引。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#import"><code>import</code></a> 语句使用如下惯例：如果包的 <code>__init__.py</code> 代码定义了列表 <code>__all__</code>，运行 <code>from package import *</code> 时，它就是被导入的模块名列表。发布包的新版本时，包的作者应更新此列表。如果包的作者认为没有必要在包中执行导入 * 操作，也可以不提供此列表。例如，<code>sound/effects/__init__.py</code> 文件可以包含以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;surround&quot;</span>, <span class="string">&quot;reverse&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这意味着 <code>from sound.effects import *</code> 将导入 <code>sound.effects</code> 包的三个命名子模块。</p>
<p>请注意子模块可能会受到本地定义名称的影响。 例如，如果你在 <code>sound/effects/__init__.py</code> 文件中添加了一个 <code>reverse</code> 函数，<code>from sound.effects import *</code> 将只导入 <code>echo</code> 和 <code>surround</code> 这两个子模块，但 <strong>不会</strong> 导入 <code>reverse</code> 子模块，因为它被本地定义的 <code>reverse</code> 函数所遮挡:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [</span><br><span class="line">    <span class="string">&quot;echo&quot;</span>,      <span class="comment"># refers to the &#x27;echo.py&#x27; file</span></span><br><span class="line">    <span class="string">&quot;surround&quot;</span>,  <span class="comment"># refers to the &#x27;surround.py&#x27; file</span></span><br><span class="line">    <span class="string">&quot;reverse&quot;</span>,   <span class="comment"># !!! refers to the &#x27;reverse&#x27; function now !!!</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">msg: <span class="built_in">str</span></span>):  <span class="comment"># &lt;-- this name shadows the &#x27;reverse.py&#x27; submodule</span></span><br><span class="line">    <span class="keyword">return</span> msg[::-<span class="number">1</span>]    <span class="comment">#     in the case of a &#x27;from sound.effects import *&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果没有定义 <code>__all__</code>，<code>from sound.effects import *</code> 语句 <em>不会</em> 把包 <code>sound.effects</code> 中的所有子模块都导入到当前命名空间；它只是确保包 <code>sound.effects</code> 已被导入（可能还会运行 <code>__init__.py</code> 中的任何初始化代码），然后再导入包中定义的任何名称。 这包括由 <code>__init__.py</code> 定义的任何名称（以及显式加载的子模块）。 它还包括先前 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#import"><code>import</code></a> 语句显式加载的包里的任何子模块。 请看以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>在本例中，<code>echo</code> 和 <code>surround</code> 模块被导入到当前命名空间，因为在执行 <code>from...import</code> 语句时它们已在 <code>sound.effects</code> 包中定义了。 （当定义了 <code>__all__</code> 时也是如此）。</p>
<p>虽然，可以把模块设计为用 <code>import *</code> 时只导出遵循指定模式的名称，但仍不提倡在生产代码中使用这种做法。</p>
<p>记住，使用 <code>from package import specific_submodule</code> 没有任何问题！ 实际上，除了导入模块使用不同包的同名子模块之外，这种方式是推荐用法。</p>
<h3 id="6-4-2-相对导入">6.4.2. 相对导入</h3>
<p>当包由多个子包构成（如示例中的 <code>sound</code> 包）时，可以使用绝对导入来引用同级包的子模块。 例如，如果 <code>sound.filters.vocoder</code> 模块需要使用 <code>sound.effects</code> 包中的 <code>echo</code> 模块，它可以使用 <code>from sound.effects import echo</code>。</p>
<p>你还可以编写相对导入代码，即使用 <code>from module import name</code> 形式的 import 语句。 这些导入使用前导点号来表示相对导入所涉及的当前包和上级包。 例如对于 <code>surround</code> 模块，可以使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure>
<p>注意，相对导入基于当前模块名。因为主模块名永远是 <code>&quot;__main__&quot;</code> ，所以如果计划将一个模块用作 Python 应用程序的主模块，那么该模块内的导入语句必须始终使用绝对导入。</p>
<h3 id="6-4-3-多目录中的包">6.4.3. 多目录中的包</h3>
<p>包还支持一个特殊属性 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.11/reference/import.html#path__"><code>__path__</code></a> 。在包的 <code>__init__.py</code> 中的代码被执行前，该属性被初始化为一个只含一项的列表，该项是一个字符串，是 <strong>init</strong>.py 所在目录的名称。可以修改此变量；这样做会改变在此包中搜索模块和子包的方式。</p>
<p>这个功能虽然不常用，但可用于扩展包中的模块集。</p>
<h1>7. 输入与输出</h1>
<p>程序输出有几种显示方式；数据既可以输出供人阅读的形式，也可以写入文件备用。本章探讨一些可用的方式。</p>
<h2 id="7-1-更复杂的输出格式">7.1. 更复杂的输出格式</h2>
<p>到目前为止我们已遇到过两种写入值的方式: <em>表达式语句</em> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 函数。 （第三种方式是使用文件对象的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.TextIOBase.write"><code>write()</code></a> 方法；标准输出文件可以被引用为 <code>sys.stdout</code>。 更多相关信息请参阅标准库参考）。</p>
<p>对输出格式的控制不只是打印空格分隔的值，还需要更多方式。格式化输出包括以下几种方法。</p>
<ul>
<li>
<p>使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#tut-f-strings">格式化字符串字面值</a> ，要在字符串开头的引号/三引号前添加 <code>f</code> 或 <code>F</code> 。在这种字符串中，可以在 <code>&#123;</code> 和 <code>&#125;</code> 字符之间输入引用的变量，或字面值的 Python 表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>year = <span class="number">2016</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = <span class="string">&#x27;Referendum&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;Results of the <span class="subst">&#123;year&#125;</span> <span class="subst">&#123;event&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">&#x27;Results of the 2016 Referendum&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法需要更多手动操作。该方法也用 <code>&#123;</code> 和 <code>&#125;</code> 标记替换变量的位置，虽然这种方法支持详细的格式化指令，但需要提供格式化信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>yes_votes = <span class="number">42_572_654</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>no_votes = <span class="number">43_132_495</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>percentage = yes_votes / (yes_votes + no_votes)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:-9&#125; YES votes  &#123;:2.2%&#125;&#x27;</span>.<span class="built_in">format</span>(yes_votes, percentage)</span><br><span class="line"><span class="string">&#x27; 42572654 YES votes  49.67%&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后，还可以用字符串切片和合并操作完成字符串处理操作，创建任何排版布局。字符串类型还支持将字符串按给定列宽进行填充，这些方法也很有用。</p>
</li>
</ul>
<p>如果不需要花哨的输出，只想快速显示变量进行调试，可以用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a> 函数把值转化为字符串。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a> 函数返回供人阅读的值，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> 则生成适于解释器读取的值（如果没有等效的语法，则强制执行 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError"><code>SyntaxError</code></a>）。对于没有支持供人阅读展示结果的对象， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a> 返回与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> 相同的值。一般情况下，数字、列表或字典等结构的值，使用这两个函数输出的表现形式是一样的。字符串有两种不同的表现形式。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Hello, world.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello, world.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello, world.&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1</span>/<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0.14285714285714285&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span> * <span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">200</span> * <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;The value of x is &#x27;</span> + <span class="built_in">repr</span>(x) + <span class="string">&#x27;, and y is &#x27;</span> + <span class="built_in">repr</span>(y) + <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">The value of x <span class="keyword">is</span> <span class="number">32.5</span>, <span class="keyword">and</span> y <span class="keyword">is</span> <span class="number">40000.</span>..</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The repr() of a string adds string quotes and backslashes:</span></span><br><span class="line"><span class="meta">... </span>hello = <span class="string">&#x27;hello, world\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hellos = <span class="built_in">repr</span>(hello)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(hellos)</span><br><span class="line"><span class="string">&#x27;hello, world\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The argument to repr() may be any Python object:</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">repr</span>((x, y, (<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)))</span><br><span class="line"><span class="string">&quot;(32.5, 40000, (&#x27;spam&#x27;, &#x27;eggs&#x27;))&quot;</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#module-string"><code>string</code></a> 模块包含 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#string.Template"><code>Template</code></a> 类，提供了将值替换为字符串的另一种方法。该类使用 <code>$x</code> 占位符，并用字典的值进行替换，但对格式控制的支持比较有限。</p>
<h3 id="7-1-1-格式化字符串字面值">7.1.1. 格式化字符串字面值</h3>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a> （简称为 f-字符串）在字符串前加前缀 <code>f</code> 或 <code>F</code>，通过 <code>&#123;expression&#125;</code> 表达式，把 Python 表达式的值添加到字符串内。</p>
<p>格式说明符是可选的，写在表达式后面，可以更好地控制格式化值的方式。下例将 pi 舍入到小数点后三位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;The value of pi is approximately <span class="subst">&#123;math.pi:<span class="number">.3</span>f&#125;</span>.&#x27;</span>)</span><br><span class="line">The value of pi <span class="keyword">is</span> approximately <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure>
<p>在 <code>':'</code> 后传递整数，为该字段设置最小字符宽度，常用于列对齐：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Sjoerd&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;Jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;Dcab&#x27;</span>: <span class="number">7678</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, phone <span class="keyword">in</span> table.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name:<span class="number">10</span>&#125;</span> ==&gt; <span class="subst">&#123;phone:10d&#125;</span>&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">Sjoerd     ==&gt;       <span class="number">4127</span></span><br><span class="line">Jack       ==&gt;       <span class="number">4098</span></span><br><span class="line">Dcab       ==&gt;       <span class="number">7678</span></span><br></pre></td></tr></table></figure>
<p>还有一些修饰符可以在格式化前转换值。 <code>'!a'</code> 应用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#ascii"><code>ascii()</code></a> ，<code>'!s'</code> 应用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a>，<code>'!r'</code> 应用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>animals = <span class="string">&#x27;eels&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;My hovercraft is full of <span class="subst">&#123;animals&#125;</span>.&#x27;</span>)</span><br><span class="line">My hovercraft <span class="keyword">is</span> full of eels.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;My hovercraft is full of <span class="subst">&#123;animals!r&#125;</span>.&#x27;</span>)</span><br><span class="line">My hovercraft <span class="keyword">is</span> full of <span class="string">&#x27;eels&#x27;</span>.</span><br></pre></td></tr></table></figure>
<p><code>=</code> 说明符可被用于将一个表达式扩展为表达式文本、等号再加表达式求值结果的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bugs = <span class="string">&#x27;roaches&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count = <span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area = <span class="string">&#x27;living room&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">f&#x27;Debugging <span class="subst">&#123;bugs=&#125;</span> <span class="subst">&#123;count=&#125;</span> <span class="subst">&#123;area=&#125;</span>&#x27;</span>)</span><br><span class="line">Debugging bugs=<span class="string">&#x27;roaches&#x27;</span> count=<span class="number">13</span> area=<span class="string">&#x27;living room&#x27;</span></span><br></pre></td></tr></table></figure>
<p>请参阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/whatsnew/3.8.html#bpo-36817-whatsnew">自说明型表达式</a> 以了解 <code>=</code> 说明符的更多信息。 有关这些格式说明的详情，请查看针对 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#formatspec">格式规格迷你语言</a> 的参考指南。</p>
<h3 id="7-1-2-字符串-format-方法">7.1.2. 字符串 format() 方法</h3>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的基本用法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;We are the &#123;&#125; who say &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;knights&#x27;</span>, <span class="string">&#x27;Ni&#x27;</span>))</span><br><span class="line">We are the knights who say <span class="string">&quot;Ni!&quot;</span></span><br></pre></td></tr></table></figure>
<p>花括号及之内的字符（称为格式字段）被替换为传递给 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的对象。花括号中的数字表示传递给 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的对象所在的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; and &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>))</span><br><span class="line">spam <span class="keyword">and</span> eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125; and &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>))</span><br><span class="line">eggs <span class="keyword">and</span> spam</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法中使用关键字参数名引用值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;This &#123;food&#125; is &#123;adjective&#125;.&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line"><span class="meta">... </span>      food=<span class="string">&#x27;spam&#x27;</span>, adjective=<span class="string">&#x27;absolutely horrible&#x27;</span>))</span><br><span class="line">This spam <span class="keyword">is</span> absolutely horrible.</span><br></pre></td></tr></table></figure>
<p>位置参数和关键字参数可以任意组合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Bill&#x27;</span>, <span class="string">&#x27;Manfred&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>                                                   other=<span class="string">&#x27;Georg&#x27;</span>))</span><br><span class="line">The story of Bill, Manfred, <span class="keyword">and</span> Georg.</span><br></pre></td></tr></table></figure>
<p>如果不想分拆较长的格式字符串，最好按名称引用变量进行格式化，不要按位置。这项操作可以通过传递字典，并用方括号 <code>'[]'</code> 访问键来完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Sjoerd&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;Jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;Dcab&#x27;</span>: <span class="number">8637678</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; &#x27;</span></span><br><span class="line"><span class="meta">... </span>      <span class="string">&#x27;Dcab: &#123;0[Dcab]:d&#125;&#x27;</span>.<span class="built_in">format</span>(table))</span><br><span class="line">Jack: <span class="number">4098</span>; Sjoerd: <span class="number">4127</span>; Dcab: <span class="number">8637678</span></span><br></pre></td></tr></table></figure>
<p>这也可以通过将 <code>table</code> 字典作为采用 <code>**</code> 标记的关键字参数传入来实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Sjoerd&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;Jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;Dcab&#x27;</span>: <span class="number">8637678</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;&#x27;</span>.<span class="built_in">format</span>(**table))</span><br><span class="line">Jack: <span class="number">4098</span>; Sjoerd: <span class="number">4127</span>; Dcab: <span class="number">8637678</span></span><br></pre></td></tr></table></figure>
<p>与内置函数 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#vars"><code>vars()</code></a> 结合使用时，这种方式非常实用，可以返回包含所有局部变量的字典。</p>
<p>举个例子，以下几行代码将产生一组整齐的数据列，包含给定的整数及其平方与立方:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;&#x27;</span>.<span class="built_in">format</span>(x, x*x, x*x*x))</span><br><span class="line">...</span><br><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 进行字符串格式化的完整概述详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings">格式字符串语法</a> 。</p>
<h3 id="7-1-3-手动格式化字符串">7.1.3. 手动格式化字符串</h3>
<p>下面是使用手动格式化方式实现的同一个平方和立方的表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">repr</span>(x).rjust(<span class="number">2</span>), <span class="built_in">repr</span>(x*x).rjust(<span class="number">3</span>), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Note use of &#x27;end&#x27; on previous line</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">repr</span>(x*x*x).rjust(<span class="number">4</span>))</span><br><span class="line">...</span><br><span class="line"> <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">36</span>  <span class="number">216</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">49</span>  <span class="number">343</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">64</span>  <span class="number">512</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">81</span>  <span class="number">729</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>（注意，每列之间的空格是通过使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 添加的：它总在其参数间添加空格。）</p>
<p>字符串对象的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.rjust"><code>str.rjust()</code></a> 方法通过在左侧填充空格，对给定宽度字段中的字符串进行右对齐。同类方法还有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.ljust"><code>str.ljust()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.center"><code>str.center()</code></a> 。这些方法不写入任何内容，只返回一个新字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；虽然这种方式会弄乱列布局，但也比另一种方法好，后者在显示值时可能不准确（如果真的想截断字符串，可以使用 <code>x.ljust(n)[:n]</code> 这样的切片操作 。）</p>
<p>另一种方法是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.zfill"><code>str.zfill()</code></a> ，该方法在数字字符串左边填充零，且能识别正负号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;12&#x27;</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;00012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;-3.14&#x27;</span>.zfill(<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;-003.14&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;3.14159265359&#x27;</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;3.14159265359&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4-旧式字符串格式化方法">7.1.4. 旧式字符串格式化方法</h3>
<p>% 运算符（求余符）也可用于字符串格式化。给定 <code>'string' % values</code>，则 <code>string</code> 中的 <code>%</code> 实例会以零个或多个 <code>values</code> 元素替换。此操作被称为字符串插值。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;The value of pi is approximately %5.3f.&#x27;</span> % math.pi)</span><br><span class="line">The value of pi <span class="keyword">is</span> approximately <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting">printf 风格的字符串格式化</a> 小节介绍更多相关内容。</p>
<h2 id="7-2-读写文件">7.2. 读写文件</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#open"><code>open()</code></a> 返回一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object">file object</a> ，最常使用的是两个位置参数和一个关键字参数：<code>open(filename, mode, encoding=None)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第一个实参是文件名字符串。第二个实参是包含描述文件使用方式字符的字符串。</p>
<p><em>mode</em> 的值包括 <code>'r'</code> ，表示文件只能读取；<code>'w'</code> 表示只能写入（现有同名文件会被覆盖）；<code>'a'</code> 表示打开文件并追加内容，任何写入的数据会自动添加到文件末尾。<code>'r+'</code> 表示打开文件进行读写。<em>mode</em> 实参是可选的，省略时的默认值为 <code>'r'</code>。</p>
<p>通常情况下，文件是以 <em>text mode</em> 打开的，也就是说，你从文件中读写字符串，这些字符串是以特定的 <em>encoding</em> 编码的。如果没有指定 <em>encoding</em> ，默认的是与平台有关的（见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#open"><code>open()</code></a> ）。因为 UTF-8 是现代事实上的标准，除非你知道你需要使用一个不同的编码，否则建议使用 <code>encoding=&quot;utf-8&quot;</code> 。</p>
<p>在模式后面加上一个 <code>'b'</code> ，可以用 <em>binary mode</em> 打开文件。二进制模式的数据是以 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes"><code>bytes</code></a> 对象的形式读写的。在二进制模式下打开文件时，你不能指定 <em>encoding</em> 。</p>
<p>在文本模式下读取文件时，默认把平台特定的行结束符（Unix 上为 <code>\n</code>, Windows 上为 <code>\r\n</code>）转换为 <code>\n</code>。在文本模式下写入数据时，默认把 <code>\n</code> 转换回平台特定结束符。这种操作方式在后台修改文件数据对文本文件来说没有问题，但会破坏 <code>JPEG</code> 或 <code>EXE</code> 等二进制文件中的数据。注意，在读写此类文件时，一定要使用二进制模式。</p>
<p>在处理文件对象时，最好使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 关键字。优点是，子句体结束后，文件会正确关闭，即便触发异常也可以。而且，使用 <code>with</code> 相比等效的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a>-<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally"><code>finally</code></a> 代码块要简短得多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># We can check that the file has been automatically closed.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>如果没有使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 关键字，则应调用 <code>f.close()</code> 关闭文件，即可释放文件占用的系统资源。</p>
<p>警告：调用 <code>f.write()</code> 时，未使用 <code>with</code> 关键字，或未调用 <code>f.close()</code>，即使程序正常退出，也<strong>可能</strong> 导致 <code>f.write()</code> 的参数没有完全写入磁盘。</p>
<p>通过 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 语句，或调用 <code>f.close()</code> 关闭文件对象后，再次使用该文件对象将会失败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure>
<h3 id="7-2-1-文件对象的方法">7.2.1. 文件对象的方法</h3>
<p>本节下文中的例子假定已创建 <code>f</code> 文件对象。</p>
<p><code>f.read(size)</code> 可用于读取文件内容，它会读取一些数据，并返回字符串（文本模式），或字节串对象（在二进制模式下）。 <em>size</em> 是可选的数值参数。省略 <em>size</em> 或 <em>size</em> 为负数时，读取并返回整个文件的内容；文件大小是内存的两倍时，会出现问题。<em>size</em> 取其他值时，读取并返回最多 <em>size</em> 个字符（文本模式）或 <em>size</em> 个字节（二进制模式）。如已到达文件末尾，<code>f.read()</code> 返回空字符串（<code>''</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;This is the entire file.\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>f.readline()</code> 从文件中读取单行数据；字符串末尾保留换行符（<code>\n</code>），只有在文件不以换行符结尾时，文件的最后一行才会省略换行符。这种方式让返回值清晰明确；只要 <code>f.readline()</code> 返回空字符串，就表示已经到达了文件末尾，空行使用 <code>'\n'</code> 表示，该字符串只包含一个换行符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">&#x27;This is the first line of the file.\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">&#x27;Second line of the file\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从文件中读取多行时，可以用循环遍历整个文件对象。这种操作能高效利用内存，快速，且代码简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">This <span class="keyword">is</span> the first line of the file.</span><br><span class="line">Second line of the file</span><br></pre></td></tr></table></figure>
<p>如需以列表形式读取文件中的所有行，可以用 <code>list(f)</code> 或 <code>f.readlines()</code>。</p>
<p><code>f.write(string)</code> 把 <em>string</em> 的内容写入文件，并返回写入的字符数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;This is a test\n&#x27;</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>写入其他类型的对象前，要先把它们转化为字符串（文本模式）或字节对象（二进制模式）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>value = (<span class="string">&#x27;the answer&#x27;</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">str</span>(value)  <span class="comment"># convert the tuple to string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(s)</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p><code>f.tell()</code> 返回整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节数，以及文本模式下的意义不明的数字。</p>
<p><code>f.seek(offset, whence)</code> 可以改变文件对象的位置。通过向参考点添加 <em>offset</em> 计算位置；参考点由 <em>whence</em> 参数指定。 <em>whence</em> 值为 0 时，表示从文件开头计算，1 表示使用当前文件位置，2 表示使用文件末尾作为参考点。省略 <em>whence</em> 时，其默认值为 0，即使用文件开头作为参考点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;workfile&#x27;</span>, <span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b&#x27;0123456789abcdef&#x27;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">5</span>)      <span class="comment"># Go to the 6th byte in the file</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(-<span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># Go to the 3rd byte before the end</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在文本文件（模式字符串未使用 <code>b</code> 时打开的文件）中，只允许相对于文件开头搜索（使用 <code>seek(0, 2)</code> 搜索到文件末尾是个例外），唯一有效的 <em>offset</em> 值是能从 <code>f.tell()</code> 中返回的，或 0。其他 <em>offset</em> 值都会产生未定义的行为。</p>
<p>文件对象还有一些额外的方法，如使用频率较低的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.IOBase.isatty"><code>isatty()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.IOBase.truncate"><code>truncate()</code></a> 等；有关文件对象的完整指南请查阅标准库参考。</p>
<h3 id="7-2-2-使用-json-保存结构化数据">7.2.2. 使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#module-json"><code>json</code></a> 保存结构化数据</h3>
<p>字符串可以很容易地写入文件或从文件中读取。 数字则更麻烦一些，因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.TextIOBase.read"><code>read()</code></a> 方法只返回字符串，而字符串必须传给 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int()</code></a> 这样的函数，它接受 <code>'123'</code> 这样的字符串并返回其数值 123。 当你想要保存嵌套列表和字典等更复杂的数据类型时，手动执行解析和序列化操作将会变得非常复杂。</p>
<p>Python 允许你使用流行的数据交换格式 <a target="_blank" rel="noopener" href="https://json.org/">JSON (JavaScript Object Notation)</a>，而不是让用户持续编写和调试代码来将复杂的数据类型存入文件中。 标准库模块 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#module-json"><code>json</code></a> 可以接受带有层级结构的 Python 数据，并将其转换为字符串表示形式；这个过程称为 <em>serializing</em>。 根据字符串表示形式重建数据则称为 <em>deserializing</em>。 在序列化和反序列化之间，用于代表对象的字符串可以存储在文件或数据库中，或者通过网络连接发送到远端主机。</p>
<p>JSON 格式通常用于现代应用程序的数据交换。程序员早已对它耳熟能详，可谓是交互操作的不二之选。</p>
<p>只需一行简单的代码即可查看某个对象的 JSON 字符串表现形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="string">&#x27;simple&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(x)</span><br><span class="line"><span class="string">&#x27;[1, &quot;simple&quot;, &quot;list&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#json.dumps"><code>dumps()</code></a> 函数还有一个变体， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#json.dump"><code>dump()</code></a> ，它只将对象序列化为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file">text file</a> 。因此，如果 <code>f</code> 是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file">text file</a> 对象，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dump(x, f)</span><br></pre></td></tr></table></figure>
<p>要再次解码对象，如果 <code>f</code> 是已打开、供读取的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file">binary file</a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file">text file</a> 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = json.load(f)</span><br></pre></td></tr></table></figure>
<p>JSON文件必须以UTF-8编码。当打开JSON文件作为一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file">text file</a> 用于读写时，使用 <code>encoding=&quot;utf-8&quot;</code> 。</p>
<p>这种简单的序列化技术可以处理列表和字典，但在 JSON 中序列化任意类的实例，则需要付出额外努力。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#module-json"><code>json</code></a> 模块的参考包含对此的解释。</p>
<p>参见</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle"><code>pickle</code></a> - 封存模块</p>
<p>与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#tut-json">JSON</a> 不同，<em>pickle</em> 是一种允许对复杂 Python 对象进行序列化的协议。因此，它为 Python 所特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果解序化的数据是由手段高明的攻击者精心设计的，这种不受信任来源的 pickle 数据可以执行任意代码。</p>
<h1>8. 错误和异常</h1>
<p>至此，本教程还未深入介绍错误信息，但如果您尝试过本教程前文中的例子，应该已经看到过一些错误信息。错误可（至少）被分为两种：<em>语法错误</em> 和 <em>异常</em>。</p>
<h2 id="8-1-语法错误">8.1. 语法错误</h2>
<p>语法错误又称解析错误，是学习 Python 时最常见的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>解析器会复现出现句法错误的代码行，并用小“箭头”指向行里检测到的第一个错误。错误是由箭头 <em>上方</em> 的 token 触发的（至少是在这里检测出的）：本例中，在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 函数中检测到错误，因为，在它前面缺少冒号（<code>':'</code>） 。错误信息还输出文件名与行号，在使用脚本文件时，就可以知道去哪里查错。</p>
<h2 id="8-2-异常">8.2. 异常</h2>
<p>即使语句或表达式使用了正确的语法，执行时仍可能触发错误。执行时检测到的错误称为 <em>异常</em>，异常不一定导致严重的后果：很快我们就能学会如何处理 Python 的异常。大多数异常不会被程序处理，而是显示下列错误信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> + spam*<span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;spam&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> + <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<p>错误信息的最后一行说明程序遇到了什么类型的错误。异常有不同的类型，而类型名称会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#ZeroDivisionError"><code>ZeroDivisionError</code></a>， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError"><code>NameError</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError"><code>TypeError</code></a>。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这种规范很有用）。标准的异常类型是内置的标识符（不是保留关键字）。</p>
<p>此行其余部分根据异常类型，结合出错原因，说明错误细节。</p>
<p>错误信息开头用堆栈回溯形式展示发生异常的语境。一般会列出源代码行的堆栈回溯；但不会显示从标准输入读取的行。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#bltin-exceptions">内置异常</a> 列出了内置异常及其含义。</p>
<h2 id="8-3-异常的处理">8.3. 异常的处理</h2>
<p>可以编写程序处理选定的异常。下例会要求用户一直输入内容，直到输入有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；注意，用户中断程序会触发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt"><code>KeyboardInterrupt</code></a> 异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please enter a number: &quot;</span>))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;Oops!  That was no valid number.  Try again...&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句的工作原理如下：</p>
<ul>
<li>首先，执行 <em>try 子句</em> （<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 关键字之间的（多行）语句）。</li>
<li>如果没有触发异常，则跳过 <em>except 子句</em>，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句执行完毕。</li>
<li>如果在执行 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 子句时发生了异常，则跳过该子句中剩下的部分。 如果异常的类型与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 关键字后指定的异常相匹配，则会执行 <em>except 子句</em>，然后跳到 try/except 代码块之后继续执行。</li>
<li>如果发生的异常与 <em>except 子句</em> 中指定的异常不匹配，则它会被传递到外层的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句中；如果没有找到处理句柄，则它是一个 <em>未处理异常</em> 且执行将停止并输出一条错误消息。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句可以有多个 <em>except 子句</em> 来为不同的异常指定处理程序。 但最多只有一个处理程序会被执行。 处理程序只处理对应的 <em>try 子句</em> 中发生的异常，而不处理同一 <code>try</code> 语句内其他处理程序中的异常。 <em>except 子句</em> 可以用带圆括号的元组来指定多个异常，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">... </span><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果发生的异常与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句中的类是同一个类或是它的基类时，则该类与该异常相兼容（反之则不成立 — 列出派生类的 <em>except 子句</em> 与基类不兼容）。 例如，下面的代码将依次打印 B, C, D:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">C</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cls <span class="keyword">in</span> [B, C, D]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> cls()</span><br><span class="line">    <span class="keyword">except</span> D:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> C:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> B:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>请注意如果颠倒 <em>except 子句</em> 的顺序（把 <code>except B</code> 放在最前），则会输出 B, B, B — 即触发了第一个匹配的 <em>except 子句</em>。</p>
<p>发生异常时，它可能具有关联值，即异常 <em>参数</em> 。是否需要参数，以及参数的类型取决于异常的类型。</p>
<p><em>except 子句</em> 可能会在异常名称后面指定一个变量。 这个变量将被绑定到异常实例，该实例通常会有一个存储参数的 <code>args</code> 属性。 为了方便起见，内置异常类型定义了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__"><code>__str__()</code></a> 来打印所有参数而不必显式地访问 <code>.args</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> Exception(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> inst:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">type</span>(inst))    <span class="comment"># the exception type</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(inst.args)     <span class="comment"># arguments stored in .args</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(inst)          <span class="comment"># __str__ allows args to be printed directly,</span></span><br><span class="line"><span class="meta">... </span>                         <span class="comment"># but may be overridden in exception subclasses</span></span><br><span class="line"><span class="meta">... </span>    x, y = inst.args     <span class="comment"># unpack args</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;y =&#x27;</span>, y)</span><br><span class="line">...</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;Exception&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">x = spam</span><br><span class="line">y = eggs</span><br></pre></td></tr></table></figure>
<p>未处理异常的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__"><code>__str__()</code></a> 输出会被打印为该异常消息的最后部分 (‘detail’)。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BaseException"><code>BaseException</code></a> 是所有异常的共同基类。它的一个子类， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> ，是所有非致命异常的基类。不是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> 的子类的异常通常不被处理，因为它们被用来指示程序应该终止。它们包括由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/sys.html#sys.exit"><code>sys.exit()</code></a> 引发的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#SystemExit"><code>SystemExit</code></a> ，以及当用户希望中断程序时引发的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt"><code>KeyboardInterrupt</code></a> 。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> 可以被用作通配符，捕获（几乎）一切。然而，好的做法是，尽可能具体地说明我们打算处理的异常类型，并允许任何意外的异常传播下去。</p>
<p>处理 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> 最常见的模式是打印或记录异常，然后重新提出（允许调用者也处理异常）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = <span class="built_in">int</span>(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OS error:&quot;</span>, err)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Could not convert data to an integer.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Unexpected <span class="subst">&#123;err=&#125;</span>, <span class="subst">&#123;<span class="built_in">type</span>(err)=&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> … <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 语句具有可选的 <em>else 子句</em>，该子句如果存在，它必须放在所有 <em>except 子句</em> 之后。 它适用于 <em>try 子句</em> 没有引发异常但又必须要执行的代码。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(arg, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cannot open&#x27;</span>, arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(arg, <span class="string">&#x27;has&#x27;</span>, <span class="built_in">len</span>(f.readlines()), <span class="string">&#x27;lines&#x27;</span>)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>使用 <code>else</code> 子句比向 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 子句添加额外的代码要好，可以避免意外捕获非 <code>try</code> … <code>except</code> 语句保护的代码触发的异常。</p>
<p>异常处理程序不仅会处理在 <em>try 子句</em> 中立刻发生的异常，还会处理在 <em>try 子句</em> 中调用（包括间接调用）的函数。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">this_fails</span>():</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    this_fails()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> err:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Handling run-time error:&#x27;</span>, err)</span><br><span class="line">...</span><br><span class="line">Handling run-time error: division by zero</span><br></pre></td></tr></table></figure>
<h2 id="8-4-触发异常">8.4. 触发异常</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise"><code>raise</code></a> 语句支持强制触发指定的异常。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise"><code>raise</code></a> 唯一的参数就是要触发的异常。这个参数必须是异常实例或异常类（派生自 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#BaseException"><code>BaseException</code></a> 类，例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> 或其子类）。如果传递的是异常类，将通过调用没有参数的构造函数来隐式实例化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError  <span class="comment"># shorthand for &#x27;raise ValueError()&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果只想判断是否触发了异常，但并不打算处理该异常，则可以使用更简单的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise"><code>raise</code></a> 语句重新触发异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> NameError:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;An exception flew by!&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>
<h2 id="8-5-异常链">8.5. 异常链</h2>
<p>如果一个未处理的异常发生在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 部分内，它将会有被处理的异常附加到它上面，并包括在错误信息中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">open</span>(<span class="string">&quot;database.sqlite&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> OSError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;unable to handle error&quot;</span>)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;database.sqlite&#x27;</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">RuntimeError: unable to handle error</span><br></pre></td></tr></table></figure>
<p>为了表明一个异常是另一个异常的直接后果， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise"><code>raise</code></a> 语句允许一个可选的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise"><code>from</code></a> 子句:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exc must be exception instance or None.</span></span><br><span class="line"><span class="keyword">raise</span> RuntimeError <span class="keyword">from</span> exc</span><br></pre></td></tr></table></figure>
<p>转换异常时，这种方式很有用。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ConnectionError</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    func()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Failed to open database&#x27;</span>) <span class="keyword">from</span> exc</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> func</span><br><span class="line">ConnectionError</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">RuntimeError: Failed to <span class="built_in">open</span> database</span><br></pre></td></tr></table></figure>
<p>它还允许使用 <code>from None</code> 表达禁用自动异常链:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">open</span>(<span class="string">&#x27;database.sqlite&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> OSError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> RuntimeError <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">RuntimeError</span><br></pre></td></tr></table></figure>
<p>异常链机制详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#bltin-exceptions">内置异常</a>。</p>
<h2 id="8-6-用户自定义异常">8.6. 用户自定义异常</h2>
<p>程序可以通过创建新的异常类命名自己的异常（Python 类的内容详见 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-classes">类</a>）。不论是以直接还是间接的方式，异常都应从 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception"><code>Exception</code></a> 类派生。</p>
<p>异常类可以被定义成能做其他类所能做的任何事，但通常应当保持简单，它往往只提供一些属性，允许相应的异常处理程序提取有关错误的信息。</p>
<p>大多数异常命名都以 “Error” 结尾，类似标准异常的命名。</p>
<p>许多标准模块定义了自己的异常，以报告他们定义的函数中可能出现的错误。</p>
<h2 id="8-7-定义清理操作">8.7. 定义清理操作</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句还有一个可选子句，用于定义在所有情况下都必须要执行的清理操作。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Goodbye, world!&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">Goodbye, world!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure>
<p>如果存在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally"><code>finally</code></a> 子句，则 <code>finally</code> 子句是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句结束前执行的最后一项任务。不论 <code>try</code> 语句是否触发异常，都会执行 <code>finally</code> 子句。以下内容介绍了几种比较复杂的触发异常情景：</p>
<ul>
<li>如果执行 <code>try</code> 子句期间触发了某个异常，则某个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句应处理该异常。如果该异常没有 <code>except</code> 子句处理，在 <code>finally</code> 子句执行后会被重新触发。</li>
<li><code>except</code> 或 <code>else</code> 子句执行期间也会触发异常。 同样，该异常会在 <code>finally</code> 子句执行之后被重新触发。</li>
<li>如果 <code>finally</code> 子句中包含 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break"><code>break</code></a>、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue"><code>continue</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return"><code>return</code></a> 等语句，异常将不会被重新引发。</li>
<li>如果执行 <code>try</code> 语句时遇到 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break"><code>break</code></a>,、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue"><code>continue</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return"><code>return</code></a> 语句，则 <code>finally</code> 子句在执行 <code>break</code>、<code>continue</code> 或 <code>return</code> 语句之前执行。</li>
<li>如果 <code>finally</code> 子句中包含 <code>return</code> 语句，则返回值来自 <code>finally</code> 子句的某个 <code>return</code> 语句的返回值，而不是来自 <code>try</code> 子句的 <code>return</code> 语句的返回值。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">bool_return</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool_return()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>这是一个比较复杂的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        result = x / y</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;division by zero!&quot;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, result)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;executing finally clause&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">result <span class="keyword">is</span> <span class="number">2.0</span></span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">division by zero!</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> divide</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> /: <span class="string">&#x27;str&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如上所示，任何情况下都会执行 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally"><code>finally</code></a> 子句。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句不处理两个字符串相除触发的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError"><code>TypeError</code></a>，因此会在 <code>finally</code> 子句执行后被重新触发。</p>
<p>在实际应用程序中，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally"><code>finally</code></a> 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。</p>
<h2 id="8-8-预定义的清理操作">8.8. 预定义的清理操作</h2>
<p>某些对象定义了不需要该对象时要执行的标准清理操作。无论使用该对象的操作是否成功，都会执行清理操作。比如，下例要打开一个文件，并输出文件内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个代码的问题在于，执行完代码后，文件在一段不确定的时间内处于打开状态。在简单脚本中这没有问题，但对于较大的应用程序来说可能会出问题。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 语句支持以及时、正确的清理的方式使用文件对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>语句执行完毕后，即使在处理行时遇到问题，都会关闭文件 <em>f</em>。和文件一样，支持预定义清理操作的对象会在文档中指出这一点。</p>
<h2 id="8-9-引发和处理多个不相关的异常">8.9. 引发和处理多个不相关的异常</h2>
<p>在有些情况下，有必要报告几个已经发生的异常。这通常是在并发框架中当几个任务并行失败时的情况，但也有其他的用例，有时需要是继续执行并收集多个错误而不是引发第一个异常。</p>
<p>内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#ExceptionGroup"><code>ExceptionGroup</code></a> 打包了一个异常实例的列表，这样它们就可以一起被引发。它本身就是一个异常，所以它可以像其他异常一样被捕获。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="meta">... </span>    excs = [OSError(<span class="string">&#x27;error 1&#x27;</span>), SystemError(<span class="string">&#x27;error 2&#x27;</span>)]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ExceptionGroup(<span class="string">&#x27;there were problems&#x27;</span>, excs)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line">  + Exception Group Traceback (most recent call last):</span><br><span class="line">  |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> f</span><br><span class="line">  | ExceptionGroup: there were problems</span><br><span class="line">  +-+---------------- <span class="number">1</span> ----------------</span><br><span class="line">    | OSError: error <span class="number">1</span></span><br><span class="line">    +---------------- <span class="number">2</span> ----------------</span><br><span class="line">    | SystemError: error <span class="number">2</span></span><br><span class="line">    +------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    f()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&#x27;caught <span class="subst">&#123;<span class="built_in">type</span>(e)&#125;</span>: e&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">caught &lt;<span class="keyword">class</span> <span class="string">&#x27;ExceptionGroup&#x27;</span>&gt;: e</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>except*</code> 代替 <code>except</code> ，我们可以有选择地只处理组中符合某种类型的异常。在下面的例子中，显示了一个嵌套的异常组，每个 <code>except*</code> 子句都从组中提取了某种类型的异常，而让所有其他的异常传播到其他子句，并最终被重新引发。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ExceptionGroup(</span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;group1&quot;</span>,</span><br><span class="line"><span class="meta">... </span>        [</span><br><span class="line"><span class="meta">... </span>            OSError(<span class="number">1</span>),</span><br><span class="line"><span class="meta">... </span>            SystemError(<span class="number">2</span>),</span><br><span class="line"><span class="meta">... </span>            ExceptionGroup(</span><br><span class="line"><span class="meta">... </span>                <span class="string">&quot;group2&quot;</span>,</span><br><span class="line"><span class="meta">... </span>                [</span><br><span class="line"><span class="meta">... </span>                    OSError(<span class="number">3</span>),</span><br><span class="line"><span class="meta">... </span>                    RecursionError(<span class="number">4</span>)</span><br><span class="line"><span class="meta">... </span>                ]</span><br><span class="line"><span class="meta">... </span>            )</span><br><span class="line"><span class="meta">... </span>        ]</span><br><span class="line"><span class="meta">... </span>    )</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    f()</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>* OSError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;There were OSErrors&quot;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span>* SystemError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;There were SystemErrors&quot;</span>)</span><br><span class="line">...</span><br><span class="line">There were OSErrors</span><br><span class="line">There were SystemErrors</span><br><span class="line">  + Exception Group Traceback (most recent call last):</span><br><span class="line">  |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">  | ExceptionGroup: group1</span><br><span class="line">  +-+---------------- <span class="number">1</span> ----------------</span><br><span class="line">    | ExceptionGroup: group2</span><br><span class="line">    +-+---------------- <span class="number">1</span> ----------------</span><br><span class="line">      | RecursionError: <span class="number">4</span></span><br><span class="line">      +------------------------------------</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>注意，嵌套在一个异常组中的异常必须是实例，而不是类型。这是因为在实践中，这些异常通常是那些已经被程序提出并捕获的异常，其模式如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>excs = []</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> test <span class="keyword">in</span> tests:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        test.run()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>        excs.append(e)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> excs:</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">raise</span> ExceptionGroup(<span class="string">&quot;Test Failures&quot;</span>, excs)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="8-10-用注释细化异常情况">8.10. 用注释细化异常情况</h2>
<p>当一个异常被创建以引发时，它通常被初始化为描述所发生错误的信息。在有些情况下，在异常被捕获后添加信息是很有用的。为了这个目的，异常有一个 <code>add_note(note)</code> 方法接受一个字符串，并将其添加到异常的注释列表。标准的回溯在异常之后按照它们被添加的顺序呈现包括所有的注释。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad type&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    e.add_note(<span class="string">&#x27;Add some information&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    e.add_note(<span class="string">&#x27;Add some more information&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad <span class="built_in">type</span></span><br><span class="line">Add some information</span><br><span class="line">Add some more information</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>例如，当把异常收集到一个异常组时，我们可能想为各个错误添加上下文信息。在下文中，组中的每个异常都有一个说明，指出这个错误是什么时候发生的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> OSError(<span class="string">&#x27;operation failed&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>excs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        f()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>        e.add_note(<span class="string">f&#x27;Happened in Iteration <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        excs.append(e)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ExceptionGroup(<span class="string">&#x27;We have some problems&#x27;</span>, excs)</span><br><span class="line">  + Exception Group Traceback (most recent call last):</span><br><span class="line">  |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  | ExceptionGroup: We have some problems (<span class="number">3</span> sub-exceptions)</span><br><span class="line">  +-+---------------- <span class="number">1</span> ----------------</span><br><span class="line">    | Traceback (most recent call last):</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">    | OSError: operation failed</span><br><span class="line">    | Happened <span class="keyword">in</span> Iteration <span class="number">1</span></span><br><span class="line">    +---------------- <span class="number">2</span> ----------------</span><br><span class="line">    | Traceback (most recent call last):</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">    | OSError: operation failed</span><br><span class="line">    | Happened <span class="keyword">in</span> Iteration <span class="number">2</span></span><br><span class="line">    +---------------- <span class="number">3</span> ----------------</span><br><span class="line">    | Traceback (most recent call last):</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    |   File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> f</span><br><span class="line">    | OSError: operation failed</span><br><span class="line">    | Happened <span class="keyword">in</span> Iteration <span class="number">3</span></span><br><span class="line">    +------------------------------------</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1>9. 类</h1>
<p>类提供了把数据和功能绑定在一起的方法。创建新类时创建了新的对象 <em>类型</em>，从而能够创建该类型的新 <em>实例</em>。实例具有能维持自身状态的属性，还具有能修改自身状态的方法（由其所属的类来定义）。</p>
<p>和其他编程语言相比，Python 的类只使用了很少的新语法和语义。Python 的类有点类似于 C++ 和 Modula-3 中类的结合体，而且支持面向对象编程（OOP）的所有标准特性：类的继承机制支持多个基类、派生的类能覆盖基类的方法、类的方法能调用基类中的同名方法。对象可包含任意数量和类型的数据。和模块一样，类也支持 Python 动态特性：在运行时创建，创建后还可以修改。</p>
<p>如果用 C++ 术语来描述的话，类成员（包括数据成员）通常为 <em>public</em> （例外的情况见下文 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-private">私有变量</a>），所有成员函数都为 <em>virtual</em> 。与 Modula-3 中一样，没有用于从对象的方法中引用本对象成员的简写形式：方法函数在声明时，有一个显式的第一个参数代表本对象，该参数由方法调用隐式提供。与在 Smalltalk 中一样，Python 的类也是对象，这为导入和重命名提供了语义支持。与 C+ 和 Modula-3 不同，Python 的内置类型可以用作基类，供用户扩展。此外，与 C++ 一样，具有特殊语法的内置运算符（算术运算符、下标等）都可以为类实例重新定义由于缺乏关于类的公认术语，本章中偶尔会使用 Smalltalk 和 C++ 的术语。本章还会使用 Modula-3 的术语，Modula-3 的面向对象语义比 C++ 更接近 Python，但估计听说过这门语言的读者很少。</p>
<h2 id="9-1-名称和对象">9.1. 名称和对象</h2>
<p>对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者就可以看到更改——无需像 Pascal 那样用两个不同的机制来传参。</p>
<h2 id="9-2-Python-作用域和命名空间">9.2. Python 作用域和命名空间</h2>
<p>在介绍类前，首先要介绍 Python 的作用域规则。类定义对命名空间有一些巧妙的技巧，了解作用域和命名空间的工作机制有利于加强对类的理解。并且，即便对于高级 Python 程序员，这方面的知识也很有用。</p>
<p>接下来，我们先了解一些定义。</p>
<p><em>namespace</em> （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#abs"><code>abs()</code></a> 函数以及内置异常的名称等）；一个模块的全局名称；一个函数调用中的局部名称。对象的属性集合也是命名空间的一种形式。关于命名空间的一个重要知识点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义 <code>maximize</code> 函数，且不会造成混淆。用户使用函数时必须要在函数名前面加上模块名。</p>
<p>点号之后的名称是 <strong>属性</strong>。例如，表达式 <code>z.real</code> 中，<code>real</code> 是对象 <code>z</code> 的属性。严格来说，对模块中名称的引用是属性引用：表达式 <code>modname.funcname</code> 中，<code>modname</code> 是模块对象，<code>funcname</code> 是模块的属性。模块属性和模块中定义的全局名称之间存在直接的映射：它们共享相同的命名空间！</p>
<blockquote>
<p>存在一个例外。 模块对象有一个秘密的只读属性 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__"><code>__dict__</code></a>，它返回用于实现模块命名空间的字典；<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__"><code>__dict__</code></a> 是属性但不是全局名称。 显然，使用这个将违反命名空间实现的抽象，应当仅被用于事后调试器之类的场合。</p>
</blockquote>
<p>属性可以是只读的或者可写的。 在后一种情况下，可以对属性进行赋值。 模块属性是可写的：你可以写入 <code>modname.the_answer = 42</code> 。 也可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del"><code>del</code></a> 语句删除可写属性。 例如，<code>del modname.the_answer</code> 将从名为 <code>modname</code> 对象中移除属性 <code>the_answer</code>。</p>
<p>命名空间是在不同时刻创建的，且拥有不同的生命周期。内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间。内置名称实际上也在模块里，即 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins"><code>builtins</code></a> 。</p>
<p>函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。</p>
<p>一个命名空间的 <em>作用域</em> 是 Python 代码中的一段文本区域，从这个区域可直接访问该命名空间。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。</p>
<p>作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：</p>
<ul>
<li>最内层作用域，包含局部名称，并首先在其中进行搜索</li>
<li>那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。</li>
<li>倒数第二层作用域，包含当前模块的全局名称</li>
<li>最外层（最后搜索）的作用域，是内置名称的命名空间</li>
</ul>
<p>如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 <em>新的</em> 局部变量，而使得同名的外部变量保持不变）。</p>
<p>通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。在函数之外，局部作用域引用与全局作用域一致的命名空间：模块的命名空间。 类定义在局部命名空间内再放置另一个命名空间。</p>
<p>划重点，作用域是按字面文本确定的：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）</p>
<p>Python 有一个特殊规定。如果不存在生效的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 或 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 <code>del x</code> 从局部作用域引用的命名空间中移除对 <code>x</code> 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。</p>
<h3 id="9-2-1-作用域和命名空间示例">9.2.1. 作用域和命名空间示例</h3>
<p>下例演示了如何引用不同作用域和名称空间，以及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 对变量绑定的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line">        spam = <span class="string">&quot;local spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">&quot;nonlocal spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">&quot;global spam&quot;</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line">    do_local()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br></pre></td></tr></table></figure>
<p>示例代码的输出是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After local assignment: test spam</span><br><span class="line">After <span class="keyword">nonlocal</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">After <span class="keyword">global</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">In <span class="keyword">global</span> scope: <span class="keyword">global</span> spam</span><br></pre></td></tr></table></figure>
<p>注意，<strong>局部</strong> 赋值（这是默认状态）不会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 赋值会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定，而 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值会改变模块层级的绑定。</p>
<p>而且，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global"><code>global</code></a> 赋值前没有 <em>spam</em> 的绑定。</p>
<h2 id="9-3-初探类">9.3. 初探类</h2>
<p>类引入了一点新语法，三种新的对象类型和一些新语义。</p>
<h3 id="9-3-1-类定义语法">9.3.1. 类定义语法</h3>
<p>最简单的类定义形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>与函数定义 (<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def"><code>def</code></a> 语句) 一样，类定义必须先执行才能生效。把类定义放在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if"><code>if</code></a> 语句的分支里或函数内部试试。</p>
<p>在实践中，类定义内的语句通常都是函数定义，但也可以是其他语句。这部分内容稍后再讨论。类里的函数定义一般是特殊的参数列表，这是由方法调用的约定规范所指明的 — 同样，稍后再解释。</p>
<p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p>
<p>当 (从结尾处) 正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个围绕类定义所创建的命名空间的包装器；我们将在下一节中了解有关类对象的更多信息。 原始的 (在进入类定义之前有效的) 作用域将重新生效，类对象将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 <code>ClassName</code>)。</p>
<h3 id="9-3-2-Class-对象">9.3.2. Class 对象</h3>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p><em>属性引用</em> 使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 <code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>&quot;A simple example class&quot;</code>。</p>
<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>
<p>实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。 因此一个类可能会定义名为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__"><code>__init__()</code></a> 的特殊方法，就像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure>
<p>当一个类定义了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__"><code>__init__()</code></a> 方法时，类的实例化会自动为新创建的类实例发起调用 <code>__init__()</code>。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>
<p>当然，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__"><code>__init__()</code></a> 方法还有一些参数用于实现更高的灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 <code>__init__()</code>。 例如，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line"><span class="meta">... </span>        self.r = realpart</span><br><span class="line"><span class="meta">... </span>        self.i = imagpart</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.r, x.i</span><br><span class="line">(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-实例对象">9.3.3. 实例对象</h3>
<p>现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>
<p><em>数据属性</em> 对应于 Smalltalk 中的“实例变量”，以及 C++ 中的“数据成员”。 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。 举例来说，如果 <code>x</code> 是上面创建的 <code>MyClass</code> 的实例，则以下代码将打印数值 <code>16</code>，且不保留任何追踪信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> x.counter &lt; <span class="number">10</span>:</span><br><span class="line">    x.counter = x.counter * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x.counter)</span><br><span class="line"><span class="keyword">del</span> x.counter</span><br></pre></td></tr></table></figure>
<p>另一类实例属性引用称为 <em>方法</em>。 方法是“从属于”对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p>
<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 <em>方法对象</em>，不是函数对象。</p>
<h3 id="9-3-4-方法对象">9.3.4. 方法对象</h3>
<p>通常，方法在绑定后立即被调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.f()</span><br></pre></td></tr></table></figure>
<p>在 <code>MyClass</code> 示例中，这将返回字符串 <code>'hello world'</code>。 但是，方法并不是必须立即调用: <code>x.f</code> 是一个方法对象，它可以被保存起来以后再调用。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xf = x.f</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(xf())</span><br></pre></td></tr></table></figure>
<p>将持续打印 <code>hello world</code>，直到结束。</p>
<p>当一个方法被调用时究竟会发生什么？ 你可能已经注意到尽管 <code>f()</code> 的函数定义指定了一个参数，但上面调用 <code>x.f()</code> 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 — 即使参数实际上没有被使用…</p>
<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。 总之，调用一个具有 <em>n</em> 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p>
<p>总而言之，方法的运作方式如下。 当一个实例的非数据属性被引用时，将搜索该实例所属的类。 如果名称表示一个属于函数对象的有效类属性，则指向实例对象和函数对象的引用将被打包为一个方法对象。 当传入一个参数列表调用该方法对象时，将基于实例对象和参数列表构造一个新的参数列表，并传入这个新参数列表调用相应的函数对象。</p>
<h3 id="9-3-5-类和实例变量">9.3.5. 类和实例变量</h3>
<p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line"></span><br><span class="line">    kind = <span class="string">&#x27;canine&#x27;</span>         <span class="comment"># class variable shared by all instances</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name    <span class="comment"># instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">&#x27;Fido&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">&#x27;Buddy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">&#x27;canine&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">&#x27;canine&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.name                  <span class="comment"># unique to d</span></span><br><span class="line"><span class="string">&#x27;Fido&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name                  <span class="comment"># unique to e</span></span><br><span class="line"><span class="string">&#x27;Buddy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>正如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line"></span><br><span class="line">    tricks = []             <span class="comment"># mistaken use of a class variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_trick</span>(<span class="params">self, trick</span>):</span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">&#x27;Fido&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">&#x27;Buddy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">&#x27;roll over&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">&#x27;play dead&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks                <span class="comment"># unexpectedly shared by all dogs</span></span><br><span class="line">[<span class="string">&#x27;roll over&#x27;</span>, <span class="string">&#x27;play dead&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>正确的类设计应该使用实例变量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.tricks = []    <span class="comment"># creates a new empty list for each dog</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_trick</span>(<span class="params">self, trick</span>):</span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">&#x27;Fido&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">&#x27;Buddy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">&#x27;roll over&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">&#x27;play dead&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks</span><br><span class="line">[<span class="string">&#x27;roll over&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.tricks</span><br><span class="line">[<span class="string">&#x27;play dead&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="9-4-补充说明">9.4. 补充说明</h2>
<p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Warehouse</span>:</span><br><span class="line"><span class="meta">... </span>   purpose = <span class="string">&#x27;storage&#x27;</span></span><br><span class="line"><span class="meta">... </span>   region = <span class="string">&#x27;west&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w1 = Warehouse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(w1.purpose, w1.region)</span><br><span class="line">storage west</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w2 = Warehouse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w2.region = <span class="string">&#x27;east&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(w2.purpose, w2.region)</span><br><span class="line">storage east</span><br></pre></td></tr></table></figure>
<p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。 （而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访问；此特性可以通过用 C 编写 Python 扩展来使用。）</p>
<p>客户端应当谨慎地使用数据属性 — 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只要保证避免名称冲突 — 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。</p>
<p>在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。</p>
<p>方法的第一个参数常常被命名为 <code>self</code>。 这也不过就是一个约定: <code>self</code> 这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个 <em>类浏览器</em> 程序的编写可能会依赖于这样的约定。</p>
<p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function defined outside the class</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self, x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(x, x+y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    f = f1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">    h = g</span><br></pre></td></tr></table></figure>
<p>现在 <code>f</code>、<code>g</code> 和 <code>h</code> 都 <code>C</code> 类的指向函数对象的属性，因此它们都是 <code>C</code> 实例的方法 — 其中 <code>h</code> 与 <code>g</code> 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑。</p>
<p>方法可以通过使用 <code>self</code> 参数的方法属性调用其他方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bag</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addtwice</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.add(x)</span><br><span class="line">        self.add(x)</span><br></pre></td></tr></table></figure>
<p>方法可以通过与普通函数相同的方式引用全局名称。与方法相关联的全局作用域就是包含该方法的定义语句的模块。（类永远不会被用作全局作用域。）尽管一个人很少会有好的理由在方法中使用全局作用域中的数据，全局作用域依然存在许多合理的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，定义在全局作用域中的函数和类也一样。通常，包含该方法的类本身就定义在全局作用域中，而在下一节中我们将会发现，为何有些时候方法需要引用其所属类。</p>
<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p>
<h2 id="9-5-继承">9.5. 继承</h2>
<p>当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>名称 <code>BaseClassName</code> 必须定义于可从包含所派生的类的定义的作用域访问的命名空间中。 作为基类名称的替代，也允许使用其他任意表达式。 例如，当基类定义在另一个模块中时，这就会很有用处:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(modname.BaseClassName):</span><br></pre></td></tr></table></figure>
<p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p>
<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>
<p>派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以基类方法在尝试调用调用同一基类中定义的另一方法时，可能实际上调用是该基类的派生类中定义的方法。（对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。）</p>
<p>在派生类中的重写方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 <code>BaseClassName.methodname(self, arguments)</code>。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 <code>BaseClassName</code> 的名称被访问时方可使用此方式。）</p>
<p>Python有两个内置函数可被用于继承机制：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 或某个派生自 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的类时为 <code>True</code>。</li>
<li>使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#bool"><code>bool</code></a> 是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 不是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 的子类。</li>
</ul>
<h3 id="9-5-1-多重继承">9.5.1. 多重继承</h3>
<p>Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>对于多数目的来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左到右的，当层次结构存在重叠时不会在同一个类中搜索两次。 因此，如果某个属性在 <code>DerivedClassName</code> 中找不到，就会在 <code>Base1</code> 中搜索它，然后（递归地）在 <code>Base1</code> 的基类中搜索，如果在那里也找不到，就将在 <code>Base2</code> 中搜索，依此类推。</p>
<p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#super"><code>super()</code></a> 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。</p>
<p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#object"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#object"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 <a target="_blank" rel="noopener" href="https://www.python.org/download/releases/2.3/mro/%E3%80%82">https://www.python.org/download/releases/2.3/mro/。</a></p>
<h2 id="9-6-私有变量">9.6. 私有变量</h2>
<p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>
<p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 <em>名称改写</em>。 任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>
<p>名称改写有助于让子类重写方法而不破坏类内方法调用。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mapping</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># private copy of original update() method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingSubclass</span>(<span class="title class_ inherited__">Mapping</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys, values</span>):</span><br><span class="line">        <span class="comment"># provides new signature for update()</span></span><br><span class="line">        <span class="comment"># but does not break __init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure>
<p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>
<p>请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器中。</p>
<p>请注意传递给 <code>exec()</code> 或 <code>eval()</code> 的代码不会将发起调用类的类名视作当前类；这类似于 <code>global</code> 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code>，以及对于 <code>__dict__</code> 的直接引用。</p>
<h2 id="9-7-杂项说明">9.7. 杂项说明</h2>
<p>有时具有类似于 Pascal “record” 或 C “struct” 的数据类型是很有用的，将一些带名称的数据项捆绑在一起。 实现这一目标的理想方式是使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/dataclasses.html#module-dataclasses"><code>dataclasses</code></a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    dept: <span class="built_in">str</span></span><br><span class="line">    salary: <span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>john = Employee(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;computer lab&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john.dept</span><br><span class="line"><span class="string">&#x27;computer lab&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>john.salary</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>一段期望使用特定抽象数据类型的 Python 代码通常可以通过传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.TextIOBase.read"><code>read()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/io.html#io.TextIOBase.readline"><code>readline()</code></a> 方法以便从字典串缓冲区获取数据的类，并将其作为参数传入。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#instance-methods">实例方法对象</a> 也具有属性: <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#method.__self__"><code>m.__self__</code></a> 就是带有 <code>m()</code> 方法的实例对象，而 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#method.__func__"><code>m.__func__</code></a> 就是该方法所对应的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#user-defined-funcs">函数对象</a>。</p>
<h2 id="9-8-迭代器">9.8. 迭代器</h2>
<p>到目前为止，您可能已经注意到大多数容器对象都可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">&quot;123&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 语句会在容器对象上调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#iter"><code>iter()</code></a>。 该函数返回一个定义了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 将引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration"><code>StopIteration</code></a> 异常来通知终止 <code>for</code> 循环。 你可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#next"><code>next()</code></a> 内置函数来调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法；这个例子显示了它的运作方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;str_iterator <span class="built_in">object</span> at <span class="number">0x10c90e650</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">next</span>(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>了解了迭代器协议背后的机制后，就可以轻松地为你的类添加迭代器行为了。 定义 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#container.__iter__"><code>__iter__()</code></a> 方法用于返回一个带有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__"><code>__next__()</code></a> 方法的对象。 如果类已定义了 <code>__next__()</code>，那么 <code>__iter__()</code> 可以简单地返回 <code>self</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rev = Reverse(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(rev)</span><br><span class="line">&lt;__main__.Reverse <span class="built_in">object</span> at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(char)</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<h2 id="9-9-生成器">9.9. 生成器</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-generator">生成器</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield"><code>yield</code></a> 语句。 每次在生成器上调用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#next"><code>next()</code></a> 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">&#x27;golf&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(char)</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure>
<p>可以用生成器来完成的任何功能同样可以通用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__iter__"><code>__iter__()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__"><code>__next__()</code></a> 方法。</p>
<p>另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 <code>self.index</code> 和 <code>self.data</code> 这种实例变量的方式更易编写且更为清晰。</p>
<p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration"><code>StopIteration</code></a>。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p>
<h2 id="9-10-生成器表达式">9.10. 生成器表达式</h2>
<p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))                 <span class="comment"># sum of squares</span></span><br><span class="line"><span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(xvec, yvec))         <span class="comment"># dot product</span></span><br><span class="line"><span class="number">260</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unique_words = <span class="built_in">set</span>(word <span class="keyword">for</span> line <span class="keyword">in</span> page  <span class="keyword">for</span> word <span class="keyword">in</span> line.split())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>valedictorian = <span class="built_in">max</span>((student.gpa, student.name) <span class="keyword">for</span> student <span class="keyword">in</span> graduates)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">&#x27;golf&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h1>10. 标准库简介</h1>
<h2 id="10-1-操作系统接口">10.1. 操作系统接口</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/os.html#module-os"><code>os</code></a> 模块提供了许多与操作系统交互的函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()      <span class="comment"># Return the current working directory</span></span><br><span class="line"><span class="string">&#x27;C:\\Python312&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">&#x27;/server/accesslogs&#x27;</span>)   <span class="comment"># Change current working directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;mkdir today&#x27;</span>)   <span class="comment"># Run the command mkdir in the system shell</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>一定要使用 <code>import os</code> 而不是 <code>from os import *</code> 。这将避免内建的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#open"><code>open()</code></a> 函数被 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/os.html#os.open"><code>os.open()</code></a> 隐式替换掉，因为它们的使用方式大不相同。</p>
<p>内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#dir"><code>dir()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#help"><code>help()</code></a> 函数可用作交互式辅助工具，用于处理大型模块，如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/os.html#module-os"><code>os</code></a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(os)</span><br><span class="line">&lt;returns a <span class="built_in">list</span> of <span class="built_in">all</span> module functions&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">help</span>(os)</span><br><span class="line">&lt;returns an extensive manual page created <span class="keyword">from</span> the module<span class="string">&#x27;s docstrings&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于日常文件和目录管理任务， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/shutil.html#module-shutil"><code>shutil</code></a> 模块提供了更易于使用的更高级别的接口:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shutil</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.copyfile(<span class="string">&#x27;data.db&#x27;</span>, <span class="string">&#x27;archive.db&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;archive.db&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.move(<span class="string">&#x27;/build/executables&#x27;</span>, <span class="string">&#x27;installdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;installdir&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-2-文件通配符">10.2. 文件通配符</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/glob.html#module-glob"><code>glob</code></a> 模块提供了一个在目录中使用通配符搜索创建文件列表的函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">&#x27;*.py&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;primes.py&#x27;</span>, <span class="string">&#x27;random.py&#x27;</span>, <span class="string">&#x27;quote.py&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="10-3-命令行参数">10.3. 命令行参数</h2>
<p>一般的工具脚本常常需要处理命令行参数。 这些参数以列表形式存储在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys"><code>sys</code></a> 模块的 <em>argv</em> 属性中。 举例来说，让我们查看下面的 <code>demo.py</code> 文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File demo.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br></pre></td></tr></table></figure>
<p>以下是在命令行中运行 <code>python demo.py one two three</code> 输出的结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;demo.py&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/argparse.html#module-argparse"><code>argparse</code></a> 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，并可选择要显示的行数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    prog=<span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;Show top lines from each file&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;filenames&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-l&#x27;</span>, <span class="string">&#x27;--lines&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure>
<p>当在通过 <code>python top.py --lines=5 alpha.txt beta.txt</code> 在命令行运行时，该脚本会将 <code>args.lines</code> 设为 <code>5</code> 并将 <code>args.filenames</code> 设为 <code>['alpha.txt', 'beta.txt']</code>。</p>
<h2 id="10-4-错误输出重定向和程序终止">10.4. 错误输出重定向和程序终止</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys"><code>sys</code></a> 模块还具有 <em>stdin</em> ， <em>stdout</em> 和 <em>stderr</em> 的属性。后者对于发出警告和错误消息非常有用，即使在 <em>stdout</em> 被重定向后也可以看到它们:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">&#x27;Warning, log file not found starting a new one\n&#x27;</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure>
<p>终止脚本的最直接方法是使用 <code>sys.exit()</code> 。</p>
<h2 id="10-5-字符串模式匹配">10.5. 字符串模式匹配</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/re.html#module-re"><code>re</code></a> 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优化的解决方案:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="string">&#x27;which foot or hand fell fastest&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;foot&#x27;</span>, <span class="string">&#x27;fell&#x27;</span>, <span class="string">&#x27;fastest&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\b[a-z]+) \1&#x27;</span>, <span class="string">r&#x27;\1&#x27;</span>, <span class="string">&#x27;cat in the the hat&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;cat in the hat&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;tea for too&#x27;</span>.replace(<span class="string">&#x27;too&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;tea for two&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-6-数学">10.6. 数学</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/math.html#module-math"><code>math</code></a> 模块提供对浮点数学的底层C库函数的访问:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.cos(math.pi / <span class="number">4</span>)</span><br><span class="line"><span class="number">0.70710678118654757</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">1024</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/random.html#module-random"><code>random</code></a> 模块提供了进行随机选择的工具:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)   <span class="comment"># sampling without replacement</span></span><br><span class="line">[<span class="number">30</span>, <span class="number">83</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">81</span>, <span class="number">41</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()    <span class="comment"># random float</span></span><br><span class="line"><span class="number">0.17970987693706186</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">6</span>)    <span class="comment"># random integer chosen from range(6)</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/statistics.html#module-statistics"><code>statistics</code></a> 模块计算数值数据的基本统计属性（均值，中位数，方差等）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> statistics</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="number">2.75</span>, <span class="number">1.75</span>, <span class="number">1.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">1.25</span>, <span class="number">3.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.mean(data)</span><br><span class="line"><span class="number">1.6071428571428572</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.median(data)</span><br><span class="line"><span class="number">1.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.variance(data)</span><br><span class="line"><span class="number">1.3720238095238095</span></span><br></pre></td></tr></table></figure>
<p>SciPy项目 &lt;<a target="_blank" rel="noopener" href="https://scipy.org/">https://scipy.org</a>&gt; 有许多其他模块用于数值计算。</p>
<h2 id="10-7-互联网访问">10.7. 互联网访问</h2>
<p>有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/urllib.request.html#module-urllib.request"><code>urllib.request</code></a> 用于从URL检索数据，以及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/smtplib.html#module-smtplib"><code>smtplib</code></a> 用于发送邮件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> urlopen(<span class="string">&#x27;http://worldtimeapi.org/api/timezone/etc/UTC.txt&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> line <span class="keyword">in</span> response:</span><br><span class="line"><span class="meta">... </span>        line = line.decode()             <span class="comment"># Convert bytes to a str</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;datetime&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(line.rstrip())         <span class="comment"># Remove trailing newline</span></span><br><span class="line">...</span><br><span class="line">datetime: <span class="number">2022</span>-01-01T01:<span class="number">36</span>:<span class="number">47.689215</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.sendmail(<span class="string">&#x27;soothsayer@example.org&#x27;</span>, <span class="string">&#x27;jcaesar@example.org&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&quot;&quot;&quot;To: jcaesar@example.org</span></span><br><span class="line"><span class="string"><span class="meta">... </span>From: soothsayer@example.org</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Beware the Ides of March.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.quit()</span><br></pre></td></tr></table></figure>
<p>（请注意，第二个示例需要在localhost上运行的邮件服务器。）</p>
<h2 id="10-8-日期和时间">10.8. 日期和时间</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/datetime.html#module-datetime"><code>datetime</code></a> 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dates are easily constructed and formatted</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = date.today()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.date(<span class="number">2003</span>, <span class="number">12</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.strftime(<span class="string">&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;</span>)</span><br><span class="line"><span class="string">&#x27;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># dates support calendar arithmetic</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>birthday = date(<span class="number">1964</span>, <span class="number">7</span>, <span class="number">31</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = now - birthday</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.days</span><br><span class="line"><span class="number">14368</span></span><br></pre></td></tr></table></figure>
<h2 id="10-9-数据压缩">10.9. 数据压缩</h2>
<p>常见的数据存档和压缩格式由模块直接支持，包括：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib"><code>zlib</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/gzip.html#module-gzip"><code>gzip</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/bz2.html#module-bz2"><code>bz2</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/lzma.html#module-lzma"><code>lzma</code></a>, <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile"><code>zipfile</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/tarfile.html#module-tarfile"><code>tarfile</code></a>。:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> zlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">b&#x27;witch which has which witches wrist watch&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = zlib.compress(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(t)</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zlib.decompress(t)</span><br><span class="line"><span class="string">b&#x27;witch which has which witches wrist watch&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zlib.crc32(s)</span><br><span class="line"><span class="number">226805979</span></span><br></pre></td></tr></table></figure>
<h2 id="10-10-性能测量">10.10. 性能测量</h2>
<p>一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以立即回答这些问题的测量工具。</p>
<p>例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/timeit.html#module-timeit"><code>timeit</code></a> 模块可以快速演示在运行效率方面一定的优势:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;t=a; a=b; b=t&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.57535828626024577</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">&#x27;a,b = b,a&#x27;</span>, <span class="string">&#x27;a=1; b=2&#x27;</span>).timeit()</span><br><span class="line"><span class="number">0.54962537085770791</span></span><br></pre></td></tr></table></figure>
<p>与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/timeit.html#module-timeit"><code>timeit</code></a> 的精细粒度级别相反， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/profile.html#module-profile"><code>profile</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/profile.html#module-pstats"><code>pstats</code></a> 模块提供了用于在较大的代码块中识别时间关键部分的工具。</p>
<h2 id="10-11-质量控制">10.11. 质量控制</h2>
<p>开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测试。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/doctest.html#module-doctest"><code>doctest</code></a> 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且它允许doctest模块确保代码保持对文档的真实:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">values</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print(average([20, 30, 70]))</span></span><br><span class="line"><span class="string">    40.0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(values) / <span class="built_in">len</span>(values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testmod()   <span class="comment"># automatically validate the embedded tests</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/unittest.html#module-unittest"><code>unittest</code></a> 模块不像 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/doctest.html#module-doctest"><code>doctest</code></a> 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试集:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStatisticalFunctions</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_average</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertEqual(average([<span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>]), <span class="number">40.0</span>)</span><br><span class="line">        self.assertEqual(<span class="built_in">round</span>(average([<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>]), <span class="number">1</span>), <span class="number">4.3</span>)</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(ZeroDivisionError):</span><br><span class="line">            average([])</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            average(<span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()  <span class="comment"># Calling from the command line invokes all tests</span></span><br></pre></td></tr></table></figure>
<h2 id="10-12-自带电池">10.12. 自带电池</h2>
<p>Python有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/xmlrpc.client.html#module-xmlrpc.client"><code>xmlrpc.client</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/xmlrpc.server.html#module-xmlrpc.server"><code>xmlrpc.server</code></a> 模块使得实现远程过程调用变成了小菜一碟。 尽管存在于模块名称中，但用户不需要直接了解或处理 XML。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/email.html#module-email"><code>email</code></a> 包是一个用于管理电子邮件的库，包括MIME和其他符合 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a> 规范的邮件文档。与 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/smtplib.html#module-smtplib"><code>smtplib</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/poplib.html#module-poplib"><code>poplib</code></a> 不同（它们实际上做的是发送和接收消息），电子邮件包提供完整的工具集，用于构建或解码复杂的消息结构（包括附件）以及实现互联网编码和标头协议。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#module-json"><code>json</code></a> 包为解析这种流行的数据交换格式提供了强大的支持。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv"><code>csv</code></a> 模块支持以逗号分隔值格式直接读取和写入文件，这种格式通常为数据库和电子表格所支持。 XML 处理由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/xml.etree.elementtree.html#module-xml.etree.ElementTree"><code>xml.etree.ElementTree</code></a> ， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/xml.dom.html#module-xml.dom"><code>xml.dom</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/xml.sax.html#module-xml.sax"><code>xml.sax</code></a> 包支持。这些模块和软件包共同大大简化了 Python 应用程序和其他工具之间的数据交换。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/sqlite3.html#module-sqlite3"><code>sqlite3</code></a> 模块是 SQLite 数据库库的包装器，提供了一个可以使用稍微非标准的 SQL 语法更新和访问的持久数据库。</li>
<li>国际化由许多模块支持，包括 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/gettext.html#module-gettext"><code>gettext</code></a> ， <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/locale.html#module-locale"><code>locale</code></a> ，以及 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/codecs.html#module-codecs"><code>codecs</code></a> 包。</li>
</ul>
<h1>11. 标准库简介 —— 第二部分</h1>
<p>第二部分涵盖了专业编程所需要的更高级的模块。这些模块很少用在小脚本中。</p>
<h2 id="11-1-格式化输出">11.1. 格式化输出</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/reprlib.html#module-reprlib"><code>reprlib</code></a> 模块提供了一个定制化版本的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> 函数，用于缩略显示大型或深层嵌套的容器对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reprlib.<span class="built_in">repr</span>(<span class="built_in">set</span>(<span class="string">&#x27;supercalifragilisticexpialidocious&#x27;</span>))</span><br><span class="line"><span class="string">&quot;&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, ...&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/pprint.html#module-pprint"><code>pprint</code></a> 模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结构:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = [[[[<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>], <span class="string">&#x27;white&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]], [[<span class="string">&#x27;magenta&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;yellow&#x27;</span>], <span class="string">&#x27;blue&#x27;</span>]]]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(t, width=<span class="number">30</span>)</span><br><span class="line">[[[[<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>],</span><br><span class="line">   <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">   [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]],</span><br><span class="line">  [[<span class="string">&#x27;magenta&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>],</span><br><span class="line">   <span class="string">&#x27;blue&#x27;</span>]]]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/textwrap.html#module-textwrap"><code>textwrap</code></a> 模块能够格式化文本段落，以适应给定的屏幕宽度:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = <span class="string">&quot;&quot;&quot;The wrap() method is just like fill() except that it returns</span></span><br><span class="line"><span class="string"><span class="meta">... </span>a list of strings instead of one big string with newlines to separate</span></span><br><span class="line"><span class="string"><span class="meta">... </span>the wrapped lines.&quot;&quot;&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(textwrap.fill(doc, width=<span class="number">40</span>))</span><br><span class="line">The wrap() method <span class="keyword">is</span> just like fill()</span><br><span class="line"><span class="keyword">except</span> that it returns a <span class="built_in">list</span> of strings</span><br><span class="line">instead of one big string <span class="keyword">with</span> newlines</span><br><span class="line">to separate the wrapped lines.</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/locale.html#module-locale"><code>locale</code></a> 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping 属性，可直接将数字格式化为带有组分隔符的样式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> locale</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.setlocale(locale.LC_ALL, <span class="string">&#x27;English_United States.1252&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;English_United States.1252&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conv = locale.localeconv()          <span class="comment"># get a mapping of conventions</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1234567.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.format_string(<span class="string">&quot;%d&quot;</span>, x, grouping=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&#x27;1,234,567&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.format_string(<span class="string">&quot;%s%.*f&quot;</span>, (conv[<span class="string">&#x27;currency_symbol&#x27;</span>],</span><br><span class="line"><span class="meta">... </span>                     conv[<span class="string">&#x27;frac_digits&#x27;</span>], x), grouping=<span class="literal">True</span>)</span><br><span class="line"><span class="string">&#x27;$1,234,567.80&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="11-2-模板">11.2. 模板</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#module-string"><code>string</code></a> 模块包含一个通用的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#string.Template"><code>Template</code></a> 类，具有适用于最终用户的简化语法。它允许用户在不更改应用逻辑的情况下定制自己的应用。</p>
<p>上述格式化操作是通过占位符实现的，占位符由 <code>$</code> 加上合法的 Python 标识符（只能包含字母、数字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而无需空格分割。<code>$$</code> 将被转义成单个字符 <code>$</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Template(<span class="string">&#x27;$&#123;village&#125;folk send $$10 to $cause.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.substitute(village=<span class="string">&#x27;Nottingham&#x27;</span>, cause=<span class="string">&#x27;the ditch fund&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Nottinghamfolk send $10 to the ditch fund.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果在字典或关键字参数中未提供某个占位符的值，那么 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#string.Template.substitute"><code>substitute()</code></a> 方法将抛出 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError"><code>KeyError</code></a>。对于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#string.Template.safe_substitute"><code>safe_substitute()</code></a> 方法更加合适 —— 如果数据缺失，它会直接将占位符原样保留。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Template(<span class="string">&#x27;Return the $item to $owner.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(item=<span class="string">&#x27;unladen swallow&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.substitute(d)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">KeyError: <span class="string">&#x27;owner&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.safe_substitute(d)</span><br><span class="line"><span class="string">&#x27;Return the unladen swallow to $owner.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Template 的子类可以自定义分隔符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分号作为日期、照片序号和照片格式的占位符:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time, os.path</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>photofiles = [<span class="string">&#x27;img_1074.jpg&#x27;</span>, <span class="string">&#x27;img_1076.jpg&#x27;</span>, <span class="string">&#x27;img_1077.jpg&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">BatchRename</span>(<span class="title class_ inherited__">Template</span>):</span><br><span class="line"><span class="meta">... </span>    delimiter = <span class="string">&#x27;%&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fmt = <span class="built_in">input</span>(<span class="string">&#x27;Enter rename style (%d-date %n-seqnum %f-format):  &#x27;</span>)</span><br><span class="line">Enter rename style (%d-date %n-seqnum %f-<span class="built_in">format</span>):  Ashley_%n%f</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = BatchRename(fmt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>date = time.strftime(<span class="string">&#x27;%d%b%y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, filename <span class="keyword">in</span> <span class="built_in">enumerate</span>(photofiles):</span><br><span class="line"><span class="meta">... </span>    base, ext = os.path.splitext(filename)</span><br><span class="line"><span class="meta">... </span>    newname = t.substitute(d=date, n=i, f=ext)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; --&gt; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(filename, newname))</span><br><span class="line"></span><br><span class="line">img_1074.jpg --&gt; Ashley_0.jpg</span><br><span class="line">img_1076.jpg --&gt; Ashley_1.jpg</span><br><span class="line">img_1077.jpg --&gt; Ashley_2.jpg</span><br></pre></td></tr></table></figure>
<p>模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报表和 HTML 网络报表使用自定义模板成为可能。</p>
<h2 id="11-3-使用二进制数据记录格式">11.3. 使用二进制数据记录格式</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/struct.html#module-struct"><code>struct</code></a> 模块提供了 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/struct.html#struct.pack"><code>pack()</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/struct.html#struct.unpack"><code>unpack()</code></a> 函数，用于处理不定长度的二进制记录格式。下面的例子展示了在不使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile"><code>zipfile</code></a> 模块的情况下，如何循环遍历一个 ZIP 文件的所有头信息。Pack 代码 <code>&quot;H&quot;</code> 和 <code>&quot;I&quot;</code> 分别代表两字节和四字节无符号整数。<code>&quot;&lt;&quot;</code> 代表它们是标准尺寸的小端字节序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;myfile.zip&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):                      <span class="comment"># show the first 3 file headers</span></span><br><span class="line">    start += <span class="number">14</span></span><br><span class="line">    fields = struct.unpack(<span class="string">&#x27;&lt;IIIHH&#x27;</span>, data[start:start+<span class="number">16</span>])</span><br><span class="line">    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields</span><br><span class="line"></span><br><span class="line">    start += <span class="number">16</span></span><br><span class="line">    filename = data[start:start+filenamesize]</span><br><span class="line">    start += filenamesize</span><br><span class="line">    extra = data[start:start+extra_size]</span><br><span class="line">    <span class="built_in">print</span>(filename, <span class="built_in">hex</span>(crc32), comp_size, uncomp_size)</span><br><span class="line"></span><br><span class="line">    start += extra_size + comp_size     <span class="comment"># skip to the next header</span></span><br></pre></td></tr></table></figure>
<h2 id="11-4-多线程">11.4. 多线程</h2>
<p>线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并行的线程中。</p>
<p>以下代码展示了高阶的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading"><code>threading</code></a> 模块如何在后台运行任务，且不影响主程序的继续运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, zipfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncZip</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, infile, outfile</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.infile = infile</span><br><span class="line">        self.outfile = outfile</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        f = zipfile.ZipFile(self.outfile, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED)</span><br><span class="line">        f.write(self.infile)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Finished background zip of:&#x27;</span>, self.infile)</span><br><span class="line"></span><br><span class="line">background = AsyncZip(<span class="string">&#x27;mydata.txt&#x27;</span>, <span class="string">&#x27;myarchive.zip&#x27;</span>)</span><br><span class="line">background.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The main program continues to run in foreground.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">background.join()    <span class="comment"># Wait for the background task to finish</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Main program waited until background was done.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。</p>
<p>尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/queue.html#module-queue"><code>queue</code></a> 模块向该线程供应来自其他线程的请求。 应用程序使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue"><code>Queue</code></a> 对象进行线程间通信和协调，更易于设计，更易读，更可靠。</p>
<h2 id="11-5-日志记录">11.5. 日志记录</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#module-logging"><code>logging</code></a> 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或 <code>sys.stderr</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.debug(<span class="string">&#x27;Debugging information&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;Informational message&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;Warning:config file %s not found&#x27;</span>, <span class="string">&#x27;server.conf&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;Error occurred&#x27;</span>)</span><br><span class="line">logging.critical(<span class="string">&#x27;Critical error -- shutting down&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这会产生以下输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:Warning:config file server.conf <span class="keyword">not</span> found</span><br><span class="line">ERROR:root:Error occurred</span><br><span class="line">CRITICAL:root:Critical error -- shutting down</span><br></pre></td></tr></table></figure>
<p>默认情况下，informational 和 debugging 消息被压制，输出会发送到标准错误流。其他输出选项包括将消息转发到电子邮件，数据报，套接字或 HTTP 服务器。新的过滤器可以根据消息优先级选择不同的路由方式：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#logging.DEBUG"><code>DEBUG</code></a>，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#logging.INFO"><code>INFO</code></a>，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#logging.WARNING"><code>WARNING</code></a>，<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#logging.ERROR"><code>ERROR</code></a>，和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/logging.html#logging.CRITICAL"><code>CRITICAL</code></a>。</p>
<p>日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应用程序。</p>
<h2 id="11-6-弱引用">11.6. 弱引用</h2>
<p>Python 会自动进行内存管理（对大多数对象进行引用计数并使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-garbage-collection">garbage collection</a> 来清除循环引用）。 当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。</p>
<p>此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的是，跟踪它们将创建一个会令其永久化的引用。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/weakref.html#module-weakref"><code>weakref</code></a> 模块提供的工具可以不必创建引用就能跟踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。 典型应用包括对创建开销较大的对象进行缓存:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref, gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line"><span class="meta">... </span>        self.value = value</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">str</span>(self.value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="number">10</span>)                   <span class="comment"># create a reference</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;primary&#x27;</span>] = a            <span class="comment"># does not create a reference</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;primary&#x27;</span>]                <span class="comment"># fetch the object if it is still alive</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a                       <span class="comment"># remove the one reference</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()                <span class="comment"># run garbage collection right away</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;primary&#x27;</span>]                <span class="comment"># entry was automatically removed</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    d[<span class="string">&#x27;primary&#x27;</span>]                <span class="comment"># entry was automatically removed</span></span><br><span class="line">  File <span class="string">&quot;C:/python312/lib/weakref.py&quot;</span>, line <span class="number">46</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">    o = self.data[key]()</span><br><span class="line">KeyError: <span class="string">&#x27;primary&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="11-7-用于操作列表的工具">11.7. 用于操作列表的工具</h2>
<p>许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替代实现。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/array.html#module-array"><code>array</code></a> 模块提供了一种 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/array.html#array.array"><code>array()</code></a> 对象，它类似于列表，但只能存储类型一致的数据且存储密度更高。下面演示了一个用双字节无符号整数数组来储存整数的例子（类型码为 <code>&quot;H&quot;</code>），而通常的用 Python 的 int 对象来储存整数的列表，每个表项通常要使用 16 个字节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = array(<span class="string">&#x27;H&#x27;</span>, [<span class="number">4000</span>, <span class="number">10</span>, <span class="number">700</span>, <span class="number">22222</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(a)</span><br><span class="line"><span class="number">26932</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">array(<span class="string">&#x27;H&#x27;</span>, [<span class="number">10</span>, <span class="number">700</span>])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/collections.html#module-collections"><code>collections</code></a> 模块提供了一种 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/collections.html#collections.deque"><code>deque()</code></a> 对象，它类似于列表，但从左端添加和弹出的速度较快，而在中间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque([<span class="string">&quot;task1&quot;</span>, <span class="string">&quot;task2&quot;</span>, <span class="string">&quot;task3&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.append(<span class="string">&quot;task4&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Handling&quot;</span>, d.popleft())</span><br><span class="line">Handling task1</span><br><span class="line">unsearched = deque([starting_node])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">breadth_first_search</span>(<span class="params">unsearched</span>):</span><br><span class="line">    node = unsearched.popleft()</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> gen_moves(node):</span><br><span class="line">        <span class="keyword">if</span> is_goal(m):</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        unsearched.append(m)</span><br></pre></td></tr></table></figure>
<p>在替代的列表实现以外，标准库也提供了其他工具，例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/bisect.html#module-bisect"><code>bisect</code></a> 模块具有用于操作有序列表的函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores = [(<span class="number">100</span>, <span class="string">&#x27;perl&#x27;</span>), (<span class="number">200</span>, <span class="string">&#x27;tcl&#x27;</span>), (<span class="number">400</span>, <span class="string">&#x27;lua&#x27;</span>), (<span class="number">500</span>, <span class="string">&#x27;python&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(scores, (<span class="number">300</span>, <span class="string">&#x27;ruby&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores</span><br><span class="line">[(<span class="number">100</span>, <span class="string">&#x27;perl&#x27;</span>), (<span class="number">200</span>, <span class="string">&#x27;tcl&#x27;</span>), (<span class="number">300</span>, <span class="string">&#x27;ruby&#x27;</span>), (<span class="number">400</span>, <span class="string">&#x27;lua&#x27;</span>), (<span class="number">500</span>, <span class="string">&#x27;python&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/heapq.html#module-heapq"><code>heapq</code></a> 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> heapq <span class="keyword">import</span> heapify, heappop, heappush</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapify(data)                      <span class="comment"># rearrange the list into heap order</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(data, -<span class="number">5</span>)                 <span class="comment"># add a new entry</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[heappop(data) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]  <span class="comment"># fetch the three smallest entries</span></span><br><span class="line">[-<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="11-8-十进制浮点运算">11.8. 十进制浮点运算</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal"><code>decimal</code></a> 模块提供了一种 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 数据类型用于十进制浮点运算。 相比内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 二进制浮点实现，该类特别适用于</p>
<ul>
<li>财务应用和其他需要精确十进制表示的用途，</li>
<li>控制精度，</li>
<li>控制四舍五入以满足法律或监管要求，</li>
<li>跟踪有效小数位，或</li>
<li>用户期望结果与手工完成的计算相匹配的应用程序。</li>
</ul>
<p>例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果结果四舍五入到最接近的分数差异会更大:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(Decimal(<span class="string">&#x27;0.70&#x27;</span>) * Decimal(<span class="string">&#x27;1.05&#x27;</span>), <span class="number">2</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;0.74&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">.70</span> * <span class="number">1.05</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">0.73</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。 Decimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。</p>
<p>精确表示特性使得 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal"><code>Decimal</code></a> 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="string">&#x27;1.00&#x27;</span>) % Decimal(<span class="string">&#x27;.10&#x27;</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;0.00&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.00</span> % <span class="number">0.10</span></span><br><span class="line"><span class="number">0.09999999999999995</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>([Decimal(<span class="string">&#x27;0.1&#x27;</span>)]*<span class="number">10</span>) == Decimal(<span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">1.0</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal"><code>decimal</code></a> 模块提供了运算所需要的足够精度:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcontext().prec = <span class="number">36</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">1</span>) / Decimal(<span class="number">7</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;0.142857142857142857142857142857142857&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1>12. 虚拟环境和包</h1>
<h2 id="12-1-概述">12.1. 概述</h2>
<p>Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。</p>
<p>这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。</p>
<p>这个问题的解决方案是创建一个 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/glossary.html#term-virtual-environment">virtual environment</a>，一个目录树，其中安装有特定Python版本，以及许多其他包。</p>
<p>然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。</p>
<h2 id="12-2-创建虚拟环境">12.2. 创建虚拟环境</h2>
<p>用于创建和管理虚拟环境的模块称为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv"><code>venv</code></a>。<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv"><code>venv</code></a> 通常会安装你可用的最新版本的 Python。如果您的系统上有多个版本的 Python，您可以通过运行 <code>python3</code> 或您想要的任何版本来选择特定的Python版本。</p>
<p>要创建虚拟环境，请确定要放置它的目录，并将 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv"><code>venv</code></a> 模块作为脚本运行目录路径:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv tutorial-env</span><br></pre></td></tr></table></figure>
<p>这将创建 <code>tutorial-env</code> 目录，如果它不存在的话，并在其中创建包含 Python 解释器副本和各种支持文件的目录。</p>
<p>虚拟环境的常用目录位置是 <code>.venv</code>。 这个名称通常会令该目录在你的终端中保持隐藏，从而避免需要对所在目录进行额外解释的一般名称。 它还能防止与某些工具所支持的 <code>.env</code> 环境变量定义文件发生冲突。</p>
<p>创建虚拟环境后，您可以激活它。</p>
<p>在Windows上，运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tutorial-env\Scripts\activate</span><br></pre></td></tr></table></figure>
<p>在Unix或MacOS上，运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source tutorial-env/<span class="built_in">bin</span>/activate</span><br></pre></td></tr></table></figure>
<p>（这个脚本是为bash shell编写的。如果你使用 <strong>csh</strong> 或 <strong>fish</strong> shell，你应该改用 <code>activate.csh</code> 或 <code>activate.fish</code> 脚本。）</p>
<p>激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 <code>python</code> 命令所运行的将是已安装的特定 Python 版本。 例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/envs/tutorial-env/<span class="built_in">bin</span>/activate</span><br><span class="line">(tutorial-env) $ python</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.1</span> (default, May  <span class="number">6</span> <span class="number">2016</span>, <span class="number">10</span>:<span class="number">59</span>:<span class="number">36</span>)</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;/usr/local/lib/python35.zip&#x27;</span>, ...,</span><br><span class="line"><span class="string">&#x27;~/envs/tutorial-env/lib/python3.5/site-packages&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>要撤销激活一个虚拟环境，请输入:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>到终端。</p>
<h2 id="12-3-使用pip管理包">12.3. 使用pip管理包</h2>
<p>你可以使用一个名为 <strong>pip</strong> 的程序来安装、升级和移除软件包。 默认情况下 <code>pip</code> 将从 <a target="_blank" rel="noopener" href="https://pypi.org/">Python Package Index</a> 安装软件包。 你可以在你的 web 浏览器中查看 Python Package Index。</p>
<p><code>pip</code> 有许多子命令: “install”, “uninstall”, “freeze” 等等。 （请在 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index">安装 Python 模块</a> 指南页查看完整的 <code>pip</code> 文档。）</p>
<p>您可以通过指定包的名称来安装最新版本的包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install novas</span><br><span class="line">Collecting novas</span><br><span class="line">  Downloading novas-<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span>.tar.gz (136kB)</span><br><span class="line">Installing collected packages: novas</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> novas</span><br><span class="line">Successfully installed novas-<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
<p>您还可以通过提供包名称后跟 <code>==</code> 和版本号来安装特定版本的包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install requests==<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">Collecting requests==<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">  Using cached requests-<span class="number">2.6</span><span class="number">.0</span>-py2.py3-none-<span class="built_in">any</span>.whl</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">Successfully installed requests-<span class="number">2.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>如果你重新运行这个命令，<code>pip</code> 会注意到已经安装了所请求的版本因而不做任何事。 你可以提供不同的版本号来获取相应版本，或者你可以运行 <code>python -m pip install --upgrade</code> 以将软件包升级到最新版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install --upgrade requests</span><br><span class="line">Collecting requests</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">  Found existing installation: requests <span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">    Uninstalling requests-<span class="number">2.6</span><span class="number">.0</span>:</span><br><span class="line">      Successfully uninstalled requests-<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">Successfully installed requests-<span class="number">2.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p><code>python -m pip uninstall</code> 后跟一个或多个要从虚拟环境中删除的包所对应的名称。</p>
<p><code>python -m pip show</code> 将显示有关某个特定包的信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip show requests</span><br><span class="line">---</span><br><span class="line">Metadata-Version: <span class="number">2.0</span></span><br><span class="line">Name: requests</span><br><span class="line">Version: <span class="number">2.7</span><span class="number">.0</span></span><br><span class="line">Summary: Python HTTP <span class="keyword">for</span> Humans.</span><br><span class="line">Home-page: http://python-requests.org</span><br><span class="line">Author: Kenneth Reitz</span><br><span class="line">Author-email: me@kennethreitz.com</span><br><span class="line">License: Apache <span class="number">2.0</span></span><br><span class="line">Location: /Users/akuchling/envs/tutorial-env/lib/python3<span class="number">.4</span>/site-packages</span><br><span class="line">Requires:</span><br></pre></td></tr></table></figure>
<p><code>python -m pip list</code> 将显示所有在虚拟环境中安装的包:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip <span class="built_in">list</span></span><br><span class="line">novas (<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span>)</span><br><span class="line">numpy (<span class="number">1.9</span><span class="number">.2</span>)</span><br><span class="line">pip (<span class="number">7.0</span><span class="number">.3</span>)</span><br><span class="line">requests (<span class="number">2.7</span><span class="number">.0</span>)</span><br><span class="line">setuptools (<span class="number">16.0</span>)</span><br></pre></td></tr></table></figure>
<p><code>python -m pip freeze</code> 将产生一个类似的已安装包列表，但其输出会使用 <code>python -m pip install</code> 所期望的格式。 一个常见的约定是将此列表放在 <code>requirements.txt</code> 文件中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip freeze &gt; requirements.txt</span><br><span class="line">(tutorial-env) $ cat requirements.txt</span><br><span class="line">novas==<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">numpy==<span class="number">1.9</span><span class="number">.2</span></span><br><span class="line">requests==<span class="number">2.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>然后可以将 <code>requirements.txt</code> 提交给版本控制并作为应用程序的一部分提供。然后用户可以使用 <code>install -r</code> 安装所有必需的包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ python -m pip install -r requirements.txt</span><br><span class="line">Collecting novas==<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span> (<span class="keyword">from</span> -r requirements.txt (line <span class="number">1</span>))</span><br><span class="line">  ...</span><br><span class="line">Collecting numpy==<span class="number">1.9</span><span class="number">.2</span> (<span class="keyword">from</span> -r requirements.txt (line <span class="number">2</span>))</span><br><span class="line">  ...</span><br><span class="line">Collecting requests==<span class="number">2.7</span><span class="number">.0</span> (<span class="keyword">from</span> -r requirements.txt (line <span class="number">3</span>))</span><br><span class="line">  ...</span><br><span class="line">Installing collected packages: novas, numpy, requests</span><br><span class="line">  Running setup.py install <span class="keyword">for</span> novas</span><br><span class="line">Successfully installed novas-<span class="number">3.1</span><span class="number">.1</span><span class="number">.3</span> numpy-<span class="number">1.9</span><span class="number">.2</span> requests-<span class="number">2.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p><code>pip</code> 有更多的选项。 有关 <code>pip</code> 的完整文档请查阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index">安装 Python 模块</a> 指南。 当你编写了一个软件包并希望将其放在 Python Package Index 中时，请查阅 <a target="_blank" rel="noopener" href="https://packaging.python.org/en/latest/tutorials/packaging-projects/">Python packaging user guide</a>。</p>
<h1>13. 接下来？</h1>
<p>阅读本教程可能会增强您对使用Python的兴趣 - 您应该热衷于应用Python来解决您的实际问题。你应该去哪里了解更多？</p>
<p>本教程是Python文档集的一部分。其他文档：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/index.html#library-index">Python 标准库</a>:</p>
<p>你应当浏览一下本手册，其中提供了有关标准库中的类型、函数和模块的完整（但简洁）的参考资料。 标准 Python 分发版包括 <em>许多</em> 附加代码。 这些模块可以完成读取 Unix 邮箱，通过 HTTP 获取文档，生成随机数，解析命令行选项，压缩数据以及许多其他任务。 浏览标准库参考将使你了解有哪些可用的功能。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index">安装 Python 模块</a> 解释了怎么安装由其他Python开发者编写的模块。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/index.html#reference-index">Python 语言参考手册</a>: Python的语法和语义的详细解释。尽管阅读完非常繁重，但作为语言本身的完整指南是有用的。</p>
</li>
</ul>
<p>更多Python资源：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org</a>: Python 主网站。 它包含代码、文档和指向全网 Python 相关网页的链接。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/">https://docs.python.org</a> ：快速访问Python的文档。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://pypi.org/">https://pypi.org</a>: The Python Package Index，以前也被昵称为 Cheese Shop [<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/whatnow.html#id2">1]</a>，是可下载用户自制 Python 模块的索引。 当你要开始发布代码时，你可以在此处进行注册以便其他人能找到它。</p>
<blockquote>
<p>“Cheese Shop”是 Monty Python 的一个短剧：一位顾客来到一家奶酪商店，但无论他要哪种奶酪，店员都说没有货。</p>
</blockquote>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://code.activestate.com/recipes/langs/python/">https://code.activestate.com/recipes/langs/python/</a> ：Python Cookbook是一个相当大的代码示例集，更多的模块和有用的脚本。特别值得一看的贡献收集在一本名为Python Cookbook（O’Reilly＆Associates，ISBN 0-596-00797-3）的书中。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://pyvideo.org/">https://pyvideo.org</a> 收集了来自研讨会和用户组会议的 Python 相关视频的链接。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://scipy.org/">https://scipy.org</a> ：Scientific Python 项目包含用于快速矩阵计算和操作的模块，以及用于诸如线性代数，傅里叶变换，非线性求解器，随机数分布，统计分析等的一系列包。</p>
</li>
</ul>
<p>对于与Python相关的问题和问题报告，您可以发布到新闻组 <em>comp.lang.python</em> ，或者将它们发送到邮件列表python-<a href="mailto:list@python.org">list@python.org</a>。新闻组和邮件列表是互通的，因此发布到一个地方将自动转发给另一个。每天有数百个帖子，询问（和回答）问题，建议新功能，以及宣布新模块。邮件列表档案可在 <a target="_blank" rel="noopener" href="https://mail.python.org/pipermail/">https://mail.python.org/pipermail/</a> 上找到。</p>
<p>在发问之前，请务必查看以下列表 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/faq/index.html#faq-index">常见问题</a> （或简写为 FAQ）。常见问题包含了很多一次又一次被提出的问题及其答案，所以可能已经包含了您的问题解决方案。</p>
<h1>14. 交互式编辑和编辑历史</h1>
<p>某些版本的 Python 解释器支持编辑当前输入行和编辑历史记录，类似 Korn shell 和 GNU Bash shell 的功能 。这个功能使用了 <a target="_blank" rel="noopener" href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a> 来实现，一个支持多种编辑方式的库。这个库有它自己的文档，在这里我们就不重复说明了。</p>
<h2 id="14-1-Tab-补全和编辑历史">14.1. Tab 补全和编辑历史</h2>
<p>在解释器启动的时候变量和模块名补全功能将 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/site.html#rlcompleter-config">自动启用</a> 以便在按下 Tab 键时发起调用补全函数；它会查找 Python 语句名称、当前局部变量和可用的模块名称。 对于带点号的表达式如 <code>string.a</code>，它会对该表达式最后一个 <code>'.'</code> 之前的部分求值然后根据结果对象的属性给出补全建议。 请注意如果具有 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__"><code>__getattr__()</code></a> 方法的对象是该表达式的一部分这可能会执行应用程序定义的代码。 默认配置还会将你的编辑历史保存到你的用户目录下名为 <code>.python_history</code> 的文件。 该历史在下一次交互式解释器会话期间将继续可用。</p>
<h2 id="14-2-默认交互式解释器的替代品">14.2. 默认交互式解释器的替代品</h2>
<p>Python 解释器与早期版本的相比，向前迈进了一大步；无论怎样，还有些希望的功能：如果能在编辑连续行时建议缩进（解析器知道接下来是否需要缩进符号），那将很棒。补全机制可以使用解释器的符号表。有命令去检查（甚至建议）括号，引号以及其他符号是否匹配。</p>
<p>一个可选的增强型交互式解释器是 <a target="_blank" rel="noopener" href="https://ipython.org/">IPython</a>，它已经存在了有一段时间，它具有 tab 补全，探索对象和高级历史记录管理功能。它还可以彻底定制并嵌入到其他应用程序中。另一个相似的增强型交互式环境是 <a target="_blank" rel="noopener" href="https://bpython-interpreter.org/">bpython</a>。</p>
<h1>15. 浮点算术：争议和限制</h1>
<p>浮点数在计算机硬件中是以基数为 2 (二进制) 的小数来表示的。 例如，<strong>十进制</strong> 小数 <code>0.625</code> 的值为 6/10 + 2/100 + 5/1000，而同样的 <strong>二进制</strong> 小数 <code>0.101</code> 的值为 1/2 + 0/4 + 1/8。 这两个小数具有相同的值，唯一的区别在于第一个写成了基数为 10 的小数形式，而第二个则写成的基数为 2 的小数形式。</p>
<p>不幸的是，大多数的十进制小数都不能精确地表示为二进制小数。这导致在大多数情况下，你输入的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。</p>
<p>用十进制来理解这个问题显得更加容易一些。考虑分数 1/3 。我们可以得到它在十进制下的一个近似值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3</span><br></pre></td></tr></table></figure>
<p>或者，更近似的，:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.33</span><br></pre></td></tr></table></figure>
<p>或者，更近似的，:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.333</span><br></pre></td></tr></table></figure>
<p>以此类推。结果是无论你写下多少的数字，它都永远不会等于 1/3 ，只是更加更加地接近 1/3 。</p>
<p>同样的道理，无论你使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为基数的小数。 在以 2 为基数的情况下， 1/10 是一个无限循环小数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0001100110011001100110011001100110011001100110011...</span><br></pre></td></tr></table></figure>
<p>在任何一个位置停下，你都只能得到一个近似值。因此，在今天的大部分架构上，浮点数都只能近似地使用二进制小数表示，对应分数的分子使用每 8 字节的前 53 位表示，分母则表示为 2 的幂次。在 1/10 这个例子中，相应的二进制分数是 <code>3602879701896397 / 2 ** 55</code> ，它很接近 1/10 ，但并不是 1/10 。</p>
<p>由于值的显示方式大多数用户都不会意识到这个差异的存在。 Python 只会打印计算机中存储的二进制值的十进制近似值。 在大部分计算机中，如果 Python 要把 0.1 的二进制值对应的准确的十进制值打印出来，将会显示成这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1000000000000000055511151231257827021181583404541015625</span></span><br></pre></td></tr></table></figure>
<p>这比大多数人认为有用的数位更多，因此 Python 通过改为显示舍入值来保留可管理的数位:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">10</span></span><br><span class="line"><span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可表示的二进制分数。</p>
<p>有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如， <code>0.1</code> 、 <code>0.10000000000000001</code> 、 <code>0.1000000000000000055511151231257827021181583404541015625</code> 全都近似于 <code>3602879701896397 / 2 ** 55</code> 。由于所有这些十进制值都具有相同的近似值，因此可以显示其中任何一个，同时仍然保留不变的 <code>eval(repr(x)) == x</code> 。</p>
<p>在历史上，Python 提示符和内置的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> 函数会选择具有 17 位有效数字的来显示，即 <code>0.10000000000000001</code>。 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中最短的并简单地显示 <code>0.1</code> 。</p>
<p>请注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你会在所有支持你的硬件中的浮点运算的语言中发现同样的情况（虽然某些语言在默认状态或所有输出模块下都不会 <em>显示</em> 这种差异）。</p>
<p>想要更美观的输出，你可能会希望使用字符串格式化来产生限定长度的有效位数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(math.pi, <span class="string">&#x27;.12g&#x27;</span>)  <span class="comment"># give 12 significant digits</span></span><br><span class="line"><span class="string">&#x27;3.14159265359&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(math.pi, <span class="string">&#x27;.2f&#x27;</span>)   <span class="comment"># give 2 digits after the point</span></span><br><span class="line"><span class="string">&#x27;3.14&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(math.pi)</span><br><span class="line"><span class="string">&#x27;3.141592653589793&#x27;</span></span><br></pre></td></tr></table></figure>
<p>必须重点了解的是，这在实际上只是一个假象：你只是将真正的机器码值进行了舍入操作再 <em>显示</em> 而已。</p>
<p>一个假象还可能导致另一个假象。 例如，由于这个 0.1 并非真正的 1/10，将三个 0.1 的值相加也无法恰好得到 0.3:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>而且，由于这个 0.1 无法精确表示 1/10 而这个 0.3 也无法精确表示 3/10 的值，使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#round"><code>round()</code></a> 函数进行预先舍入也是没用的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">0.1</span>, <span class="number">1</span>) + <span class="built_in">round</span>(<span class="number">0.1</span>, <span class="number">1</span>) + <span class="built_in">round</span>(<span class="number">0.1</span>, <span class="number">1</span>) == <span class="built_in">round</span>(<span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>虽然这些数字无法精确表示其所要代表的实际值，但是可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/math.html#math.isclose"><code>math.isclose()</code></a> 函数来进行不精确的值比较:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isclose(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>, <span class="number">0.3</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>或者，也可以使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#round"><code>round()</code></a> 函数来大致地比较近似程度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(math.pi, ndigits=<span class="number">2</span>) == <span class="built_in">round</span>(<span class="number">22</span> / <span class="number">7</span>, ndigits=<span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>二进制浮点运算会有许多这样令人惊讶的情况。 有关 “0.1” 的问题会在下面 “表示性错误” 一节中更精确详细地描述。 请参阅 <a target="_blank" rel="noopener" href="https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/">Examples of Floating Point Problems</a> 获取针对二进制浮点运算机制及在实践中各种常见问题的概要说明。 还可参阅 <a target="_blank" rel="noopener" href="http://www.indowsway.com/floatingpoint.htm">The Perils of Floating Point</a> 获取其他常见意外现象的更完整介绍。</p>
<p>正如那篇文章的结尾所言，“对此问题并无简单的答案。” 但是也不必过于担心浮点数的问题！ Python 浮点运算中的错误是从浮点运算硬件继承而来，而在大多数机器上每次浮点运算得到的 2**53 数码位都会被作为 1 个整体来处理。 这对大多数任务来说都已足够，但你确实需要记住它并非十进制算术，且每次浮点运算都可能会导致新的舍入错误。</p>
<p>虽然病态的情况确实存在，但对于大多数正常的浮点运算使用来说，你只需简单地将最终显示的结果舍入为你期望的十进制数值即可得到你期望的结果。 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a> 通常已足够，对于更精度的控制可参看 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings">格式字符串语法</a> 中 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的格式描述符。</p>
<p>对于需要精确十进制表示的使用场景，请尝试使用 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal"><code>decimal</code></a> 模块，该模块实现了适合会计应用和高精度应用的十进制运算。</p>
<p>另一种形式的精确运算由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/fractions.html#module-fractions"><code>fractions</code></a> 模块提供支持，该模块实现了基于有理数的算术运算（因此可以精确表示像 1/3 这样的数值）。</p>
<p>如果你是浮点运算的重度用户那么你应当了解一下 NumPy 包以及由 SciPy 项目所提供的许多其他数学和统计运算包。 参见 &lt;<a target="_blank" rel="noopener" href="https://scipy.org/">https://scipy.org</a>&gt;。</p>
<p>Python 还提供了一些工具可能在你 <em>确实</em> 想要知道一个浮点数的精确值的少数情况下提供帮助。 例如 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#float.as_integer_ratio"><code>float.as_integer_ratio()</code></a> 方法会将浮点数值表示为一个分数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3.14159</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.as_integer_ratio()</span><br><span class="line">(<span class="number">3537115888337719</span>, <span class="number">1125899906842624</span>)</span><br></pre></td></tr></table></figure>
<p>由于这个比值是精确的，它可以被用来无损地重建原始值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="number">3537115888337719</span> / <span class="number">1125899906842624</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#float.hex"><code>float.hex()</code></a> 方法会以十六进制（以 16 为基数）来表示浮点数，同样能给出保存在你的计算机中的精确值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.<span class="built_in">hex</span>()</span><br><span class="line"><span class="string">&#x27;0x1.921f9f01b866ep+1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种精确的十六进制表示形式可被用来精确地重建浮点数值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="built_in">float</span>.fromhex(<span class="string">&#x27;0x1.921f9f01b866ep+1&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>由于这种表示法是精确的，它适用于跨越不同版本（平台无关）的 Python 移植数值，以及与支持相同格式的其他语言（例如 Java 和 C99）交换数据.</p>
<p>另一个有用的工具是 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#sum"><code>sum()</code></a> 函数，它能够帮助减少求和过程中的精度损失。 它会在数值被添加到总计值的时候为中间舍入步骤使用扩展的精度。 这可以更好地保持总体精确度，使得错误不会积累到能够影响最终总计值的程度:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">1.0</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>([<span class="number">0.1</span>] * <span class="number">10</span>) == <span class="number">1.0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/math.html#math.fsum"><code>math.fsum()</code></a> 更进一步地会在数值被添加到总计值的时候跟踪“丢失的数位”以使得结果只执行一次舍入。 此函数要比 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functions.html#sum"><code>sum()</code></a> 慢但在大量输入几乎相互抵销导致最终总计值接近零的少见场景中将会更为精确:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [-<span class="number">0.10430216751806065</span>, -<span class="number">266310978.67179024</span>, <span class="number">143401161448607.16</span>,</span><br><span class="line"><span class="meta">... </span>       -<span class="number">143401161400469.7</span>, <span class="number">266262841.31058735</span>, -<span class="number">0.003244936839808227</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="built_in">sum</span>(<span class="built_in">map</span>(Fraction, arr)))   <span class="comment"># Exact summation with single rounding</span></span><br><span class="line"><span class="number">8.042173697819788e-13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.fsum(arr)                   <span class="comment"># Single rounding</span></span><br><span class="line"><span class="number">8.042173697819788e-13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(arr)                         <span class="comment"># Multiple roundings in extended precision</span></span><br><span class="line"><span class="number">8.042178034628478e-13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total = <span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line"><span class="meta">... </span>    total += x                   <span class="comment"># Multiple roundings in standard precision</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total                            <span class="comment"># Straight addition has no correct digits!</span></span><br><span class="line">-<span class="number">0.0051575902860057365</span></span><br></pre></td></tr></table></figure>
<h2 id="15-1-表示性错误">15.1. 表示性错误</h2>
<p>本小节将详细解释 “0.1” 的例子，并说明你可以怎样亲自对此类情况进行精确分析。 假定前提是已基本熟悉二进制浮点表示法。</p>
<p><em>表示性错误</em> 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示这一事实造成的错误。 这就是为什么 Python（或者 Perl、C、C++、Java、Fortran 以及许多其他语言）经常不会显示你所期待的精确十进制数值的主要原因。</p>
<p>为什么会这样？ 1/10 是无法用二进制小数精确表示的。 至少从 2000 年起，几乎所有机器都使用 IEEE 754 二进制浮点运算标准，而几乎所有系统平台都将 Python 浮点数映射为 IEEE 754 binary64 “双精度” 值。 IEEE 754 binary64 值包含 53 位精度，因此在输入时计算机会尽量将 0.1 转换为以 <em>J</em>/2**<em>N</em> 形式所能表示的最接近的小数，其中 <em>J</em> 为恰好包含 53 比特位的整数。 重新将</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">10</span> ~= J / (<span class="number">2</span>**N)</span><br></pre></td></tr></table></figure>
<p>写为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J ~= <span class="number">2</span>**N / <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>并且由于 <em>J</em> 恰好有 53 位 (即 <code>&gt;= 2**52</code> 但 <code>&lt; 2**53</code>)，<em>N</em> 的最佳值为 56:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">52</span> &lt;=  <span class="number">2</span>**<span class="number">56</span> // <span class="number">10</span>  &lt; <span class="number">2</span>**<span class="number">53</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>也就是说，56 是唯一能使 <em>J</em> 恰好有 53 位的 <em>N</em> 值。 这样 <em>J</em> 可能的最佳就是舍入之后的商:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q, r = <span class="built_in">divmod</span>(<span class="number">2</span>**<span class="number">56</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>由于余数超于 10 的一半，所以最佳近似值可通过向上舍入获得:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q+<span class="number">1</span></span><br><span class="line"><span class="number">7205759403792794</span></span><br></pre></td></tr></table></figure>
<p>因此在 IEEE 754 双精度下可能达到的 1/10 的最佳近似值为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7205759403792794</span> / <span class="number">2</span> ** <span class="number">56</span></span><br></pre></td></tr></table></figure>
<p>分子和分母都除以二则结果小数为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3602879701896397</span> / <span class="number">2</span> ** <span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略小于 1/10。 但无论如何它都不会是 <em>精确的</em> 1/10！</p>
<p>因此计算机永远不会 “看到” 1/10: 它实际看到的就是上面所给出的小数，即它能达到的最佳 IEEE 754 双精度近似值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> * <span class="number">2</span> ** <span class="number">55</span></span><br><span class="line"><span class="number">3602879701896397.0</span></span><br></pre></td></tr></table></figure>
<p>如果我们将该小数乘以 10**55，我们可以看到该值输出 55 个十进制数位:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3602879701896397</span> * <span class="number">10</span> ** <span class="number">55</span> // <span class="number">2</span> ** <span class="number">55</span></span><br><span class="line"><span class="number">1000000000000000055511151231257827021181583404541015625</span></span><br></pre></td></tr></table></figure>
<p>这意味着存储在计算机中的确切数字等于十进制数值 0.1000000000000000055511151231257827021181583404541015625。 许多语言（包括较旧版本的 Python）都不会显示这个完整的十进制数值，而是将结果舍入到 17 位有效数字:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(<span class="number">0.1</span>, <span class="string">&#x27;.17f&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0.10000000000000001&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/fractions.html#module-fractions"><code>fractions</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal"><code>decimal</code></a> 模块使得这样的计算更为容易:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction.from_float(<span class="number">0.1</span>)</span><br><span class="line">Fraction(<span class="number">3602879701896397</span>, <span class="number">36028797018963968</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0.1</span>).as_integer_ratio()</span><br><span class="line">(<span class="number">3602879701896397</span>, <span class="number">36028797018963968</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal.from_float(<span class="number">0.1</span>)</span><br><span class="line">Decimal(<span class="string">&#x27;0.1000000000000000055511151231257827021181583404541015625&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(Decimal.from_float(<span class="number">0.1</span>), <span class="string">&#x27;.17&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0.10000000000000001&#x27;</span></span><br></pre></td></tr></table></figure>
<h1>16. 附录</h1>
<h2 id="16-1-交互模式">16.1. 交互模式</h2>
<h3 id="16-1-1-错误处理">16.1.1. 错误处理</h3>
<p>当发生错误时，解释器会打印错误消息和栈回溯。 在交互模式下，将返回到主提示符；当输入是来自文件的时候，它将在打印栈回溯之后退出并附带一个非零的退出状态码。 （由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句中 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except"><code>except</code></a> 子句所处理的异常在此上下文中不属于错误。） 有些错误属于无条件致命错误，会导致程序附带非零状态码退出；这适用于内部一致性丧失以及某些内存耗尽的情况等。 所有错误消息都将被写入到标准错误流；来自被执行命令的正常输出测会被写入到标准输出。</p>
<p>将中断字符（通常为 Control-C 或 Delete ）键入主要或辅助提示符会取消输入并返回主提示符。在执行命令时键入中断引发的 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt"><code>KeyboardInterrupt</code></a> 异常，可以由 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try"><code>try</code></a> 语句处理。</p>
<blockquote>
<p>GNU Readline 包的问题可能会阻止这种情况。</p>
</blockquote>
<h3 id="16-1-2-可执行的Python脚本">16.1.2. 可执行的Python脚本</h3>
<p>在 BSD 等类Unix系统上，Python 脚本可以像 shell 脚本一样直接执行，通过在第一行添加：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3.5</span></span><br></pre></td></tr></table></figure>
<p>（假设解释器位于用户的 <code>PATH</code> ）脚本的开头，并将文件设置为可执行。 <code>#!</code> 必须是文件的前两个字符。在某些平台上，第一行必须以Unix样式的行结尾（<code>'\n'</code>）结束，而不是以Windows（<code>'\r\n'</code>）行结尾。注意，“散列字符”，或者说“磅字符”， <code>'#'</code> ，在Python中代表注释开始。</p>
<p>可以使用 <strong>chmod</strong> 命令为脚本提供可执行模式或权限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x myscript.py</span><br></pre></td></tr></table></figure>
<p>在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 <code>.py</code> 文件与 <code>python.exe</code> 相关联，这样双击Python文件就会将其作为脚本运行。扩展也可以是 <code>.pyw</code> ，在这种情况下，会隐藏通常出现的控制台窗口。</p>
<h3 id="16-1-3-交互式启动文件">16.1.3. 交互式启动文件</h3>
<p>当您以交互模式使用 Python 时，您可能会希望在每次启动解释器时，解释器先执行几条您预先编写的命令，然后您再以交互模式继续使用。您可以通过将名为 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONSTARTUP"><code>PYTHONSTARTUP</code></a> 的环境变量设置为包含启动命令的文件的文件名来实现。这类似于 Unix shell 的 <code>.profile</code> 功能。</p>
<p>Python 只有在交互模式时，才会读取此文件，而非在从脚本读指令或是将 <code>/dev/tty</code> 显式作为被运行的 Python 脚本的文件名时（后者反而表现得像一个交互式会话）。这个文件与交互式指令共享相同的命名空间，所以它定义或导入的对象可以在交互式会话中直接使用。您也可以在该文件中更改提示符 <code>sys.ps1</code> 和 <code>sys.ps2</code>。</p>
<p>如果您想 <em>从当前目录中</em> 读取一个额外的启动文件，您可以在上文所说的全局启动文件中编写像 <code>if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())</code> 这样的代码。如果要在脚本中使用启动文件，则必须在脚本中显式执行此操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filename = os.environ.get(<span class="string">&#x27;PYTHONSTARTUP&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> filename <span class="keyword">and</span> os.path.isfile(filename):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> fobj:</span><br><span class="line">        startup_file = fobj.read()</span><br><span class="line">    <span class="built_in">exec</span>(startup_file)</span><br></pre></td></tr></table></figure>
<h3 id="16-1-4-定制模块">16.1.4. 定制模块</h3>
<p>Python 提供了两个钩子供你进行自定义: sitecustomize 和 usercustomize。 要了解它是如何工作的，首先需要找到用户 site-packages 目录的位置。 启动 Python 并运行以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> site</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>site.getusersitepackages()</span><br><span class="line"><span class="string">&#x27;/home/user/.local/lib/python3.5/site-packages&#x27;</span></span><br></pre></td></tr></table></figure>
<p>现在，您可以在该目录中创建一个名为 <code>usercustomize.py</code> 的文件，并将所需内容放入其中。它会影响Python的每次启动，除非它以 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-s"><code>-s</code></a> 选项启动，以禁用自动导入。</p>
<p>sitecustomize 的工作方式相同，但通常由计算机管理员在全局 site-packages 目录中创建，并在 usercustomize 之前导入。 更多细节请参阅 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/site.html#module-site"><code>site</code></a> 模块的文档。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://isSeymour.github.io/butterflyblog">isSeymour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://isseymour.github.io/butterflyblog/2024/01/27/PY-PythonTutorial/">https://isseymour.github.io/butterflyblog/2024/01/27/PY-PythonTutorial/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://isSeymour.github.io/butterflyblog" target="_blank">isSeymour</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/butterflyblog/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/pythontutorial/pythonturorial.png" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY1.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/pay/PAY2.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/butterflyblog/2023/11/12/Algorithm-Error/" title="算法常见报错问题"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/BK7.webp" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法常见报错问题</div></div></a></div><div class="next-post pull-right"><a href="/butterflyblog/2024/01/29/PY-NumPy/" title="《NumPy》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/NumPy/NumPy-0.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《NumPy》Notes</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/butterflyblog/2024/01/31/PY-Matplotlib/" title="《Matplotlib》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/Matplotlib/Matplotlib.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-31</div><div class="title">《Matplotlib》Notes</div></div></a></div><div><a href="/butterflyblog/2024/01/30/PY-SciPy/" title="《SciPy》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/Matplotlib/SciPy.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="title">《SciPy》Notes</div></div></a></div><div><a href="/butterflyblog/2024/01/29/PY-NumPy/" title="《NumPy》Notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/NumPy/NumPy-0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-29</div><div class="title">《NumPy》Notes</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/T6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">isSeymour</div><div class="author-info__description">志之所趋，无远弗届，穷山距海，不能限也。</div></div><div class="card-info-data site-data is-center"><a href="/butterflyblog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/butterflyblog/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/butterflyblog/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/isSeymour/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://isSeymour.github.io/profile/" target="_blank" title="学术主页"><i class="fa-regular fa-address-card" style="color: #000000;"></i></a><a class="social-icon" href="https://github.com/isSeymour/" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/79699613/" target="_blank" title="B站"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_63205991/" target="_blank" title="CSDN"><i class="fa-solid fa-code" style="color: #000000;"></i></a><a class="social-icon" href="mailto:isSeymour@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">《Python Tutorial》Notes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1. 课前甜点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2. Python 解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%B0%83%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-text">2.1. 调用解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E5%87%BA"><span class="toc-text">退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0"><span class="toc-text">2.1.1. 传入参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.1.2. 交互模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-text">2.2. 解释器的运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-text">2.2.1. 源文件的字符编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">3. Python 速览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Python-%E7%94%A8%E4%BD%9C%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-text">3.1. Python 用作计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%95%B0%E5%AD%97"><span class="toc-text">3.1.1. 数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%96%87%E6%9C%AC"><span class="toc-text">3.1.2. 文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%88%97%E8%A1%A8"><span class="toc-text">3.1.3. 列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%B5%B0%E5%90%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-text">3.2. 走向编程的第一步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">4. 更多控制流工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-if-%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.1. if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-for-%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.2. for 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-range-%E5%87%BD%E6%95%B0"><span class="toc-text">4.3. range() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84-break%E3%80%81continue-%E8%AF%AD%E5%8F%A5%E5%8F%8A-else-%E5%AD%90%E5%8F%A5"><span class="toc-text">4.4. 循环中的 break、continue 语句及 else 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-pass-%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.5. pass 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-match-%E8%AF%AD%E5%8F%A5"><span class="toc-text">4.6. match 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-text">4.7. 定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.8. 函数定义详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.1. 默认值参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.2. 关键字参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.3. 特殊参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-1-%E4%BD%8D%E7%BD%AE%E6%88%96%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.3.1. 位置或关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-2-%E4%BB%85%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.3.2. 仅位置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-3-%E4%BB%85%E9%99%90%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-text">4.8.3.3. 仅限关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-4-%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.8.3.4. 函数示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.8.3.5. 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-4-%E4%BB%BB%E6%84%8F%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-text">4.8.4. 任意实参列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-5-%E8%A7%A3%E5%8C%85%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-text">4.8.5. 解包实参列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-6-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4.8.6. Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-7-%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.8.7. 文档字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-8-%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="toc-text">4.8.8. 函数注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%B0%8F%E6%8F%92%E6%9B%B2%EF%BC%9A%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">4.9. 小插曲：编码风格</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">5. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">5.1. 列表详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88"><span class="toc-text">5.1.1. 用列表实现堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E7%94%A8%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">5.1.2. 用列表实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">5.1.3. 列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E5%B5%8C%E5%A5%97%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">5.1.4. 嵌套的列表推导式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-del-%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.2. del 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%85%83%E7%BB%84%E5%92%8C%E5%BA%8F%E5%88%97"><span class="toc-text">5.3. 元组和序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E9%9B%86%E5%90%88"><span class="toc-text">5.4. 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%AD%97%E5%85%B8"><span class="toc-text">5.5. 字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-text">5.6. 循环的技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%B7%B1%E5%85%A5%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-text">5.7. 深入条件控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%BA%8F%E5%88%97%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">5.8. 序列和其他类型的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">6. 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3"><span class="toc-text">6.1. 模块详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E4%BB%A5%E8%84%9A%E6%9C%AC%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9D%97"><span class="toc-text">6.1.1. 以脚本方式执行模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E6%A8%A1%E5%9D%97%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-text">6.1.2. 模块搜索路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E2%80%9C%E5%B7%B2%E7%BC%96%E8%AF%91%E7%9A%84%E2%80%9D-Python-%E6%96%87%E4%BB%B6"><span class="toc-text">6.1.3. “已编译的” Python 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97"><span class="toc-text">6.2. 标准模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-dir-%E5%87%BD%E6%95%B0"><span class="toc-text">6.3. dir() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8C%85"><span class="toc-text">6.4. 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5"><span class="toc-text">6.4.1. 从包中导入 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5"><span class="toc-text">6.4.2. 相对导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-%E5%A4%9A%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E5%8C%85"><span class="toc-text">6.4.3. 多目录中的包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">7. 输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">7.1. 更复杂的输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-text">7.1.1. 格式化字符串字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E5%AD%97%E7%AC%A6%E4%B8%B2-format-%E6%96%B9%E6%B3%95"><span class="toc-text">7.1.2. 字符串 format() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E6%89%8B%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">7.1.3. 手动格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">7.1.4. 旧式字符串格式化方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">7.2. 读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">7.2.1. 文件对象的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E4%BD%BF%E7%94%A8-json-%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-text">7.2.2. 使用 json 保存结构化数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">8. 错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="toc-text">8.1. 语法错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%BC%82%E5%B8%B8"><span class="toc-text">8.2. 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">8.3. 异常的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E8%A7%A6%E5%8F%91%E5%BC%82%E5%B8%B8"><span class="toc-text">8.4. 触发异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-text">8.5. 异常链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">8.6. 用户自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-text">8.7. 定义清理操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B8%85%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-text">8.8. 预定义的清理操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%BC%95%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E4%B8%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">8.9. 引发和处理多个不相关的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E7%94%A8%E6%B3%A8%E9%87%8A%E7%BB%86%E5%8C%96%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5"><span class="toc-text">8.10. 用注释细化异常情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">9. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">9.1. 名称和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Python-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">9.2. Python 作用域和命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.2.1. 作用域和命名空间示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%88%9D%E6%8E%A2%E7%B1%BB"><span class="toc-text">9.3. 初探类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-%E7%B1%BB%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-text">9.3.1. 类定义语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-Class-%E5%AF%B9%E8%B1%A1"><span class="toc-text">9.3.2. Class 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">9.3.3. 实例对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-text">9.3.4. 方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">9.3.5. 类和实例变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">9.4. 补充说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E7%BB%A7%E6%89%BF"><span class="toc-text">9.5. 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">9.5.1. 多重继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-text">9.6. 私有变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E6%9D%82%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="toc-text">9.7. 杂项说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">9.8. 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">9.9. 生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">9.10. 生成器表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">10. 标准库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.1. 操作系统接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%96%87%E4%BB%B6%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">10.2. 文件通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">10.3. 命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2"><span class="toc-text">10.4. 错误输出重定向和程序终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">10.5. 字符串模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E6%95%B0%E5%AD%A6"><span class="toc-text">10.6. 数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%BF%E9%97%AE"><span class="toc-text">10.7. 互联网访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-text">10.8. 日期和时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-text">10.9. 数据压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F"><span class="toc-text">10.10. 性能测量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-11-%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">10.11. 质量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-12-%E8%87%AA%E5%B8%A6%E7%94%B5%E6%B1%A0"><span class="toc-text">10.12. 自带电池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">11. 标准库简介 —— 第二部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">11.1. 格式化输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%A8%A1%E6%9D%BF"><span class="toc-text">11.2. 模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">11.3. 使用二进制数据记录格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">11.4. 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-text">11.5. 日志记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">11.6. 弱引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">11.7. 用于操作列表的工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="toc-text">11.8. 十进制浮点运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">12. 虚拟环境和包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">12.1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="toc-text">12.2. 创建虚拟环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E4%BD%BF%E7%94%A8pip%E7%AE%A1%E7%90%86%E5%8C%85"><span class="toc-text">12.3. 使用pip管理包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">13. 接下来？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">14. 交互式编辑和编辑历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-Tab-%E8%A1%A5%E5%85%A8%E5%92%8C%E7%BC%96%E8%BE%91%E5%8E%86%E5%8F%B2"><span class="toc-text">14.1. Tab 补全和编辑历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E9%BB%98%E8%AE%A4%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81"><span class="toc-text">14.2. 默认交互式解释器的替代品</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">15. 浮点算术：争议和限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E8%A1%A8%E7%A4%BA%E6%80%A7%E9%94%99%E8%AF%AF"><span class="toc-text">15.1. 表示性错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">16. 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-text">16.1. 交互模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">16.1.1. 错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84Python%E8%84%9A%E6%9C%AC"><span class="toc-text">16.1.2. 可执行的Python脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-3-%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-text">16.1.3. 交互式启动文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-4-%E5%AE%9A%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="toc-text">16.1.4. 定制模块</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/07/22/Attention-is-all-you-need/" title="Transformer 开山之作"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/attention-is-all-you-need/attention-page-0.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="Transformer 开山之作"/></a><div class="content"><a class="title" href="/butterflyblog/2025/07/22/Attention-is-all-you-need/" title="Transformer 开山之作">Transformer 开山之作</a><time datetime="2025-07-21T16:00:00.000Z" title="发表于 2025-07-22 00:00:00">2025-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/04/27/LLM4Rec_abc_5/" title="大模型推荐系统 (应用)"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/llm4rec_abc/5/llm4rec-abc-5-Page.webp" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="大模型推荐系统 (应用)"/></a><div class="content"><a class="title" href="/butterflyblog/2025/04/27/LLM4Rec_abc_5/" title="大模型推荐系统 (应用)">大模型推荐系统 (应用)</a><time datetime="2025-04-27T08:00:00.000Z" title="发表于 2025-04-27 16:00:00">2025-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/butterflyblog/2025/04/26/LLM4Rec_abc_4/" title="大模型推荐系统（4）直接推荐范式"><img src="https://cdn.jsdelivr.net/gh/isSeymour/PicGo/posts/llm4rec_abc/4/llm4rec-abc-4-Page.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/blog/page_img/404.jpg'" alt="大模型推荐系统（4）直接推荐范式"/></a><div class="content"><a class="title" href="/butterflyblog/2025/04/26/LLM4Rec_abc_4/" title="大模型推荐系统（4）直接推荐范式">大模型推荐系统（4）直接推荐范式</a><time datetime="2025-04-26T10:00:00.000Z" title="发表于 2025-04-26 18:00:00">2025-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Seymour0314/PicGo/posts/pythontutorial/pythonturorial.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By isSeymour</div><div class="footer_custom_text">欢迎乘坐我的生活地铁！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/butterflyblog/js/utils.js"></script><script src="/butterflyblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liAZxomGv7Hapw8g',
      clientSecret: 'f7cafde192c4ada8bef4b76952c422d90575cf8b',
      repo: 'gitalk',
      owner: 'isSeymour',
      admin: ['isSeymour'],
      id: '9bb227ab869dbd3fd524dfd68e0f13d3',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/butterflyblog/js/search/local-search.js"></script></div></div></body></html>